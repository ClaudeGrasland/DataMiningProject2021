# Agrégation socio-spatiale {#c21-socio-spatial}


## Objectifs

L'objectif de cette section est de procéder à des **agrégations sociales et spatiales** des données individuelles afin de pouvoir ensuite réaliser des cartes.

### Ménages ou habitants ?

La principale difficulté consistera à choisir les bonnes **pondérations** selon que l'on souhaite :

- Travailler sur les **ménages** : par exemple pour connaître le nombre de ménages ayant 0, 1, 2 ou plus de 3 automobiles.
- Travailler sur les **habitants** :  par exemple pour connaître le nombre de personnes ayant plus de 6 ans.

### Département, commune ou IRIS ?

On devra aussi s'intéresser aux variables géographiques disponibles pour réaliser des agrégations spatiales différentes selon que l'on souhaite travailler :

- à l'échelle de l'ensemble du **département** : par exemple, quel est le taux de chômage des actifs du Val de Marne
- à l'échelle des **communes** : par exemple, quel est le taux de chômage des actifs  de Sucy-en-Brie
- à l'échelle des **IRIS** infra-communaux : par exemple, quel est le taux de chômage des actifs du quartier de la Fossse Rouge à Sucy-en Brie.

### Tableaux de contingence et tableaux de profil

Enfin, on fera attention de ne pas mélanger les **stocks** et les **taux** qui correspondent à des tableaux et des variables de nature différente tant pour l'analyse statistique que pour la cartogaphie.

- Un **tableau de contingence** est un tableau de comptage d'individus (habitants ou ménages) dans lequel on peut effectuer les sommes en ligne ou en colonnes. Par exemple, on peut dénombrer les actifs en fonction de leur catégorie socio-professionnelle et de leur commune de résidence. Chacune des cases du tableau correspondra à un nombre d'actifs. 
- **Un tableau de profil (ou de pourcentage)** est une transformation du tableau de contingence permettant de calculer des pourcentages en ligne ou en colonne. Dans l'exemple précédent, si les lignes correspondent aux communes et les colonnes aux CSP, on peut produire soit un tableau des **profils en lignes** (pourcentage des habitants d'une commune travaillant dans une CSP), soit un tableau des **profils en colonnes** (pourcentage des membres d'une CSP résidant dans une commune).

### Packages utilisés

Nous allons nous limiter à un nombre minimum de package au cours de cette première séance dans la mesure où très peu de réalisations cartographiques seront effectuées. 

- **dplyr** : pour la manipulation des tableaux et leur agrégation (inutile de charger l'ensemble du package tidyverse)
- **knitr** : pour afficher proprement les tableaux de résultats
- **ggplot2** : pour visualiser les résultats sous formes de graphiques
- **sf** : pour manipuler les données cartographiques et les agréger


```{r}
library(knitr)
library(dplyr)
library(ggplot2)
library(sf)
```
### Choix d'une commune 

En prévision du projet, chaque étudiant devra choisir une commune qui fera l'objet d'analyse ciblées. Cette commune devra respecter les conditions suivantes :

1. Présence d'au moins 10 IRIS
2. Population supérieure à 20 000 habitants
3. Diversité sociale importante avec mélange de quartiers à profils différents

Une fois identifiée la commune cible chaque étudiant devra trouver son **code officiel géographique** en tapant son nom sur la page web suivante :

https://www.insee.fr/fr/statistiques/zones/2011101

Voici une première liste de communes proposées aux étudiants :


- Champigny-sur-Marne (94017)
- Créteil (94028)
- Fontenay-sous-Bois (94033)
- Ivry-sur-Seine (94041)
- Saint-Maur-des-Fossés (94068)
- Vitry-sur-Seine (94081)
- Vincennes (94080)
- Villejuif (94076)

Le cours prendra quant à lui l'exemple de la commune de Sucy-en-Brie (94071)


### Chargement des données 

Nous avons besoin de trois fichiers

- Le fichier des individus
- le fichier des métadonnées relatives aux individus
- le fonds de carte des IRIS

```{r}
indiv <- readRDS("data/indiv2017.Rdata")
meta <- readRDS("data/indiv_2017_meta.Rdata")
map <-readRDS("data/map_iris.Rdata")
```



## Fichier de référence

Nous allons apprendre dans un premier temps à calculer pour une commune un fichier de référence comportant le nombre d'habitants et le nombre de ménage de chacun des quartiers IRIS. Puis nous y ajouerons le contour géomérique des quartiers IRIS afin de pouvoir réaliser des cartes par la suite.


### Nombre total d'habitants et de ménages de la commune


Comme le recensement n'est pas exhaustif, nous devrons pondérer tous nos calculs par la variable IPONDI qui est définie de la façon suivante dans les métadonnées :

```{r}
metavar<-meta %>% filter(COD_VAR == "IPONDI")
kable(metavar)
```


#### nombre d'habitants de la commune

On commence par créer la variable COM qui n'existe pas mais qui est contenue dans le code IRIS, puis on regroupe par commune et enfin on effectue la somme.

```{r}
indiv %>%  mutate(COM = substr(IRIS,1,5)) %>%
           filter(COM == "94071") %>%
           summarise(nbhab = sum(IPONDI))
        
            
```

On constate que la commune de *Sucy-en-Brie (94071*)* a une population estimée de *26479.068* habitants. 







#### nombre de ménage de la commune

Pour calculer le nombre de ménages, il faut construire un tablean *menag* ne comportant que les personnes de références. Nous allons devoir utiliser pour cela la variable **LPRF** dont on affiche les métadonnées : 


```{r}
metavar<-meta %>% filter(COD_VAR == "LPRF")
kable(metavar)
```
Ce tableau montre que la modalité "1" correspond précisément aux personnes de références. Il faut donc filtrer le tableau des individus sur la condition `LPRF==1`pour ne garder que les ménages.On peut alors dénombrer les ménages en appliquant exactement la même procédure de pondération que pour la population :

```{r}
indiv %>% filter(LPRF == 1) %>%
          mutate(COM = substr(IRIS,1,5)) %>%
          filter(COM == "94071") %>%
          summarise(nbmen = sum(IPONDI))
        
```

D'après le tableau obtenu, il y a 7466.732 ménages (ordinaires) dans la commune de Sucy-en-Brie en 2017


#### Vérification

On se rend sur le site de l'INSEE pour vérifier que les deux chiffres correspondent bien approximativement aux résultats du recensement de 2017



### Nombre d'habitants et de ménages par IRIS

On se propose maintenant d'établir un tableau du nombre d'habitant et du nombre de ménages d'une commune par quartier IRIS.



#### Nombre d'habitants d'une commune par IRIS

On calcule le nombre d'habitants par IRIS à l'aide de l'instruction `group_by`  du package dplyr: 

```{r}
tabpop <- indiv %>%   mutate(COM = substr(IRIS,1,5)) %>%
                      filter(COM == "94071") %>%
                      group_by (IRIS) %>%
                      summarise(nbhab = sum(IPONDI))
kable(tabpop)
```

#### Nombre de ménages d'une commune par IRIS

On calcule le nombre de ménages par IRIS

```{r}
tabmen <- indiv %>%   filter(LPRF == 1) %>%
                      mutate(COM = substr(IRIS,1,5)) %>%
                      filter(COM == "94071") %>%
                      group_by (IRIS) %>%
                      summarise(nbmen = sum(IPONDI))
```

Puis on effectue la jointure des deux tableaux et on crée une nouvelle variable décrivant le nombre moyen de personnes par ménage

```{r}
tabdon <- left_join(tabpop, tabmen) %>%
                    mutate(tailmen = nbhab/nbmen)
kable(tabdon, digits = c(NA,0,0,2))
```
### Ajout de la géométrie 

Notre tableau des IRIS ne comporte pas actuellement de données géométriques permettant la cartographie et on n'y trouve pas non plus le nom ds IRIS. Nous allons donc extraire ces informations du fichier cartographique. Puis nous allons fusionner les deux fichiers pour faire un objet de type `sf`(spatial features) qui pourra être facilement utilisé par la suite pour réaliser des cartes.

#### Extraction des IRIS de la commune

On charge le fichier des IRIS du départmeent et on extrait de celui-ci les contours IRIS de la commune qui nous intéresse.

```{r}
mymap <- map %>% filter(INSEE_COM == "94071") %>%
                 select(CODE_IRIS, NOM_IRIS, TYP_IRIS,NOM_COM, geometry)
  
head(mymap)
```

#### Ajout des coordonnées des centres d'IRIS

On détermine les centres des quartiers IRIS à l'aide d'un combinaison de fonctions SF et on les ajoute au fichier

```{r}
coo<-as.data.frame(st_coordinates(st_centroid(mymap)))

mymap <-cbind(mymap,coo)

kable(mymap)

```




#### Visualisation de la carte

On visualise la carte des iris à l'aide des fonctions `geom_sf` et `geom_text`du package ggplot2

```{r}

ggplot(mymap) +
  geom_sf(fill = "lightyellow") +
  geom_text(aes(x=X, y=Y, label = substr(CODE_IRIS,6,9)), colour = "red") +
  ggtitle("Découpage de la commune de Sucy-en-Brie en IRIS")
```





#### Jointure des deux fichiers

On va maintenant effectuer la joindure avec le tableau de données, mais en faisant attention à recoder la variable IRIS du fichier de données en CODE_IRIS pour assurer la jointure.

```{r}
mapdon <- tabdon %>% rename(CODE_IRIS = IRIS) %>%
                    left_join(mymap)


kable(mapdon)
```

#### Sauvegarde du résultat

On sauvegarde précieusement le fichier final qui servira de référence pour la suite des travaux.

```{r}
saveRDS(mapdon, "data/mapdon_94071.Rdata")
```



### Automatisation du travail

Nous avons maintenant bien décomposé toutes les étapes permettant de créer le fichier de référence pour une commune précise. Il nous reste à automatiser le processus pour une commune quelconque. Nous allons pour cela créer une **fonction** qui permet de créer pour une commune quelconque son fichier de référence.


#### Ecriture de la fonction

Il suffit de reprendre tous les programmes précédents en remplaçant le code 94370 par un argument `codecom` de la fonction qu'on va appeler **mapdon()** : 


```{r}
mapdon <- function(indiv = indiv,
                   map = map,
                   codecom = "94370") 
  {

  
  # (1) Création du tableau de population par IRIS
  tabpop <- indiv %>%   mutate(COM = substr(IRIS,1,5)) %>%
                        filter(COM == codecom) %>%
                        group_by (IRIS) %>%
                        summarise(nbhab = sum(IPONDI))
  
  
  # (2) Création du tableau de ménage par IRIS
  tabmen <- indiv %>% filter(LPRF == 1) %>%
                      mutate(COM = substr(IRIS,1,5)) %>%
                      filter(COM == codecom) %>%
                      group_by (IRIS) %>%
                      summarise(nbmen = sum(IPONDI))
  
  # (3) Fusion des tableaux de données
  tabdon <- left_join(tabpop, tabmen) %>%
                      mutate(tailmen = nbhab/nbmen)
  
  # (4) Extraction du fonds de carte des IRIS
   mymap <- map %>% filter(INSEE_COM == codecom) %>%
                 select(CODE_IRIS, NOM_IRIS, TYP_IRIS,NOM_COM, geometry)
   
  # (5) Ajout des coordonnées des centres d'IRIS
   coo<-as.data.frame(st_coordinates(st_centroid(mymap)))
   mymap <-cbind(mymap,coo)
   
   # (6) Fusion des données et de la géométrie
   mapdon <- tabdon %>% rename(CODE_IRIS = IRIS) %>%
                    left_join(mymap)
   
   # (7) Conversion au format sf
   mapdon<-st_as_sf(mapdon)
   
   # (7) Sortie du résultat
   return(mapdon)
}

```


#### Test de la fonction

Essayons maintenant d'appliquer notre fonction à une autre commune comme Saint-Maur-des-Fossés (94068). Il suffit pour cela de lui fournir les trois paramètres correspondant au tableau de données individuelles, au fonds de carte et au code de la commune

```{r}

# indiv <- readRDS("data/indiv2017.Rdata")
# map <-readRDS("data/map_iris.Rdata")

stmaur <- mapdon(indiv=indiv, 
                 map = map, 
                 codecom = "94068")
class(stmaur)
kable(head(stmaur))
```

On peut visualiser la carte et ses codes :

```{r}
ggplot(stmaur) +
  geom_sf(fill = "lightyellow") +
  geom_text(aes(x=X, y=Y, label = substr(CODE_IRIS,6,9)), colour = "red") +
  ggtitle("Découpage de la commune en IRIS") 
```

Et sauvegarder le résultat s'il est correct : 

```{r}
saveRDS(stmaur, "data/mapdon_94068.Rdata")
```















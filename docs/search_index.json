[["32-functions.html", "Chapitre 6 Fonctions Objectif 6.1 Fonctions de sélection 6.2 Fonctions d’agrégation 6.3 Fonctions de normalisation", " Chapitre 6 Fonctions Linking to GEOS 3.8.1, GDAL 3.1.4, PROJ 6.3.1 Un modèle de donnée n’a d’intérêt que s’il est conçu en fonction d’objectifs qui seront réalisés à l’aide de fonctions exploitant les possibilités du modèle de donnée. Nous allons montrer ici à l’aide de quelques exemples simples l’intérêt du modèle de donnée défini au chapitre précédent. Objectif L’objectif de ce chapitre est de construire une série de fonctions exploitant le modèle de donnée défini précédemment que nous appellerons base. Pour bien mettre en évidence le fait que les fonctions dépendent de ce modèle de données, on leur donnera des noms qui commenceront toujours par ce radical suivi de suffixes. Plus précisément on définira une arborescence de fonctions à l’aide de suffixes de précision croissante. On se place ainsi dans une logique de création d’un package pouvant encapsuler à terme ces différentes fonctions (mais cela dépasse le cadre de ce cours). Les fonctions doivent pouvoir s’applique à n’importe quelle base de données suivant le modèle prescrit. On les testera donc sur au moins trois bases différentes portant respectivement sur les individus âgés de de 18 ans et plus, les actifs mobiles et les ménages ordinaires csp94 : base de données des individus âgés de 18 ans et plus par CSP et par IRIS au RP 2017, contenue dans le fichier VDM_RP2017_CS1_IRIS_POP.Rdata. tra94 : base de données des actifs mobiles et par IRIS selon le mode de transport au 2017, contenue dans le fichier VDM_RP2017_TRANS_IRIS_ACT.Rdata anc94 : base de données des ménages et par IRIS en fonction de l’ancienneté d’installation dans le logement au RP2017, contenue dans le fichier VDM_RP2017_ANEMR_IRIS_MEN.Rdata csp94 &lt;- readRDS(&quot;data/VDM_RP2017_CS1_IRIS_POP.Rdata&quot;) tra94 &lt;- readRDS(&quot;data/VDM_RP2017_TRANS_IRIS_ACT.Rdata&quot;) anc94 &lt;- readRDS(&quot;data/VDM_RP2017_ANEMR_IRIS_MEN.Rdata&quot;) 6.1 Fonctions de sélection Les fonctions utilitaires permettent de transformer une base en une autre base en filtrant ou agrégeant des données selon les dimensions sociales ou spatiales. Le résultat est obligatoirement une base de même type que la base d’origine. 6.1.1 Sélection géographique base_select_geo() On peut tout d’abord effectuer une sélection géographique en ne conservant que certains IRIS. La sélection peut s’effectuer par défaut sur les unités géographique de base i mais elle peut aussi utiliser n’importe quelle variable du fichier geo, notamment les niveaux d’agrégation supérieurs ce qui est en général plus pratique. Pour cela on va commencer par modifier le fichier geo puis le fichier tab et enfin le fichier soc afin d’y éliminer les catégories éventuellement absentes de la zone d’étude. base_select_geo &lt;- function(base = base, var = i2, sel = c(&quot;Geo1&quot;,&quot;Geo2&quot;,&quot;Geo3&quot;)) { b&lt;-base b$geo&lt;- b$geo %&gt;% filter({{var}} %in% sel) b$tab&lt;- b$tab %&gt;% filter(i %in% b$geo$i) b$soc &lt;- b$soc %&gt;% filter(j %in% unique(b$tab$j)) return(b) } Essayons d’appliquer notre fonction à l’extraction des CSP de la commune de Sucy-en-Brie : csp_sucy &lt;- base_select_geo(base = csp94, var = i2, sel = &quot;94071&quot;) On peut vérifier que les trois fichiers ont été modifiés dans la nouvelle base. kable(head(csp_sucy$tab,3)) i j Xij 940710101 2 99 940710101 3 367 940710101 4 269 kable(head(csp_sucy$geo,3)) i lab_i i2 lab_i2 geometry lng lat 940710107 Notre Dame … Bruyeres 94071 Sucy-en-Brie MULTIPOLYGON (((2.557576 48… 2.562682 48.75904 940710103 La Cite Verte 94071 Sucy-en-Brie MULTIPOLYGON (((2.525385 48… 2.521975 48.77332 940710102 La Fosse Rouge 94071 Sucy-en-Brie MULTIPOLYGON (((2.534443 48… 2.527384 48.77628 kable(head(csp_sucy$soc,3)) j var_j lab_j j2 var_j2 lab_j2 2 Catégorie socioprofessionnelle en 8 postes Artisans, commerçants et chefs d’entreprise A CSP des actifs en 3 classes Haut 3 Catégorie socioprofessionnelle en 8 postes Cadres et professions intellectuelles supérieures A CSP des actifs en 3 classes Haut 4 Catégorie socioprofessionnelle en 8 postes Professions Intermédiaires B CSP des actifs en 3 classes Moyen 6.1.2 Sélection sociologique base_select_soc() On peut tout effectuer l’opération symétrique sur les données sociologiques Pour cela on va commencer par modifier le fichier soc puis le fichier tab et enfin le fichier geopour éliminer les unités spatiales où l’ensemble des catégories ciblées sont absentes. base_select_soc &lt;- function(base = base, var = j2, sel = c(&quot;Cat1&quot;,&quot;Cat2&quot;,&quot;Cat3&quot;)) { b&lt;-base b$soc&lt;- b$soc %&gt;% filter({{var}} %in% sel) b$tab&lt;- b$tab %&gt;% filter(j %in% b$soc$j) b$geo &lt;- b$geo %&gt;% filter(i %in% unique(b$tab$i)) return(b) } A titre d’exemple on ne va conserver que les deux modes de transport doux (marche et vélo) dans le fichier des déplacements des actifs : tra_doux &lt;- base_select_soc(base = tra94, var = j2, sel = &quot;A&quot;) On peut vérifier que les trois fichiers ont été modifiés dans la nouvelle base. kable(head(tra_doux$tab,4)) i j Xij 940020101 2 102 940020101 3 56 940020102 2 103 940020102 3 37 kable(head(tra_doux$geo,3)) i lab_i i2 lab_i2 geometry lng lat 940210107 Sorbiers 94021 Chevilly-Larue MULTIPOLYGON (((2.357357 48… 2.357553 48.77377 940680204 Le Vieux Saint-Maur 4 94068 Saint-Maur-des-Fossés MULTIPOLYGON (((2.483923 48… 2.481153 48.80862 940810308 Robespierre 94081 Vitry-sur-Seine MULTIPOLYGON (((2.388071 48… 2.388817 48.79110 kable(head(tra_doux$soc,3)) j var_j lab_j j2 var_j2 lab_j2 2 Mode de transport principal le plus souvent utilisé pour aller travailler Marche à pied (ou rollers, patinette) A Modes de déplacement en 3 classes Marche ou en vélo 3 Mode de transport principal le plus souvent utilisé pour aller travailler Vélo (y compris à assistance électrique) A Modes de déplacement en 3 classes Marche ou en vélo 6.2 Fonctions d’agrégation 6.2.1 Agrégation géographique base_agreg_geo()) Supposons maintenant que l’on veuille transformer notre base de donnée pour la faire passer du niveau des IRIS (i) à celui des communes (i2). Cela va entraîner une modification des fichiers tab et geo mais pas du fichier soc qui demeurera identique. Noter que l’on doir reprojeter les données avant de calculer les centres de polygones et de les agréger base_agreg_geo &lt;- function(base = base, var = i2, lab = lab_i2) { b&lt;-base key &lt;- b$geo %&gt;% select(i, {{var}}) b$tab &lt;-b$tab %&gt;% left_join(key) %&gt;% group_by({{var}},j) %&gt;% mutate(i = as.factor({{var}}),j = j,Xij = sum(Xij)) %&gt;% ungroup()%&gt;% select(i,j,Xij) b$geo &lt;- b$geo %&gt;% st_transform(crs = 2154) %&gt;% mutate(i = {{var}}, lab_i = {{lab}}) %&gt;% group_by(i) %&gt;% summarize(lab_i = unique(lab_i), lat = mean(lat), lng=mean(lng)) %&gt;% ungroup() %&gt;% st_transform(crs = 4326)%&gt;% st_as_sf() return(b) } Appliquons ceci au fichier CSP des IRIS. On obtient une nouvelle base par CSP mais au niveau des communes. Il y a un message d’avertissement concernant l’agrégation des unités spatiales qu’il vaut normalement mieux effectuer après une projection planaire. com &lt;-base_agreg_geo(base = csp94, var = i2, lab = lab_i2) kable(head(com$tab)) i j Xij 94002 2 1030 94002 3 5746 94002 4 6251 94002 5 6783 94002 6 3439 94002 7 5959 kable(head(com$geo)) i lab_i lat lng geometry 94001 Ablon-sur-Seine 48.72462 2.421236 MULTIPOLYGON (((2.43501 48…. 94002 Alfortville 48.79967 2.421002 POLYGON ((2.433383 48.78383… 94003 Arcueil 48.80620 2.333503 POLYGON ((2.343535 48.79781… 94004 Boissy-Saint-Léger 48.75209 2.509456 POLYGON ((2.516929 48.73853… 94011 Bonneuil-sur-Marne 48.77062 2.482723 POLYGON ((2.476012 48.76572… 94015 Bry-sur-Marne 48.83884 2.523050 POLYGON ((2.518283 48.829, … 6.2.2 Agrégation sociologique base_agreg_soc() On reproduit un code équivalent pour procéder à une agrégation des catégories sociales base_agreg_soc &lt;- function(base = base, var = j2, lab = lab_j2) { b&lt;-base key &lt;- b$soc %&gt;% select(j, {{var}}) b$tab &lt;-b$tab %&gt;% left_join(key) %&gt;% group_by(i,{{var}}) %&gt;% mutate(i =i, j= as.factor({{var}}),Xij = sum(Xij)) %&gt;% ungroup()%&gt;% select(i,j,Xij) b$soc &lt;- b$soc %&gt;% mutate(j = {{var}}, lab_j = {{lab}}) %&gt;% select(j,lab_j) return(b) } Appliquons ceci au fichier CSP des IRIS pour le regrouper en 3 catégories. csp3 &lt;-base_agreg_soc(base = csp94, var = j2, lab= lab_j2) kable(head(csp3$tab)) i j Xij 940020101 A 518 940020101 A 518 940020101 B 480 940020101 C 691 940020101 C 691 940020101 NA 695 kable(head(csp3$soc)) j lab_j B Moyen A Haut A Haut B Moyen C Bas C Bas 6.3 Fonctions de normalisation Les fonctions de normalisation sont destinées à transformer les données absolues de comptage en donnée relatives de proportion d’un total pouvant être celui de la ligne (unités spatiales) ou de la colonne (unités sociales). Elles peuvent s’appliquer selon le cas à une variable ou un tableau. 6.3.1 Normalisation géographique base_norm_geo() Cette fonction permet d’exprimer les modalités de la variable en % du total des unités géographiques. Elle va essentiellement modifier le fichier tabauquel on va adjoindre deux colonnes : Xi = effectif total de l’unité spatiale Pj_i = Xij/Xi = probabilité de i sachant j base_norm_geo &lt;- function(base = base) { b &lt;- base tab_i &lt;- b$tab %&gt;% group_by(i) %&gt;% summarize(Xi = sum(Xij)) b$tab &lt;-b$tab %&gt;% left_join(tab_i) %&gt;% mutate(Pj_i = Xij/Xi) return(b) } Par exemple : csp94_geo &lt;- base_norm_geo(csp94) head(csp94_geo$tab) # A tibble: 6 x 5 i j Xij Xi Pj_i &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 940020101 2 97 2384 0.0407 2 940020101 3 421 2384 0.177 3 940020101 4 480 2384 0.201 4 940020101 5 428 2384 0.180 5 940020101 6 263 2384 0.110 6 940020101 7 292 2384 0.122 6.3.2 Normalisation sociologiquebase_norm_soc() Cette fonction permet d’exprimer les modalités de la variable en % du total des catagories sociales. Elle va donc également modifier le fichier tab et lui adjoindre deux autres colonnes : Xj = effectif total de la catégorie Pi_j = Xij/Xi = probabilité de i sachant j base_norm_soc &lt;- function(base = base) { b &lt;- base tab_j &lt;- b$tab %&gt;% group_by(j) %&gt;% summarize(Xj = sum(Xij)) b$tab &lt;-b$tab %&gt;% left_join(tab_j) %&gt;% mutate(Pi_j = Xij/Xi) return(b) } "]]

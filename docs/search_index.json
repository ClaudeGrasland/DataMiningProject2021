[["index.html", "Projet DATA MINING 2021 Master Meci - Parcours Data - Options PISE et CCESE", " Projet DATA MINING 2021 Master Meci - Parcours Data - Options PISE et CCESE C. Grasland et C. Signoretto 2021-03-31 "],["00-presentation.html", "Présentation À propos de ce document Prérequis Remerciements Licence", " Présentation À propos de ce document Ce document est la première version du cours de Data Mining dispensé aux étudiants de deuxième année de l’ option Data du master MECI Il est basé sur R version 4.0.2 (2020-06-22). Ce document est régulièrement corrigé et mis à jour. La version de référence est disponible en ligne à l’adresse : https://ClaudeGrasland.github.io/DataMiningProject2021. Pour toute suggestion ou correction, il est possible de me contacter par mail Prérequis Le seul prérequis pour suivre ce document est d’avoir installé R et RStudio sur votre ordinateur. Il s’agit de deux logiciels libres, gratuits, téléchargeables en ligne et fonctionnant sous PC, Mac et Linux. Pour installer R, il suffit de se rendre sur une des pages suivantes 1 : Installer R sous Windows Installer R sous Mac Pour installer RStudio, rendez-vous sur la page suivante et téléchargez la version adaptée à votre système : https://www.rstudio.com/products/rstudio/download/#download Remerciements Ce document a bénéficié de la relecture et des suggestions … des étudiants qui en ont été les cobayes des premières versions. Ce document est généré par l’excellente extension bookdown de Yihui Xie et il s’est servi du template proposé par Julien Barnier pour introduire des exercices interactifs dans son cours de tidyverse. Licence Ce document est mis à disposition selon les termes de la Licence Creative Commons Attribution - Pas d’Utilisation Commerciale - Partage dans les Mêmes Conditions 4.0 International. Licence Creative Commons Sous Linux, utilisez votre gestionnaire de packages habituel.↩︎ "],["11-data.html", "Chapitre 1 Données 1.1 Introduction 1.2 Données statistiques sur les individus 1.3 Données statistiques sur les logements ordinaires 1.4 Données géométriques 1.5 Bilan et nettoyage", " Chapitre 1 Données library(knitr) library(dplyr) library(data.table) library(readr) library(sf) library(ggplot2) 1.1 Introduction L’objectif du projet Data Mining 2021 consistera à étudier les inégalités sociales et spatiales dans le département du Val de Marne à partir des données du dernier recensement de population de 2017. Ces inégalités seront envisagées à différentes échelles ce qui impliquera des procédures d’agrégation des fichiers détails. 1.2 Données statistiques sur les individus Nous partirons des fichiers détail de l’INSEE car, à la différence des tableaux prédéfinis, ils permettent virtuellement toutes les formes de croisement d’indicateurs. Ils sont évidemment beaucoup plus volumineux, mais ce sera justement l’occasion pour les étudiants en data mining d’être confrontés à des problèmes d’optimisation et de big data. On trouve leur description détaillée sur le site de l’INSEE dans la page consacrée au recensement : https://www.insee.fr/fr/statistiques/4508161 Nous avons opté pour le fichier des individus localisés au canton-ou-ville qui présente une grande polyvalence d’usage puisqu’il permet de reconstituer des tableau agrégés ou l’unité de compte peut-être soit le ménage, soit l’individu selon le critère de pondération adopté. 1.2.1 Etape 1 : téléchargement des données et stockage temporaire Nous allons télécharger ici le fichier des données pour la région Ile-de-France au format .csv et l’enregistrer dans un dossier spécial tmp qui pourra ulétérieurement être détruit ou déplacé afin de libérer de la place N.B. Ce programme qui prend quelques minutes sera exécuté une seule fois. On ajoutera ensuite dans l’en-tête du chunk eval=FALSE ce qui veut dire que ce bloc de code ne sera plus executé automatiquement lorsqu’on réalise un knit du document Rmd. Il sera néanmoins toujours possible de l’executer manuellement en cliquant sur sa petite flèche verte. ### Téléchargement du fichier INSEE download.file(url=&quot;https://www.insee.fr/fr/statistiques/fichier/4802064/RP2017_INDCVIZA_csv.zip&quot;, destfile = &quot;tmp/indiv2017.zip&quot;) ## Decompression du fichier INSEE unzip(zipfile = &quot;tmp/indiv2017.zip&quot;, exdir = &quot;tmp&quot;) ## Examen du contenu list.files(&quot;tmp&quot;) Nous constatons que le document zippé contenait en fait deux fichiers différents Le fichier de données individuelles FD_INDCVIZA_2017.csv : qui pèse au bas mot 1014.3 Mo (1 Giga) et dont nous verrons par la suite qu’il comporte 4.3 millions de lignes et 88 colonnes. Le fichier de métadonnées varmod_INDCVI_2017.csv : qui ne pèse que 1.8 Mo et comprend la description précise du label de chacune des modalités de variables. 1.2.2 Etape 2 : Transformation des données au format R L’importation d’un tableau aussi gros (4.3 millions de lignes et 88 colonnes) donne l’occasion de faire quelques tests de vitesses sur les différents packages capables de lire des fichiers .csv. Nous allons pour cela utiliser la fonction Sys.time()qui permet de repérer l’heure au début et à la fin d’une action. Les résultats dépendront évidemment de la vitesse de l’ordinateur. Il s’agit ici d’un MacBook Pro 2.9 Ghz, disposant de 4 coeurs et 16 Go de mémoire. 1.2.2.1 Chargement avec la fonction read.csv Avec la fonctionread.csv ui fait partie du R-base , le temps de chargement est de 150 secondes. Le tableau résultant est de classe data.frame puisque nous avons utilisé une fonction native de R-base t1&lt;-Sys.time() tab&lt;-read.csv(&quot;tmp/FD_INDCVIZA_2017.csv&quot;, sep = &quot;;&quot;, header =T) t2&lt;-Sys.time() paste (&quot;chargement effectué en&quot;,t2-t1,) dim(tab) class(tab) 1.2.2.2 Chargement avec la fonction read_csv2 avec la fonction read_csv2 du package readr, le chargement est effectué en 59 secondes sur le même ordinateur. Le tableau résultant garde la classe data.frame mais est aussi un tibble puisque le package readr fait partie de l’écosystème tibble/tidyverse. Le temps de chrgement est donc divisé par deux. library(readr) t1&lt;-Sys.time() tab&lt;-read_csv2(&quot;tmp/FD_INDCVIZA_2017.csv&quot;) t2&lt;-Sys.time() paste (&quot;chargement effectué en&quot;,t2-t1, &quot;secondes&quot;) dim(tab) class(tab) 1.2.2.3 Chargement avec la fonction fread avec la fonction fread du package data.table, le chargement est effectué en 31 secondes sur le même ordinateur.Le tableau résultant conserve la classe data.frame mais possède aussi la classe data.table puisque la fonction fread est issue de ce package. Le temps est divisé encore une fois par deux. library(data.table) t1&lt;-Sys.time() tab&lt;-fread(&quot;tmp/FD_INDCVIZA_2017.csv&quot;) t2&lt;-Sys.time() paste (&quot;chargement effectué en&quot;,t2-t1, &quot;secondes&quot;) dim(tab) class(tab) On voit donc que le temps de chargement peut différer fortement selon le choix des packages. Il en va ensuite de même pour les traitements d’agrégation des données qui seront plus ou moins rapides selon que l’on utilise les fonctions de R-base applicables à un data.frame, celles du package tidyverse applicables à un tibble ou enfin celles du package data.table applicables à un data.table. 1.2.3 Etape 3 : Sélection des données utiles et sauvegarde au format .Rdata Nos différentes tableaux peuvent être enregistés au format interne de .R ce qui réduira considérablement leur taille par rapport au fichier texte au format csv qui pèse 1.06 Go. Nous allons également limiter la taille du document en ne conservant que les données qui nous intéressent, en l’occurence celles du département du Val de Marne. Comme ces données bvont nous servir durant tout le projet, elles seront stockées dans le dossier data situé à l’intérieur du projet et non pas dans le dossier tmp qui sera détruit si l’on n’en a plus besoin pour libérer de la place. N.B. On ramène l’objet à la classe d’objet unique data.frame pour éviter des conflits possibles entre package. On pourra toujours le retransformer ensuite en data.table ou en tibble. ## Chargement avec fread (+ rapide) tab&lt;-fread(&quot;tmp/FD_INDCVIZA_2017.csv&quot;) ## Suppression de la classe data.table tab&lt;-as.data.frame(tab) ## Selection des données relatives au Val de Marne sel &lt;- tab %&gt;% filter(DEPT == 94) ## Vérification des dimensions du tableau dim(sel) ## Sauvegarde au format RDS saveRDS(object = sel, file = &quot;data/indiv2017.Rdata&quot;) On peut effectuer de façon facultative une sauvegarde au format .csv ce qui évitera des problème d’ouverture du fichier .Rdata pour les personnes ayant des versions anciennes de R. Mais du coup cela engendrera un fichier très volumineux (200 Mo). ## Sauvegarde au format CSV (facultatif) write.table(x=sel, file = &quot;data/indiv2017.csv&quot;, sep=&quot;;&quot;, dec = &quot;.&quot;, fileEncoding = &quot;UTF-8&quot;) 1.2.3.1 Etape 4 : Chargement et sauvegarde des méta-données Il ne faut surtout pas oublier le fichier des métadonnées qui va permettre de recoder facilement tous les facteurs et de décoder les chiffres correspondant aux classes. On va donc le transformer au format R puis l’enregistrer également dans le dossier data. # Lecture du fichier de métadonnées meta&lt;-fread(&quot;tmp/varmod_INDCVI_2017.csv&quot;) # Enregistrement dans le dossier data saveRDS(object = meta, file = &quot;data/indiv2017_meta.Rdata&quot;) 1.3 Données statistiques sur les logements ordinaires Nous allons reproduire sans les commenter de façon aussi détaillée les mêmes étapes que précédemment pour construire un fichier des logements ordinaires dont la description se trouve à l’adresse suivante : https://www.insee.fr/fr/statistiques/4802056?sommaire=4508161 1.3.1 Etape 1 : récupération des fichiers ### Téléchargement du fichier INSEE download.file(url=&quot;https://www.insee.fr/fr/statistiques/fichier/4802056/RP2017_LOGEMTZA_csv.zip&quot;, destfile = &quot;tmp/logmt2017.zip&quot;) ## Decompression du fichier INSEE unzip(zipfile = &quot;tmp/logmt2017.zip&quot;, exdir = &quot;tmp&quot;) ## Examen du contenu list.files(&quot;tmp&quot;) Comme dans le cas du fichier des individus, on trouve un fichier des données et un fichier des métadonnées qu’il faut tous les deux récupérer. 1.3.2 Etape 2 : Transformation des données au format R On utilise la fonction fread du package data.table qui est la plus rapide ## Chargement avec fread (+ rapide) tab&lt;-fread(&quot;tmp/FD_LOGEMTZA_2017.csv&quot;) 1.3.3 Etape 3 : Sélection des données utiles et sauvegarde au format .Rdata On remet le tableau au format standard data.frame , on sélectionne la zone d’étude et on sauvegarde au format .Rdata. N.B Comme la variable DEPT n’existe pas on utilise les deux premiers chiffres du code de la variable COMMUNE pour la créer ## Suppression de la classe data.table tab&lt;-as.data.frame(tab) ## Selection des données relatives au Val de Marne sel &lt;- tab %&gt;% mutate(DEPT = substr(COMMUNE,1,2)) %&gt;% filter(DEPT == &quot;94&quot;) ## Vérification des dimensions du tableau dim(sel) ## Sauvegarde au format RDS saveRDS(object = sel, file = &quot;data/logmt2017.Rdata&quot;) 1.3.3.1 Etape 4 : Chargement et sauvegarde des méta-données Comme dans le cas des logements, on sauvegarde précieusement le fichier des métadonnées. # Lecture du fichier de métadonnées meta&lt;-fread(&quot;tmp/varmod_LOGEMT_2017.csv&quot;) # Enregistrement dans le dossier data saveRDS(object = meta, file = &quot;data/logmt2017_meta.Rdata&quot;) 1.4 Données géométriques Les contours des unités spatiales correspondant aux codes de l’INSEE sont produits par l’IGN et disponibles sur le site géoservice en accès libre : https://geoservices.ign.fr/documentation/diffusion/telechargement-donnees-libres.html 1.4.1 Etape 1 : récupération du fonds IRIS au format shapefile La principale difficulté est de s’orienter dans l’ensemble des produits disponibles. Dans l’exemple présent, nous cherchhons le contour des IRIS, c’est-à-dire des entités infra-communales correspondant au découpage utilisé lors du recensement de 2017. Comme précédemment, nous allons stocker le résultat du téléchargement dans notre fichier tmp qui sera détruit ou déplacé lorsque nous aurons récupéré toutes les données utiles. download.file(url=&quot;https://wxs.ign.fr/1yhlj2ehpqf3q6dt6a2y7b64/telechargement/inspire/CONTOURS-IRIS-2017-06-30%24CONTOURS-IRIS_2-1__SHP__FRA_2017-06-30/file/CONTOURS-IRIS_2-1__SHP__FRA_2017-06-30.7z&quot;, destfile = &quot;tmp/geom.7z&quot;) Il n’est apparemment pas possible de décompresser le fichier avec la fonction unzip de R, donc on effectue cette opération manuellement. Il en résulte une arborescence très complexe de dossiers et de sous-dossiers correspondant aux IRIS de la Francé métropolitaine mais aussi de chacun des DOM. Il faut alors aller repérer dans cet arborescence le dossier où se trouve le fonds IRIS de la France métropolitaine qui est au format shapefile et comporte plusieurs fichiers avec des extensions différentes. list.files(&quot;tmp/CONTOURS-IRIS_2-1__SHP__FRA_2017-06-30/CONTOURS-IRIS/1_DONNEES_LIVRAISON_2016/CONTOURS-IRIS_2-1_SHP_LAMB93_FE-2016&quot;) [1] &quot;CONTOURS-IRIS.cpg&quot; &quot;CONTOURS-IRIS.dbf&quot; &quot;CONTOURS-IRIS.prj&quot; [4] &quot;CONTOURS-IRIS.shp&quot; &quot;CONTOURS-IRIS.shx&quot; &quot;LISTE.csv&quot; 1.4.2 Etape 2 : Importation et transformation au format sf La cartographie et plus généralement les opérations géométriques sur des données spatiales dans R peuvent facilement être effectuées avec le package sf (spatial features) qui crée des objets ubniques rassemblant à la fois un tableau de données (l’équivalent du fichier .dbf) une géométrie (l’équivalent du fichier .shp) une projection (l’équivalent du fichier .prj) Lorsqu’on récupère des fonds de carte au format shapefile (.shp) ou dans d’autres formats standards comme GeoJson, la première tâche consiste donc à les convertir au formt sf afin de pouvoir les utiliser facilement dans R. L’importation se fait à l’aide de l’instruction st_read en indiquant juste le nom du fichier .shp à charger. Les autres fichiers (.dbf ou .proj) seront lus également et intégrés dans l’objet qui hérite de la double classe data.frame et sf library(sf) map &lt;- st_read(&quot;tmp/CONTOURS-IRIS_2-1__SHP__FRA_2017-06-30/CONTOURS-IRIS/1_DONNEES_LIVRAISON_2016/CONTOURS-IRIS_2-1_SHP_LAMB93_FE-2016/CONTOURS-IRIS.shp&quot;) Reading layer `CONTOURS-IRIS&#39; from data source `/Users/claudegrasland1/Documents/cg/cours/2020_M2_MECI_Datamining/DataMiningProject2021/tmp/CONTOURS-IRIS_2-1__SHP__FRA_2017-06-30/CONTOURS-IRIS/1_DONNEES_LIVRAISON_2016/CONTOURS-IRIS_2-1_SHP_LAMB93_FE-2016/CONTOURS-IRIS.shp&#39; using driver `ESRI Shapefile&#39; Simple feature collection with 49404 features and 6 fields geometry type: MULTIPOLYGON dimension: XY bbox: xmin: 99040 ymin: 6049662 xmax: 1242445 ymax: 7110479 projected CRS: RGF93_Lambert_93 dim(map) [1] 49404 7 class(map) [1] &quot;sf&quot; &quot;data.frame&quot; head(map,2) # A tibble: 2 x 7 INSEE_COM NOM_COM IRIS CODE_IRIS NOM_IRIS TYP_IRIS geometry &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;MULTIPOLYGON [m]&gt; 1 72191 Mayet 0000 721910000 Mayet Z (((498083.5 6747517, 4981… 2 77248 Lesches 0000 772480000 Lesches Z (((685753.1 6868613, 6857… 1.4.3 Etape 3 : Extraction des IRIS de la zone d’étude Le fichier comporte près de 50 000 unités spatiales qui correspondent soit à des communes suffisamment grandes pour être découpées en IRIS, soit à des communes non découpées. On reconnaît ces dernières au fait que leur code IRIS se termine par ‘00000’. Supposons qu’on veuille extraire le fonds de carte du Val de Marne. On va commencer par créer une variable DEPT en extrayant les dxeux premiers caractères du code communal, puis on va sélectionner le départements correspondant : map_iris&lt;-map %&gt;% mutate(DEPT = substr(INSEE_COM,1,2)) %&gt;% filter(DEPT %in% c(&quot;94&quot;)) dim(map_iris) [1] 527 8 class(map_iris) [1] &quot;sf&quot; &quot;data.frame&quot; head(map_iris,2) # A tibble: 2 x 8 INSEE_COM NOM_COM IRIS CODE_IRIS NOM_IRIS TYP_IRIS geometry &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;MULTIPOLYGON [m]&gt; 1 94021 Chevil… 0107 940210107 Sorbiers H (((652774.3 6853051, 652… 2 94068 Saint-… 0204 940680204 Le Vieu… H (((662096.5 6856264, 662… # … with 1 more variable: DEPT &lt;chr&gt; Le nouveau tableau ne comporte plus que 2749 unités spatiales et 8 colonnes au lieu de 7 puisqu’ l’on a ajouté une colonne DEPT. On peut visualiser le résultat à l’aide de la fonction geom_sfdu package ggplot2 : ggplot(map_iris)+geom_sf(fill=&quot;lightyellow&quot;,col=&quot;red&quot;) + theme_void() On sauvegarde le résultat dans notre dossier data au format interne de R : saveRDS(object = map_iris, file = &quot;data/map_iris.Rdata&quot;) On peut également effectuer (de façon facultative) une sauvegarde au format shapefile afin de pouvoir réutiliser le fonds de carte à l’aide d’autres applications externes à R. st_write(obj = map_iris, dsn= &quot;data/map_iris.shp&quot;, # indique le format de sortie par l&#39;extension .shp delete_dsn = TRUE, # écrase le fichier s&#39;il existe déjà quiet = TRUE) # évite que R fasse des commentaires 1.4.4 Etape 4 : création d’un fonds de carte des communes Comme nous serons amenés à travailler à plusieurs échelles, nous produisons tout de suite un fonds de carte des communes en utilisant les fonctions d’agrégation du packages sf combinées avec celles de dplyr. map_com &lt;- map_iris %&gt;% group_by(INSEE_COM) %&gt;% summarise(NOM_COM = min(NOM_COM)) %&gt;% st_as_sf() `summarise()` ungrouping output (override with `.groups` argument) on vérifie que l’agrégation s’est bien passée : ggplot(map_com)+geom_sf(fill=&quot;lightyellow&quot;,col=&quot;red&quot;) + theme_void() Et on sauvegarde le fonds de carte saveRDS(object = map_com, file = &quot;data/map_com.Rdata&quot;) 1.4.5 Etape 5 : création d’un fonds de carte par département Enfin, on construit un fonds de carte des départements selon la même procédure : map_dep &lt;- map_iris %&gt;% mutate(DEPT = substr(INSEE_COM,1,2))%&gt;% group_by(DEPT) %&gt;% summarise() %&gt;% st_as_sf() `summarise()` ungrouping output (override with `.groups` argument) ggplot(map_dep)+geom_sf(fill=&quot;lightyellow&quot;,col=&quot;red&quot;) + theme_void() saveRDS(object = map_dep, file = &quot;data/map_dep.Rdata&quot;) 1.4.6 Etape 6: Superposition des trois fonds de carte On va utiliser la fonction plot du package sf qui permet de visualiser la variable geometry et facilite les superpositions avec l’instruction add=TRUE. par(mar=c(0,0,0,0)) plot(map_iris$geometry, col= &quot;lightyellow&quot;, border = &quot;gray80&quot;, lwd=0.5) plot(map_com$geometry, col= NA, border = &quot;gray50&quot;, lwd=1, add=TRUE) plot(map_dep$geometry, col= NA, border = &quot;gray30&quot;, lwd=2, add=TRUE) 1.5 Bilan et nettoyage Nous avons désormais un dossier data qui comporte : Le fichier des individus et ses métadonnées Le fichier des logements ordinaires et ses métadonnées Les fonds de carte par iris, commune et département. list.files(&quot;data&quot;) [1] &quot;indiv_2017_meta.Rdata&quot; &quot;indiv2017_meta.Rdata&quot; &quot;indiv2017.Rdata&quot; [4] &quot;logmt2017_meta.Rdata&quot; &quot;logmt2017.Rdata&quot; &quot;map_com.Rdata&quot; [7] &quot;map_dep.Rdata&quot; &quot;map_iris.Rdata&quot; &quot;map_VOIT_IRIS.Rdata&quot; [10] &quot;mapdon_94068.Rdata&quot; &quot;mapdon_94071.Rdata&quot; &quot;VOIT_IRIS.Rdata&quot; On peut alors décider de détruire le dossier tmp qui contient des dossiers très volumineux et pas forcément indispensables. "],["12-statistics.html", "Chapitre 2 Analyse statistique I (C.S.) 2.1 Introduction 2.2 Quelques statistiques sur les logements et ménages 2.3 Quelles caractéristiques des individus résidant dans le Val de Marne en 2017 ? 2.4 La création de fonctions", " Chapitre 2 Analyse statistique I (C.S.) # On charge les librairies principales que l&#39;on va utiliser library(knitr) library(tidyverse) library(data.table) library(questionr) library(RColorBrewer) 2.1 Introduction 2.1.1 Les données du Recensement de la Population (RP) Il existe plusieurs fichiers disponibles sur le site de l’Insee concernant l’enquête du Recensement de la Population, la dernière année disponible datant de 2017. Ces fichiers sont lourds, ils peuvent être téléchargés par zone, c’est ce que nous allons faire ensuite. Soit vous le téléchargez via internet et enregistrez le fichier dans un de vos dossiers bien spécifiés et vous le “dézippez”, soit vous le télécharger directement dans R. On va s’intéresser au fichier “Individus localisés au canton-ou-ville” : on le télécharge pour la zone A c’est-à-dire l’Ile-de-France. download.file(url=&quot;https://www.insee.fr/fr/statistiques/fichier/4802064/RP2017_INDCVIZA_csv.zip&quot;, destfile = &quot;tmp/RP2017_INDCVIZA_csv.zip&quot;) #Le fichier a donc été téléchargé dans le dossier intitulé &quot;tmp&quot; du projet R, on va maintenant le dézippé et enregistrer les fichiers extraits dans le même dossier. unzip(&quot;tmp/RP2017_INDCVIZA_csv.zip&quot;, exdir = &quot;tmp&quot;) Il nous reste plus qu’à charger les données dans R : pour cela on utilise la commande fread du package data.table car cela va bien plus vite que les fonctions plus habituelles du type read.csv, et on vérifie en regardant les premiers éléments de la table qu’elle a bien été chargée : #library(data.table) RP &lt;- fread(&quot;tmp/FD_INDCVIZA_2017.csv&quot;, stringsAsFactors=TRUE) RP &lt;- as.data.frame(RP) head(RP) str(RP) On a donc 88 variables et plus de 4 341 175 observations pour l’ensemble de l’Ile de France. Le fait que le nombre d’individus recensés soit inférieur à la population totale de l’Ile de France (plus de 12 millions d’habitants au RP 2017) s’explique par les méthodes de sondage utilisées dans le nouveau recensement en France depuis les années 2000. C’est la raison pour laquelle tous les calculs doivent être pondérés par la variable IPONDIpour être représentatifs Certaines des variables ont été codées comme numériques alors que, selon le dictionnaire des variables, elles devraient être toutes en caractères ou ici dans R en facteurs, on va regarder quelles variables sont concernées et on va les transformer pour qu’elles soient dans le bon format. Ci-dessous, la fonction select_if du package dplyr permet de sélectionner les variables avec une condition (d’où le “if”) donnée entre parenthèses, ici donc si ces variables ont le format “numeric” : RP %&gt;% select_if(is.numeric) %&gt;% names() On en a 23 sur 88, mais attention il y a la variable de pondération IPONDI qui, elle, doit rester numérique, donc on peut procéder au changement de type pour l’ensemble de ces variables sauf celle de pondération, avec la fonction mutate_at en spécifiant l’ensemble des variables concernées (copiées-collées depuis la sortie précédente en veillant bien sûr à bien enlever IPONDI), et vérifier. RP %&gt;% mutate_at(c(&quot;AGED&quot;, &quot;AGER20&quot;, &quot;AGEREV&quot;, &quot;AGEREVQ&quot;, &quot;ANAI&quot;, &quot;CATPC&quot;, &quot;COUPLE&quot;, &quot;CS1&quot;, &quot;DEPT&quot;, &quot;ETUD&quot;, &quot;IMMI&quot;, &quot;INAI&quot;, &quot;INATC&quot;, &quot;MOCO&quot;, &quot;MODV&quot;, &quot;NAIDT&quot;, &quot;ORIDT&quot;, &quot;REGION&quot;, &quot;SEXE&quot;, &quot;STAT_CONJ&quot;,&quot;TACT&quot;, &quot;TACTD16&quot;), factor) %&gt;% select_if(is.numeric) %&gt;% head(5) On remplace maintenant la table et dans le même temps on ne garde que le département du Val de Marne (variable DEPT, modalité '94') sur lequel on va travailler. On procède donc finalement avec le code suivant : RP &lt;- RP %&gt;% mutate_at(c(&quot;AGED&quot;, &quot;AGER20&quot;, &quot;AGEREV&quot;, &quot;AGEREVQ&quot;, &quot;ANAI&quot;, &quot;CATPC&quot;, &quot;COUPLE&quot;, &quot;CS1&quot;, &quot;DEPT&quot;, &quot;ETUD&quot;, &quot;IMMI&quot;, &quot;INAI&quot;, &quot;INATC&quot;, &quot;MOCO&quot;, &quot;MODV&quot;, &quot;NAIDT&quot;, &quot;ORIDT&quot;, &quot;REGION&quot;, &quot;SEXE&quot;, &quot;STAT_CONJ&quot;, &quot;TACT&quot;, &quot;TACTD16&quot;), factor) %&gt;% filter(DEPT==&#39;94&#39;) On se retrouve avec une table moins lourde puisqu’il y a dorénavant 530 007 observations. On peut enregistrer ce fichier, ainsi que celui contenant les métadonnées dans le dossier R au format RDS avec la fonction saveRDS. saveRDS(object = RP, file = &quot;data/indiv2017.Rdata&quot;) # Lecture du fichier de métadonnées et enregistrement dans le dossier Data de notre projet meta &lt;- fread(&quot;tmp/varmod_INDCVI_2017.csv&quot;) # Enregistrement dans le dossier data saveRDS(object = meta, file = &quot;data/indiv_2017_meta.Rdata&quot;) Pour l’importer, il faudra utiliser la fonction readRDS, comme l’exemple ci-dessous (sans l’exécuter) : RP&lt;-readRDS(file =&quot;data/indiv2017.Rdata&quot;) 2.1.2 Quelles variables sont présentes dans les données ? Quelle spécificité ? L’une des difficultés pour l’analyse de cette base de données réside dans les différents niveaux présents : “individu” pour la personne de référence du ménage ; “ménage” regroupant l’ensemble des occupants d’une résidence principale, qu’ils aient ou non des liens de parenté ; “famille” partie d’un ménage comprenant au moins 2 personnes (par exemple, un couple, ou un adulte avec un enfant…) ; et enfin “logement” qui comprend ici les résidences principales, et rassemble des informations décrivant les types de logement. Pour se familiariser avec cette base de données, puisque cette année le projet que vous devrez réaliser porte sur cette base, il faut d’abord étudier les variables qu’elle contient. Un premier travail va ainsi consister à trier les 88 variables selon 5 thèmes : variables décrivant le logement ; variables décrivant le ménage ; variables décrivant la famille ; variables décrivant l’individu ; variables géographiques. Une fois cela effectué, il faut comprendre comment utiliser à bon escient ces différents niveaux. Ainsi, pour toute variable au niveau logement, ménage et famille, il faudra utiliser un filtre : ne prendre que la personne de référence du ménage. On peut toutefois vouloir donner des statistiques sur la “population des ménages”. C’est ce que nous allons voir, en prenant appui sur les statistiques produites par l’Insee pour ce département. 2.2 Quelques statistiques sur les logements et ménages Premier exercice à faire : étudier l’équipement automobile des ménages, en essayant de retrouver les statistiques ci-dessous de l’Insee dont la source est ici. #Emplacement stationnement : RP %&gt;% filter(LPRM==&quot;1&quot;) %&gt;% mutate(Stationnement=recode(GARL, &quot;1&quot;=&quot;Au moins un emplacement réservé au stationnement&quot;, &quot;2&quot; = &quot;Aucun emplacement&quot;)) %&gt;% count(Stationnement, wt=IPONDI) %&gt;% mutate(n=round(n,0),pct=prop.table(n)*100, pct=round(pct, 1)) %&gt;% kable(format.args = list(big.mark = &quot; &quot;)) Stationnement n pct Au moins un emplacement réservé au stationnement 321 768 54.8 Aucun emplacement 264 910 45.2 #Voiture : RP %&gt;% filter(LPRM==&quot;1&quot;) %&gt;% mutate(Voiture=case_when(VOIT %in% c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;) ~ &quot;Au moins une voiture&quot;, VOIT==&quot;0&quot; ~ &quot;Pas de voiture&quot;)) %&gt;% count(Voiture, wt=IPONDI) %&gt;% mutate(n=round(n,0),pct=prop.table(n)*100, pct=round(pct, 1)) %&gt;% kable(format.args = list(big.mark = &quot; &quot;)) Voiture n pct Au moins une voiture 400 704 68.3 Pas de voiture 185 974 31.7 RP %&gt;% filter(LPRM==&quot;1&quot;) %&gt;% mutate(Nb_voiture=case_when(VOIT==&quot;1&quot; ~ &quot;1 voiture&quot;, VOIT %in% c(&quot;2&quot;, &quot;3&quot;) ~ &quot;2 voitures ou plus&quot;, VOIT==&quot;0&quot; ~ &quot;Pas de voiture&quot;)) %&gt;% count(Nb_voiture, wt=IPONDI) %&gt;% mutate(n=round(n,0),pct=prop.table(n)*100, pct=round(pct, 1)) %&gt;% kable(format.args = list(big.mark = &quot; &quot;)) Nb_voiture n pct 1 voiture 295 286 50.3 2 voitures ou plus 105 418 18.0 Pas de voiture 185 974 31.7 Second exercice à faire : étudier l’ancienneté d’emménagement dans la résidence principale en 2017, en essayant de retrouver de même les statistiques ci-dessous de l’Insee (même source : ici) : #Ancienneté d&#39;emménagement en nombre de ménage RP %&gt;% filter(LPRM==&quot;1&quot;) %&gt;% mutate(Anciennete=case_when(ANEMR==&quot;00&quot; ~ &quot;Depuis moins de 2 ans&quot;, ANEMR==&quot;01&quot; ~ &quot;De 2 à 4 ans&quot;, ANEMR==&quot;02&quot; ~ &quot;De 5 à 9 ans&quot;, as.numeric(ANEMR)&gt;3 ~ &quot;10 ans ou plus&quot;), Anciennete = factor(Anciennete, levels=c(&quot;Depuis moins de 2 ans&quot;,&quot;De 2 à 4 ans&quot;,&quot;De 5 à 9 ans&quot;,&quot;10 ans ou plus&quot;))) %&gt;% count(Anciennete, wt=IPONDI) %&gt;% mutate(n=round(n,0),pct=prop.table(n)*100, pct=round(pct, 1)) %&gt;% bind_rows(summarise(Anciennete = &quot;Ensemble&quot;, RP[RP$LPRM==&quot;1&quot;, ], n = sum(IPONDI), pct = 100.0)) %&gt;% kable(format.args = list(big.mark = &quot; &quot;)) Anciennete n pct Depuis moins de 2 ans 67 956 11.6 De 2 à 4 ans 125 587 21.4 De 5 à 9 ans 109 449 18.7 10 ans ou plus 283 686 48.4 Ensemble 586 678 100.0 #Ancienneté d&#39;emménagement en population des ménages RP %&gt;% filter(CATL==&quot;1&quot;) %&gt;% mutate(Anciennete=case_when(ANEMR==&quot;00&quot; ~ &quot;Depuis moins de 2 ans&quot;, ANEMR==&quot;01&quot; ~ &quot;De 2 à 4 ans&quot;, ANEMR==&quot;02&quot; ~ &quot;De 5 à 9 ans&quot;, as.numeric(ANEMR)&gt;3 ~ &quot;10 ans ou plus&quot;), Anciennete = factor(Anciennete, levels=c(&quot;Depuis moins de 2 ans&quot;,&quot;De 2 à 4 ans&quot;,&quot;De 5 à 9 ans&quot;,&quot;10 ans ou plus&quot;)), nb_pieces=as.numeric(as.character(NBPI))) %&gt;% count(Anciennete, wt=IPONDI) %&gt;% mutate(n=round(n,0), pct=prop.table(n)*100, pct=round(pct, 1)) %&gt;% bind_rows(summarise(Anciennete = &quot;Ensemble&quot;, RP[RP$CATL==&quot;1&quot;, ], n = sum(IPONDI), pct = 100.0)) %&gt;% kable(format.args = list(big.mark = &quot; &quot;)) Anciennete n pct Depuis moins de 2 ans 141 773 10.4 De 2 à 4 ans 296 324 21.7 De 5 à 9 ans 293 371 21.5 10 ans ou plus 632 159 46.4 Ensemble 1 363 627 100.0 #Nombre moyen de pièces par logement RP %&gt;% filter(LPRM==&quot;1&quot;) %&gt;% mutate(Anciennete=case_when(ANEMR==&quot;00&quot; ~ &quot;Depuis moins de 2 ans&quot;, ANEMR==&quot;01&quot; ~ &quot;De 2 à 4 ans&quot;, ANEMR==&quot;02&quot; ~ &quot;De 5 à 9 ans&quot;, as.numeric(ANEMR)&gt;3 ~ &quot;10 ans ou plus&quot;), Anciennete = factor(Anciennete, levels=c(&quot;Depuis moins de 2 ans&quot;,&quot;De 2 à 4 ans&quot;,&quot;De 5 à 9 ans&quot;,&quot;10 ans ou plus&quot;)), Np_pieces=as.numeric(as.character(NBPI))) %&gt;% group_by(Anciennete) %&gt;% summarise(Np_pieces_moy=weighted.mean(Np_pieces, IPONDI, na.rm=T)) %&gt;% bind_rows(summarise(Anciennete = &quot;Ensemble&quot;, RP[RP$LPRM==&quot;1&quot;, ], Np_pieces_moy = weighted.mean(as.numeric(as.character(NBPI)), IPONDI, na.rm=T))) %&gt;% mutate(Np_pieces_moy=round(Np_pieces_moy, 1)) %&gt;% kable(format.args = list(big.mark = &quot; &quot;)) `summarise()` ungrouping output (override with `.groups` argument) Anciennete Np_pieces_moy Depuis moins de 2 ans 2.6 De 2 à 4 ans 2.8 De 5 à 9 ans 3.2 10 ans ou plus 3.7 Ensemble 3.3 #Nombre moyen de pièces par personne RP %&gt;% filter(CATL==&quot;1&quot;) %&gt;% mutate(nb_pieces=as.numeric(as.character(NBPI)), nb_pers=as.numeric(as.character(INPER)), np_pieces_pers=nb_pieces/nb_pers, Anciennete=case_when(ANEMR==&quot;00&quot; ~ &quot;Depuis moins de 2 ans&quot;, ANEMR==&quot;01&quot; ~ &quot;De 2 à 4 ans&quot;, ANEMR==&quot;02&quot; ~ &quot;De 5 à 9 ans&quot;, as.numeric(ANEMR)&gt;3 ~ &quot;10 ans ou plus&quot;), Anciennete = factor(Anciennete, levels=c(&quot;Depuis moins de 2 ans&quot;,&quot;De 2 à 4 ans&quot;,&quot;De 5 à 9 ans&quot;,&quot;10 ans ou plus&quot;))) %&gt;% group_by(Anciennete) %&gt;% summarise(Moy_pieces_pers=weighted.mean(np_pieces_pers, IPONDI, na.rm=T)) %&gt;% bind_rows(summarise(Anciennete = &quot;Ensemble&quot;, RP[RP$CATL==&quot;1&quot;, ], Moy_pieces_pers=weighted.mean(as.numeric(as.character(NBPI))/as.numeric(as.character(INPER)), IPONDI, na.rm=T))) %&gt;% mutate(Moy_pieces_pers=round(Moy_pieces_pers, 1)) %&gt;% kable(format.args = list(big.mark = &quot; &quot;)) `summarise()` ungrouping output (override with `.groups` argument) Anciennete Moy_pieces_pers Depuis moins de 2 ans 1.2 De 2 à 4 ans 1.2 De 5 à 9 ans 1.2 10 ans ou plus 1.6 Ensemble 1.4 C’est néanmoins plutôt du côté des graphiques que R excelle en la matière, avec le fameux package ggplot. On va maintenant essayer de travailler ce package avec ses différentes fonctions. Si besoin, pour vous aider à démarrer avec ggplot, 2 liens utiles : ici et là. Dans la continuité des statistiques réalisées précédemment, troisième exercice à faire : réalisez d’abord un graphique représentant l’ancienneté d’emménagement des ménages dans le Val de Marne en 2017, selon 6 catégories (“Depuis moins de 2 ans”, “De 2 à 4 ans”, “De 5 à 9 ans”, “De 10 à 19 ans”, “De 20 à 29 ans”, “30 ans ou plus”) et en pourcentage. On peut repartir du 1er code précédent en ajoutant des catégories, puis en utilisant un ggplot(). # 2 exemples : #Avec geom_col() qui crée un diagramme à barres ou graphique en colonnes RP %&gt;% filter(LPRM==&quot;1&quot; &amp; CATL==&quot;1&quot;) %&gt;% mutate(anc=case_when(ANEMR==&quot;00&quot; ~ &quot;Depuis moins de 2 ans&quot;, ANEMR==&quot;01&quot; ~ &quot;De 2 à 4 ans&quot;, ANEMR==&quot;02&quot; ~ &quot;De 5 à 9 ans&quot;, ANEMR==&quot;03&quot; ~ &quot;De 10 à 19 ans&quot;, ANEMR==&quot;04&quot; ~ &quot;De 20 à 29 ans&quot;, as.numeric(ANEMR)&gt;=5 ~ &quot;30 ans ou plus&quot;), anc = factor(anc, levels=c(&quot;Depuis moins de 2 ans&quot;, &quot;De 2 à 4 ans&quot;, &quot;De 5 à 9 ans&quot;, &quot;De 10 à 19 ans&quot;, &quot;De 20 à 29 ans&quot;, &quot;30 ans ou plus&quot;))) %&gt;% count(anc, wt=IPONDI) %&gt;% mutate(pct=prop.table(n)*100, pct=round(pct, 1)) %&gt;% ggplot() + aes(x=anc, y=pct, fill=anc) + geom_col() + scale_fill_brewer(palette = &quot;Set2&quot;) + geom_text(aes(y=pct, label=pct), vjust=1.5, color=&quot;gray30&quot;, size=4) + labs(title = &quot;Ancienneté d&#39;emménagement des ménages en 2017 dans le Val de Marne&quot;, x=&quot;&quot;, y=&quot;&quot;) + theme_bw() + theme(legend.position = &quot;none&quot;) #Ou avec geom_bar(), mais en mettant l&#39;option &quot; stat=&quot;identity&quot; &quot; car on donne déjà les valeurs avec y=pct RP %&gt;% filter(LPRM==&quot;1&quot; &amp; CATL==&quot;1&quot;) %&gt;% mutate(anc=case_when(ANEMR==&quot;00&quot; ~ &quot;Depuis moins de 2 ans&quot;, ANEMR==&quot;01&quot; ~ &quot;De 2 à 4 ans&quot;, ANEMR==&quot;02&quot; ~ &quot;De 5 à 9 ans&quot;, ANEMR==&quot;03&quot; ~ &quot;De 10 à 19 ans&quot;, ANEMR==&quot;04&quot; ~ &quot;De 20 à 29 ans&quot;, as.numeric(ANEMR)&gt;=5 ~ &quot;30 ans ou plus&quot;), anc = factor(anc, levels=c(&quot;Depuis moins de 2 ans&quot;, &quot;De 2 à 4 ans&quot;, &quot;De 5 à 9 ans&quot;, &quot;De 10 à 19 ans&quot;, &quot;De 20 à 29 ans&quot;, &quot;30 ans ou plus&quot;))) %&gt;% count(anc, wt=IPONDI) %&gt;% mutate(pct=prop.table(n)*100, pct=round(pct, 1)) %&gt;% ggplot() + aes(x=anc, y=pct, fill=anc) + geom_bar(stat=&quot;identity&quot;) + scale_fill_brewer(palette = &quot;Dark2&quot;) + geom_text(aes(y=pct, label=pct), vjust=1.5, color=&quot;gray22&quot;, size=4) + labs(title = &quot;Ancienneté d&#39;emménagement des ménages en 2017 dans le Val de Marne&quot;, x=&quot;&quot;, y=&quot;&quot;) + theme(legend.position = &quot;none&quot;) Réalisez ensuite un graphique de la distribution du nombre de pièces par type de logement en ne considérant que les maisons et appartements. Par exemple, cela pourrait donner cela : RP %&gt;% filter(LPRM==&quot;1&quot; &amp; TYPL %in% c(&quot;1&quot;, &quot;2&quot;)) %&gt;% mutate(nb_pieces=as.numeric(as.character(NBPI)), TYPL=recode(TYPL, &quot;1&quot;=&quot;Maison&quot;, &quot;2&quot;=&quot;Appartement&quot;)) %&gt;% ggplot() + aes(x=nb_pieces, y=TYPL, fill=TYPL) + geom_boxplot(outlier.shape = NA) + coord_flip() + stat_summary(fun=mean, geom=&quot;point&quot;, shape=20, size=4) + scale_x_continuous(limits = c(1, 8)) + labs(title=&quot;Nombre de pièces par ménage selon le type de logement en 2017&quot;, x=&quot;Nombre de pièces&quot;, y=&quot;Type de logement&quot;) + theme(legend.position = &quot;none&quot;) 2.3 Quelles caractéristiques des individus résidant dans le Val de Marne en 2017 ? On va s’intéresser maintenant aux caractéristiques des individus qui résident dans ce département du Val de Marne. On peut ainsi décrire la population selon les variables suivantes : l’âge, le sexe, la situation quant à l’immigration, le diplôme, la catégorie sociale, le type d’activité ou encore les conditions d’emploi. Premier exercice à faire : faire un graphique décrivant la population de 15 ans ou plus selon la catégorie socioprofessionnelle (CS). Puis un second, différenciant la population par sexe, en plus de la CS (vous pourrez enlever les agriculteurs peu nombreux). #Population de 15 ans ou plus selon la catégorie socioprofessionnelle (et sans les agriculteurs trop peu nombreux) RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT!=&quot;23&quot; &amp; CS1!=&quot;1&quot;) %&gt;% count(CS1, wt=IPONDI) %&gt;% mutate(pct=prop.table(n)*100, pct=round(pct, 1), CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;)) %&gt;% ggplot() + aes(x=CS1, y=pct, fill=CS1) + geom_col() + scale_fill_brewer(palette = &quot;Set2&quot;) + geom_text(aes(y=pct, label=pct), vjust=1.5, color=&quot;gray30&quot;, size=4) + labs(title = &quot;Population de 15 ans ou plus selon la catégorie socioprofessionnelle&quot;, x=&quot;&quot;, y=&quot;&quot;) + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 75, hjust=1)) #Population de 15 ans ou plus par sexe et catégorie socioprofessionnelle (et sans les agriculteurs trop peu nombreux) RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT!=&quot;23&quot; &amp; CS1!=&quot;1&quot;) %&gt;% group_by(SEXE) %&gt;% count(CS1, wt=IPONDI) %&gt;% mutate(pct=prop.table(n)*100, pct=round(pct, 1), CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;), SEXE=recode(SEXE, &quot;1&quot;=&quot;Homme&quot;, &quot;2&quot;=&quot;Femme&quot;)) %&gt;% ggplot() + aes(x=CS1, y=pct, fill=CS1) + geom_bar(stat=&quot;identity&quot;)+ facet_wrap(~SEXE,nrow=1, ncol=2) + scale_fill_brewer(palette = &quot;Set2&quot;) + geom_text(aes(y=pct, label=pct), vjust=1, color=&quot;gray23&quot;, size=3.5) + labs(title = &quot;Population de 15 ans ou plus par sexe et catégorie socioprofessionnelle&quot;, x=&quot;&quot;, y=&quot;&quot;) + theme_grey() + theme(axis.text.x=element_blank(), axis.ticks.x=element_blank(), legend.position=&quot;bottom&quot;, legend.title = element_blank(), plot.title = element_text(hjust = 0.5)) On peut dorénavant s’intéresser aux personnes en emploi, second exercice à faire : faîtes un graphique représentant la population de 15 ans ou plus en emploi par statut (salariés/non-salariés), sexe et catégorie socioprofessionnelle (en enlevant de nouveau les agriculteurs) RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT==&quot;11&quot; &amp; CS1!=&quot;1&quot;) %&gt;% mutate(EMPL=case_when(EMPL %in% c(&quot;11&quot;,&quot;12&quot;,&quot;13&quot;,&quot;14&quot;,&quot;15&quot;,&quot;16&quot;) ~ &quot;Salariés&quot;, EMPL %in% c(&quot;21&quot;,&quot;22&quot;,&quot;23&quot;) ~ &quot;Non Salariés&quot;), CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;), SEXE=recode(SEXE, &quot;1&quot;=&quot;Homme&quot;, &quot;2&quot;=&quot;Femme&quot;)) %&gt;% group_by(SEXE, EMPL) %&gt;% count(CS1, wt=IPONDI) %&gt;% mutate(pct=prop.table(n)*100, pct=round(pct, 1)) %&gt;% ggplot() + aes(x =SEXE, y=pct, fill = CS1) + geom_bar(stat=&quot;identity&quot;) + facet_wrap(~EMPL, nrow=1, ncol=2) + scale_fill_brewer(palette = &quot;Set2&quot;) + geom_text(aes(label = after_stat(y)), color=&quot;gray24&quot;, position = position_stack(.5)) + labs(title = &quot;Population de 15 ans ou plus en emploi par statut, sexe et catégorie socioprofessionnelle&quot;, x=&quot;&quot;, y=&quot;&quot;, fill=&quot;Catégorie socio-professionnelle&quot;) + theme_grey() + theme(legend.position=&quot;right&quot;) 2.4 La création de fonctions Et oui, le copier-coller c’est bien et simple, mais voilà pour ré-utiliser un code de façon plus automatique, créer des fonctions est très utile (et on peut même les stocker dans un fichier .r pour les réutiliser plus tard pour une autre étude). L’idée est qu’à partir d’un bloc d’instructions ou de lignes de code, on l’intègre dans une fonction qui portera un nom et qui pourra être appliquée sur les paramètres que l’on veut (table/objet différent, ici communes différentes, variables différentes) et qui nous retournera une valeur en sortie (qu’il faut préciser donc). Par exemple : #Les &quot;...&quot; seront des instructions bien sûr ! nom_fonction &lt;- function(data, var) { tab &lt;- data %&gt;% ... %&gt;% ... return(tab) } #L&#39;appel de la fonction devra ainsi préciser la table de données sur laquelle l&#39;appliquer et les autres arguments : nom_fonction(data = nom_de_ma_table , var = nom_de_ma_variable) #De plus, on pourra créer un nouvel objet (ici &quot;tab_var&quot;) pour stocker la table qui est en valeur de sortie de la fonction : tab_var &lt;- nom_fonction(data = nom_de_ma_table , var = nom_de_ma_variable) 2.4.1 Création d’une fonction pour retourner un tableau Alors, reprenons notre code précédent (ci-dessous), et essayons d’écrire une fonction pour faire des sorties de tableaux, de sorte qu’il suffise d’appeler cette fonction en indiquant le nom de notre table, de notre commune et de notre variable. On n’exécute pas de nouveau ce code, mais on l’affiche seulement sur notre script : pour cela il faut, dans le chunk, mettre l’option eval=FALSE comme ceci : {r eval=FALSE}. #Rappel exemple code précédent (avec ajout de la commune prise en référence - Sucy-en-Brie) : RP %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(LPRM==&quot;1&quot; &amp; COM == &quot;94071&quot;) %&gt;% mutate(Nb_voiture=case_when(VOIT==&quot;1&quot; ~ &quot;1 voiture&quot;, VOIT %in% c(&quot;2&quot;, &quot;3&quot;) ~ &quot;2 voitures ou plus&quot;, VOIT==&quot;0&quot; ~ &quot;Pas de voiture&quot;)) %&gt;% count(Nb_voiture, wt=IPONDI) %&gt;% mutate(n=round(n,0),pct=prop.table(n)*100, pct=round(pct, 1)) On crée donc une fonction qu’on appelle tab_menage avec comme paramètres “data”, “codecom” et “var” qui s’appliquerait dans le cas de statistiques au niveau “ménages” : tab_menage &lt;- function(data, codecom, var) { tab &lt;- data %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(LPRM==&quot;1&quot; &amp; COM == codecom) %&gt;% count({{ var }}, wt=IPONDI) %&gt;% mutate(n=round(n,0), pct=prop.table(n)*100, pct=round(pct, 1)) return(tab) } Le plus difficile ici est l’appel de la variable dans la fonction notamment lorsqu’on utilise le langage dplyr : une méthode (mais il en existe une autre, cf. ici) est d’utiliser les {{ }}. En outre, il ne faut pas oublier de préciser la valeur de sortie avec return(). En revanche, si l’on veut recoder la variable soit en regroupant des modalités, soit en renommant les modalités (ou les 2 !), il faudra le faire dans une étape préalable. De manière générale, il est bien comme on l’a vu dans les 2 premières séances de ce ciyrs (cf. script de cours associé) de prendre le temps de bien préparer la table, recoder toutes les variables comme on le souhaite, inspecter et traiter les valeurs manquantes, etc., avant l’étape de l’analyse statistique des données. Ainsi, si l’on reprend l’exemple des trois premiers tableaux que nous avons réalisés lors de la dernière séance (cf. plus haut), on peut le refaire en 2 étapes : préparation de la table, et appel des fonctions. (On peut aussi intégrer la fonction dans un code dplyr en ajoutant un %&gt;%, dans ce cas il faut enlever le paramètre “data =” dans la fonction lorsqu’on l’appelle, cf. après.) # Etape 1 : création d&#39;une nouvelle table (ou en remplacement si on l&#39;appelle de la même façon) RP &lt;- RP %&gt;% mutate(Stationnement = recode(GARL, &quot;1&quot; = &quot;Au moins un emplacement réservé au stationnement&quot;, &quot;2&quot; = &quot;Aucun emplacement&quot;), Voiture = case_when(VOIT %in% c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;) ~ &quot;Au moins une voiture&quot;, VOIT == &quot;0&quot; ~ &quot;Pas de voiture&quot;), Nb_voiture = case_when(VOIT == &quot;1&quot; ~ &quot;1 voiture&quot;, VOIT %in% c(&quot;2&quot;, &quot;3&quot;) ~ &quot;2 voitures ou plus&quot;, VOIT == &quot;0&quot; ~ &quot;Pas de voiture&quot;)) #Etape 2 : création des tableaux, soit en sortie dans la console (1er cas), soit en nouvel objet R (cas suivants) tab_menage(data = RP, codecom = &quot;94071&quot;, var = Stationnement) # A tibble: 2 x 3 Stationnement n pct &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Au moins un emplacement réservé au stationnement 7432 69.4 2 Aucun emplacement 3284 30.6 tab_voit &lt;- tab_menage(data = RP, codecom = &quot;94071&quot;, var = Voiture) tab_nbvoit &lt;- tab_menage(data = RP, codecom = &quot;94071&quot;, var = Nb_voiture) #Visualisation des 2 tables créées tab_voit # A tibble: 2 x 3 Voiture n pct &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Au moins une voiture 9011 84.1 2 Pas de voiture 1705 15.9 tab_nbvoit # A tibble: 3 x 3 Nb_voiture n pct &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 voiture 5399 50.4 2 2 voitures ou plus 3611 33.7 3 Pas de voiture 1705 15.9 On peut créer une même fonction pour réaliser des statistiques cette fois au niveau individus, il suffit de supprimer le 1er filtre avec la variable LPRM(). tab_indiv &lt;- function(data, codecom, var) { tab &lt;- data %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(COM == codecom) %&gt;% count({{ var }}, wt=IPONDI) %&gt;% mutate(n=round(n,0), pct=prop.table(n)*100, pct=round(pct, 1)) return(tab) } Exemple, avec la variable CS de catégorie socio-professionnelle #Pour être pertinent, table restreinte à la population de 15 ans ou plus (sans les agriculteurs non plus, trop peu nobmreux) : RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT!=&quot;23&quot; &amp; CS1!=&quot;1&quot;) %&gt;% mutate(CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;)) %&gt;% tab_indiv(codecom = &quot;94071&quot;, var = CS1) # A tibble: 7 x 3 CS1 n pct &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Artisans, commerçants et chefs d&#39;entreprise 713 3.3 2 Cadres et professions intellectuelles supérieures 3487 16.1 3 Professions Intermédiaires 3317 15.3 4 Employés 3244 14.9 5 Ouvriers 1691 7.8 6 Retraités 5610 25.8 7 Autres personnes sans activité professionnelle 3644 16.8 Et si on cherchait à n’avoir qu’une fonction à appliquer, que nos statistiques ensuite soient au niveau ménages ou au niveau individus ? tab_var &lt;- function(data, codecom, list_mod, var) { tab &lt;- data %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(LPRM %in% list_mod &amp; COM == codecom) %&gt;% count({{ var }}, wt=IPONDI) %&gt;% mutate(n=round(n,0), pct=prop.table(n)*100, pct=round(pct, 1)) return(tab) } Ce qui donnerait pour le niveau ménage l’appel de la fonction : tab_var(data = RP, codecom = &quot;94071&quot;, list_mod=c(&quot;1&quot;), var = Nb_voiture) # A tibble: 3 x 3 Nb_voiture n pct &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 voiture 5399 50.4 2 2 voitures ou plus 3611 33.7 3 Pas de voiture 1705 15.9 Et pour l’ensemble des individus : RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT!=&quot;23&quot; &amp; CS1!=&quot;1&quot;) %&gt;% mutate(CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;)) %&gt;% tab_var(codecom = &quot;94071&quot;, list_mod=c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;Z&quot;), var = CS1) # A tibble: 7 x 3 CS1 n pct &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Artisans, commerçants et chefs d&#39;entreprise 713 3.3 2 Cadres et professions intellectuelles supérieures 3487 16.1 3 Professions Intermédiaires 3317 15.3 4 Employés 3244 14.9 5 Ouvriers 1691 7.8 6 Retraités 5610 25.8 7 Autres personnes sans activité professionnelle 3644 16.8 C’est un peu fastidieux ici de rentrer toutes les modalités de la variable LPRM. Une solution rapide est de créer une nouvelle variable à partir de LPRM qu’on appelerait LPRM_1 qui n’ait que 2 modalités, ce qui peut être fait idéalement dans l’étape initiale de préparation des données (sinon comme ci-dessous) ! tab_var &lt;- function(data, codecom, list_mod, var) { tab &lt;- data %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(LPRM_1 %in% list_mod &amp; COM == codecom) %&gt;% count({{ var }}, wt=IPONDI) %&gt;% mutate(n=round(n,0), pct=prop.table(n)*100, pct=round(pct, 1)) return(tab) } # Appliquée sur le même exemple que précédemment : RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT!=&quot;23&quot; &amp; CS1!=&quot;1&quot;) %&gt;% mutate(CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;), LPRM_1 = case_when(LPRM == &quot;1&quot; ~ &quot;1&quot;, TRUE ~ &quot;0&quot;)) %&gt;% tab_var(codecom = &quot;94071&quot;, list_mod=c(&quot;1&quot;, &quot;0&quot;), var = CS1) # A tibble: 7 x 3 CS1 n pct &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Artisans, commerçants et chefs d&#39;entreprise 713 3.3 2 Cadres et professions intellectuelles supérieures 3487 16.1 3 Professions Intermédiaires 3317 15.3 4 Employés 3244 14.9 5 Ouvriers 1691 7.8 6 Retraités 5610 25.8 7 Autres personnes sans activité professionnelle 3644 16.8 2.4.2 Création d’une fonction pour retourner un graphique Maintenant, créons, de la même façon, une fonction qui retourne en valeur de sortie un graphique, comme ceux que l’on a construit plus haut. On peut dans un premier temps, partir du principe que l’on appelera d’abord notre fonction tab_var() pour créer le tableau en sortie, à partir duquel on appliquera la fonction du graphe. Pour rappel, voici le code initialement utilisé pour créer un graphique représentant la population de 15 ans ou plus selon la catégorie socioprofessionnelle dans notre commune de référence (de nouveau, on ne l’exécute pas ici, et on spécifie eval=FALSE). #Population de 15 ans ou plus selon la catégorie socioprofessionnelle (sans les agriculteurs ; et avec ajout de la commune prise en référence - Sucy-en-Brie) RP %&gt;% mutate(COM = substr(IRIS, 1, 5)) %&gt;% filter(COM == &quot;94071&quot; &amp; !AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT!=&quot;23&quot; &amp; CS1!=&quot;1&quot;) %&gt;% count(CS1, wt=IPONDI) %&gt;% mutate(pct=prop.table(n)*100, pct=round(pct, 1), CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;)) %&gt;% ggplot() + aes(x=CS1, y=pct, fill=CS1) + geom_col() + scale_fill_brewer(palette = &quot;Set2&quot;) + geom_text(aes(y=pct, label=pct), vjust=1.4, color=&quot;gray30&quot;, size=3.5) + labs(title = &quot;Population de 15 ans ou plus selon la catégorie socioprofessionnelle&quot;, x=&quot;&quot;, y=&quot;&quot;) + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 75, hjust=1)) On s’intéresse donc aux dernières lignes de codes pour créer notre fonction qu’on appelera par exemple graph_baton, en considérant qu’on aura avant un tableau avec 3 colonnes : la variable, le nombre “n” et le pourcentage “pct”. On peut donc réutiliser certains de ces noms de variables dans la fonction, ou se laisser la possibilité de l’indiquer dans les paramètres de la fonction (les lignes de codes suivantes ne sont pas exécutées, de nouveau l’option {r eval=FALSE} est ici inscrite dans le script Markdown). # On peut proposer une première écriture avec &quot;pct&quot; comme variable indiquée pour &quot;y=&quot; car ici c&#39;est le pourcentage qu&#39;on reprend, et dans nos tableaux il portera toujours le nom de &quot;pct&quot; : graph_baton &lt;- function(data, var_x, nom_titre) { graph &lt;- data %&gt;% ggplot() + aes(x = {{ var_x }}, y = pct, fill = {{ var_x }}) + geom_col() + scale_fill_brewer(palette = &quot;Set2&quot;) + geom_text(aes(y = pct, label = pct), vjust=1.4, color=&quot;gray30&quot;, size=3.5) + labs(title = nom_titre, x=&quot;&quot;, y=&quot;&quot;) + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 75, hjust=1)) return(graph) } # Mais si on veut se laisser la possibilité de ne pas forcément mettre le pourcentage mais aussi les effectifs... alors il vaut mieux indiquer un nouveau paramètre que l&#39;on aura à &quot;remplir&quot; en appelant la fonction : graph_baton &lt;- function(data, var_x, var_y, nom_titre) { graph &lt;- data %&gt;% ggplot() + aes(x = {{ var_x }}, y = {{ var_y }}, fill = {{ var_x }}) + geom_col() + scale_fill_brewer(palette = &quot;Set2&quot;) + geom_text(aes(y = {{ var_y }}, label = {{ var_y }}), vjust=1.4, color=&quot;gray30&quot;, size=3.5) + labs(title = nom_titre, x=&quot;&quot;, y=&quot;&quot;) + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 75, hjust=1)) return(graph) } #On avait vu qu&#39;on pouvait également utiliser la fonction `geom_bar()` en mettant l&#39;option &quot;(stat=&quot;identity&quot;)&quot; à la place de `geom_col()`, c&#39;est ce que nous allons privilégier ensuite : graph_baton &lt;- function(data, var_x, var_y, nom_titre) { graph &lt;- data %&gt;% ggplot() + aes(x = {{ var_x }}, y = {{ var_y }}, fill = {{ var_x }}) + geom_bar(stat=&quot;identity&quot;) + scale_fill_brewer(palette = &quot;Set2&quot;) + geom_text(aes(y = {{ var_y }}, label = {{ var_y }}), vjust=1.4, color=&quot;gray30&quot;, size=3.5) + labs(title = nom_titre, x=&quot;&quot;, y=&quot;&quot;) + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 75, hjust=1)) return(graph) } Essayons de l’appliquer en lien avec le code initial : graph_baton &lt;- function(data, var_x, var_y, nom_titre) { graph &lt;- data %&gt;% ggplot() + aes(x = {{ var_x }}, y = {{ var_y }}, fill = {{ var_x }}) + geom_bar(stat=&quot;identity&quot;) + scale_fill_brewer(palette = &quot;Set2&quot;) + geom_text(aes(y = {{ var_y }}, label = {{ var_y }}), vjust=1.4, color=&quot;gray30&quot;, size=3.5) + labs(title = nom_titre, x=&quot;&quot;, y=&quot;&quot;) + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 75, hjust=1)) return(graph) } #Restreignons là aussi l&#39;analyse aux 15 ans ou plus (sans les agriculteurs de nouveau) tab_CS &lt;- RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT!=&quot;23&quot; &amp; CS1!=&quot;1&quot;) %&gt;% mutate(CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;), LPRM_1 = case_when(LPRM == &quot;1&quot; ~ &quot;1&quot;, TRUE ~ &quot;0&quot;)) %&gt;% tab_var(codecom = &quot;94071&quot;, list_mod=c(&quot;1&quot;, &quot;0&quot;), var = CS1) graph_baton(data = tab_CS, var_x = CS1, var_y = pct, nom_titre =&quot;Population de 15 ans ou plus selon la catégorie socioprofessionnelle&quot;) Si certaines options du graphique ne s’adapteront pas bien pour d’autres variables, il est possible dans la fonction créée d’enlever les lignes de codes comprenant les fonctions geom_text() et theme(), et de les ajouter ensuite au graphe que l’on aura stocké préalablement dans un objet. De même, ici on a voulu “économiser” le nombre de paramètres cités pour le graphe en reprenant le même nom de variables que pour le tableau, mais il sera finalement peut-être plus judicieux de bien distinguer les variables appelées dans le tableau et les variables appelées dans le graphe. On le verra plus loin. 2.4.3 Création d’une seule fonction comprenant tableau et graphe Vous l’avez compris, on peut constamment optimiser son code, y compris ses fonctions. Par exemple ici, au lieu d’appeler la fonction tableau, puis ensuite la fonction graphe, on peut créer une fonction qui renverra le graphique voulu en intégrant l’étape du tableau. On va l’appeler graph_baton1 : #Fonction Graph intégrant la fonction tab graph_baton1 &lt;- function(data, codecom, list_mod, var, var_x, var_y, nom_titre) { tabvar &lt;- tab_var(data = data, codecom = codecom, list_mod, var = {{ var }}) graph &lt;- tabvar %&gt;% ggplot() + aes(x = {{ var_x }}, y = {{ var_y }}, fill = {{ var_x }}) + geom_bar(stat=&quot;identity&quot;) + scale_fill_brewer(palette = &quot;Set2&quot;) + geom_text(aes(y = {{ var_y }}, label = {{ var_y }}), vjust=1.4, color=&quot;gray30&quot;, size=3.5) + labs(title = nom_titre, x=&quot;&quot;, y=&quot;&quot;) + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 75, hjust=1)) return(graph) } RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT!=&quot;23&quot; &amp; CS1!=&quot;1&quot;) %&gt;% mutate(CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;), LPRM_1 = case_when(LPRM == &quot;1&quot; ~ &quot;1&quot;, TRUE ~ &quot;0&quot;)) %&gt;% graph_baton1(codecom = &quot;94071&quot;, list_mod = c(&quot;1&quot;, &quot;0&quot;), var = CS1,var_x=CS1, var_y = pct, nom_titre = &quot;Population de 15 ans ou plus selon la catégorie socioprofessionnelle&quot;) En revanche, vous voyez ici qu’il nous renvoie le seul graphique. Et si on veut aussi le tableau ? Le problème est qu’a priori une fonction ne sait pas renvoyer plusieurs valeurs de sortie. Par conséquent, on est obligés de contourner le problème en utilisant une petite astuce : on crée une liste d’objets. graph_baton2 &lt;- function(data, codecom, list_mod, var, var_x, var_y, nom_titre) { tabvar &lt;- tab_var(data = data, codecom = codecom, list_mod, var = {{ var }}) graph &lt;- tabvar %&gt;% ggplot() + aes(x = {{ var_x }}, y = {{ var_y }}, fill = {{ var_x }}) + geom_bar(stat=&quot;identity&quot;) + scale_fill_brewer(palette = &quot;Set2&quot;) + geom_text(aes(y = {{ var_y }}, label = {{ var_y }}), vjust=1.4, color=&quot;gray30&quot;, size=3.5) + labs(title = nom_titre, x=&quot;&quot;, y=&quot;&quot;) + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 75, hjust=1)) return(list(tabvar, graph)) } RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT!=&quot;23&quot; &amp; CS1!=&quot;1&quot;) %&gt;% mutate(CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;), LPRM_1 = case_when(LPRM == &quot;1&quot; ~ &quot;1&quot;, TRUE ~ &quot;0&quot;)) %&gt;% graph_baton2(codecom = &quot;94071&quot;, list_mod = c(&quot;1&quot;, &quot;0&quot;), var = CS1, var_x=CS1, var_y = pct, nom_titre = &quot;Population de 15 ans ou plus selon la catégorie socioprofessionnelle&quot;) [[1]] CS1 n pct 1 Artisans, commerçants et chefs d&#39;entreprise 713 3.3 2 Cadres et professions intellectuelles supérieures 3487 16.1 3 Professions Intermédiaires 3317 15.3 4 Employés 3244 14.9 5 Ouvriers 1691 7.8 6 Retraités 5610 25.8 7 Autres personnes sans activité professionnelle 3644 16.8 [[2]] 2.4.4 Et pour distinguer par groupe ? Et pour avoir des moyennes… ? Et si on veut représenter la population par catégorie socio-professionnelle en distinguant par sexe, comme précédemment ? Il faut rajouter la fonction group_by(), mais en faisant en sorte qu’on ne sache pas d’une part quelle variable on va mettre, ni combien de variables on va mettre, et d’autre part on pourrait se laisser le choix de ne pas en mettre du tout. On peut repartir de notre fonction tab_var, pour rappel ci-dessous (non-exécutée) : tab_var &lt;- function(data, codecom, list_mod, var) { tab &lt;- data %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(LPRM_1 %in% list_mod &amp; COM == codecom) %&gt;% count({{ var }}, wt=IPONDI) %&gt;% mutate(n=round(n,0), pct=prop.table(n)*100, pct=round(pct, 1)) return(tab) } Procédons par étapes : on lui ajoute la fonction group_by() qui nous permettrait de distinguer selon une seule autre variable : tab_var1 &lt;- function(data, codecom, list_mod, var, var2) { tab &lt;- data %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(LPRM_1 %in% list_mod &amp; COM == codecom) %&gt;% group_by({{ var2 }}) %&gt;% count({{ var }}, wt=IPONDI) %&gt;% mutate(n=round(n,0), pct=prop.table(n)*100, pct=round(pct, 1)) return(tab) } RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT!=&quot;23&quot; &amp; CS1!=&quot;1&quot;) %&gt;% mutate(SEXE=recode(SEXE, &quot;1&quot;=&quot;Homme&quot;, &quot;2&quot;=&quot;Femme&quot;), CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;), LPRM_1 = case_when(LPRM == &quot;1&quot; ~ &quot;1&quot;, TRUE ~ &quot;0&quot;)) %&gt;% tab_var1(codecom=&quot;94071&quot;, list_mod=c(&quot;1&quot;, &quot;0&quot;), var=CS1, var2=SEXE) # A tibble: 14 x 4 SEXE CS1 n pct &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Homme Artisans, commerçants et chefs d&#39;entreprise 516 5 2 Homme Cadres et professions intellectuelles supérieures 2018 19.7 3 Homme Professions Intermédiaires 1409 13.8 4 Homme Employés 857 8.4 5 Homme Ouvriers 1407 13.8 6 Homme Retraités 2466 24.1 7 Homme Autres personnes sans activité professionnelle 1555 15.2 8 Femme Artisans, commerçants et chefs d&#39;entreprise 197 1.7 9 Femme Cadres et professions intellectuelles supérieures 1469 12.8 10 Femme Professions Intermédiaires 1908 16.6 11 Femme Employés 2387 20.8 12 Femme Ouvriers 284 2.5 13 Femme Retraités 3143 27.4 14 Femme Autres personnes sans activité professionnelle 2089 18.2 Mais on voudrait pouvoir éventuellement distinguer selon plusieurs variables, par IRIS et sexe par exemple, ou tout autre chose ; et puis on voudrait aussi pendant qu’on y est n’avoir qu’une seule fonction tab_var pour avoir un tableau selon une seule variable ou selon plusieurs autres variables. Pour laisser à la fonction la possibilité d’appeler plusieurs paramètres (ou aucun !), il faut utiliser les “…”, que l’on va ici mettre dans la fonction group_by(...). tab_var &lt;- function(data, codecom, list_mod, var, ...) { tab &lt;- data %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(LPRM_1 %in% list_mod &amp; COM == codecom) %&gt;% group_by(...) %&gt;% count({{ var }}, wt=IPONDI) %&gt;% mutate(n=round(n,0), pct=prop.table(n)*100, pct=round(pct, 1)) return(tab) } #Ici, je crée un nouvel objet, pour pouvoir lancer les 2 fonctions de test à la suite RP_stats &lt;- RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT!=&quot;23&quot; &amp; CS1!=&quot;1&quot;) %&gt;% mutate(SEXE=recode(SEXE, &quot;1&quot;=&quot;Homme&quot;, &quot;2&quot;=&quot;Femme&quot;), CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;), LPRM_1 = case_when(LPRM == &quot;1&quot; ~ &quot;1&quot;, TRUE ~ &quot;0&quot;)) tab_var(data=RP_stats, codecom=&quot;94071&quot;, list_mod=c(&quot;1&quot;, &quot;0&quot;), var=CS1) # A tibble: 7 x 3 CS1 n pct &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Artisans, commerçants et chefs d&#39;entreprise 713 3.3 2 Cadres et professions intellectuelles supérieures 3487 16.1 3 Professions Intermédiaires 3317 15.3 4 Employés 3244 14.9 5 Ouvriers 1691 7.8 6 Retraités 5610 25.8 7 Autres personnes sans activité professionnelle 3644 16.8 tab_var(data=RP_stats, codecom=&quot;94071&quot;, list_mod=c(&quot;1&quot;, &quot;0&quot;), var=CS1, SEXE) # A tibble: 14 x 4 SEXE CS1 n pct &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Homme Artisans, commerçants et chefs d&#39;entreprise 516 5 2 Homme Cadres et professions intellectuelles supérieures 2018 19.7 3 Homme Professions Intermédiaires 1409 13.8 4 Homme Employés 857 8.4 5 Homme Ouvriers 1407 13.8 6 Homme Retraités 2466 24.1 7 Homme Autres personnes sans activité professionnelle 1555 15.2 8 Femme Artisans, commerçants et chefs d&#39;entreprise 197 1.7 9 Femme Cadres et professions intellectuelles supérieures 1469 12.8 10 Femme Professions Intermédiaires 1908 16.6 11 Femme Employés 2387 20.8 12 Femme Ouvriers 284 2.5 13 Femme Retraités 3143 27.4 14 Femme Autres personnes sans activité professionnelle 2089 18.2 Et on peut réécrire ainsi notre fonction graph_baton1() pour intégrer cette nouvelle version de notre fonction tabvar() ! graph_baton1 &lt;- function(data, codecom, list_mod, var, ..., var_x, var_y, nom_titre) { tabvar &lt;- tab_var(data = data, codecom = codecom, list_mod, var = {{ var }}, ...) graph &lt;- tabvar %&gt;% ggplot() + aes(x = {{ var_x }}, y = {{ var_y }}, fill = {{ var_x }}) + geom_bar(stat=&quot;identity&quot;) + scale_fill_brewer(palette = &quot;Set2&quot;) + geom_text(aes(y = {{ var_y }}, label = {{ var_y }}), vjust=1.4, color=&quot;gray30&quot;, size=3.5) + labs(title = nom_titre, x=&quot;&quot;, y=&quot;&quot;) + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 75, hjust=1)) return(graph) } Ainsi, pour avoir un graphique similaire à celui de fin de section précédente (qui s’intitulait “Population de 15 ans ou plus par sexe et catégorie socioprofessionnelle”), on y arrive avec ce code, c’est-à-dire en sauvegardant le résultat de notre fonction dans un objet graphe (intitulé ici “gg”) puis en lui ajoutant ensuite la fonction facet_wrap() et la variable qu’on a utilisée dans le group_by() à l’intérieur de la fonction (ici donc le sexe), et en lui spécifiant éventuellement quelques ajouts supplémentaires concernant l’arrière-plan du graphique avec theme() : gg &lt;- RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT!=&quot;23&quot; &amp; CS1!=&quot;1&quot;) %&gt;% mutate(CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;), SEXE=recode(SEXE, &quot;1&quot;=&quot;Homme&quot;, &quot;2&quot;=&quot;Femme&quot;), LPRM_1 = case_when(LPRM == &quot;1&quot; ~ &quot;1&quot;, TRUE ~ &quot;0&quot;)) %&gt;% graph_baton1(codecom= &quot;94071&quot;, list_mod= c(&quot;1&quot;, &quot;0&quot;), var=CS1, SEXE, var_x=CS1, var_y= pct, nom_titre= &quot;Population de 15 ans ou plus par sexe et catégorie socioprofessionnelle&quot;) gg + facet_wrap(~SEXE,nrow=1, ncol=2) + theme_grey() + theme(axis.text.x=element_blank(), axis.ticks.x=element_blank(), legend.position=&quot;bottom&quot;, legend.title = element_blank(), plot.title = element_text(hjust = 0.5)) En réalité, pour une utilisation plus générale, il est sans doute préférable de ne pas indiquer dans la fonction les éléments relatifs ni au theme(), ni à geom_text(), et enfin de distinguer les variables utilisées pour le tableau, et les variables utilisées dans le graphique car dès qu’on sera sur des graphiques plus complexes avec plusieurs variables dans le group_by(), les choses risquent de ne pas fonctionner avec une fonction ne distinguant pas bien l’ensemble des variables. On peut donc finalement, ou en plus, proposer cette fonction, en ajoutant un paramètre “var_z” pour bien distinguer les différentes variables : graph_baton3 &lt;- function(data, codecom, list_mod, var, ..., var_x, var_y, var_z, nom_titre) { tabvar &lt;- tab_var(data = data, codecom = codecom, list_mod, var = {{ var }}, ...) graph &lt;- tabvar %&gt;% ggplot() + aes(x = {{ var_x }}, y = {{ var_y }}, fill = {{ var_z }}) + geom_bar(stat=&quot;identity&quot;) + scale_fill_brewer(palette = &quot;Set2&quot;) + labs(title = nom_titre, x=&quot;&quot;, y=&quot;&quot;) return(graph) } Elle est par exemple utile pour réaliser le graphique en fin de section précédente qui était intitulé : “Population de 15 ans ou plus en emploi par statut, sexe et catégorie socioprofessionnelle”: gg &lt;-RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT==&quot;11&quot; &amp; CS1!=&quot;1&quot;) %&gt;% mutate(EMPL=case_when(EMPL %in% c(&quot;11&quot;,&quot;12&quot;,&quot;13&quot;,&quot;14&quot;,&quot;15&quot;,&quot;16&quot;) ~ &quot;Salariés&quot;, EMPL %in% c(&quot;21&quot;,&quot;22&quot;,&quot;23&quot;) ~ &quot;Non Salariés&quot;), CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;), SEXE=recode(SEXE, &quot;1&quot;=&quot;Homme&quot;, &quot;2&quot;=&quot;Femme&quot;), LPRM_1 = case_when(LPRM == &quot;1&quot; ~ &quot;1&quot;, TRUE ~ &quot;0&quot;)) %&gt;% graph_baton3(codecom= &quot;94071&quot;, list_mod= c(&quot;1&quot;, &quot;0&quot;), var = CS1, SEXE, EMPL, var_x = SEXE, var_y = pct, var_z = CS1, nom_titre= &quot;Population de 15 ans ou plus en emploi par statut, sexe et catégorie socioprofessionnelle&quot;) gg + facet_wrap(~EMPL, nrow=1, ncol=2) + geom_text(aes(label = after_stat(y)), color=&quot;gray24&quot;, position = position_stack(.5), size=3.5) + labs(fill=&quot;Catégorie socio-professionnelle&quot;) + theme(legend.position=&quot;right&quot;) Enfin, on peut vouloir créer une fonction pour réaliser des statistiques sur des variables quantitatives, comme on le fait avec la fonction summarise(). On avait par exemple calculé, plus haut, le nombre moyen de pièces par logement selon l’ancienneté d’emménagement du ménage. On peut prendre exemple sur le code de notre fonction tabvar() et intégrer la fonction summarise() au lieu de count() ; et ajouter un paramètre pour expliciter le nom que l’on souhaite donner à la variable de sortie (la moyenne ici), avec les {{ }} comme pour la variable (paramètre “nom_var” ici donc). mean_var &lt;- function(data, codecom,list_mod, var, ..., nom_var) { var_mean &lt;- data %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(LPRM_1 %in% list_mod &amp; COM == codecom) %&gt;% group_by(...) %&gt;% summarise({{ nom_var }} = weighted.mean({{ var }}, IPONDI, na.rm=T)) return(var_mean) } Mais si vous exécutez ce code, cela devrait vous mettre un message d’erreur en rouge : “Erreur : ‘=’ inattendu(e) in: \"group_by(…) %&gt;% summarise({{ nom }} =\"”. Et oui, ça ne fonctionne pas car la fonction summarise() ne comprend pas le paramètre “nom_var”, il faut en fait mettre avant weighted.mean() un := et non un simple = ! mean_var &lt;- function(data, codecom,list_mod, var, ..., nom_var) { var_mean &lt;- data %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(LPRM_1 %in% list_mod &amp; COM == codecom) %&gt;% group_by(...) %&gt;% summarise({{ nom_var }} := weighted.mean({{ var }}, IPONDI, na.rm=T)) return(var_mean) } On la teste : # Nombre moyen de pièces par logement, pour notre commune de référence Sucy-en-Brie RP %&gt;% mutate(Np_pieces=as.numeric(as.character(NBPI), na.rm=TRUE), LPRM_1 = case_when(LPRM == &quot;1&quot; ~ &quot;1&quot;, TRUE ~ &quot;0&quot;)) %&gt;% mean_var(codecom =&quot;94071&quot;, list_mod=c(&quot;1&quot;), var=Np_pieces, nom_var=Nbmoy_pieces) # A tibble: 1 x 1 Nbmoy_pieces &lt;dbl&gt; 1 4.09 # Nombre moyen de pièces par logement selon l&#39;ancienneté d&#39;emménagement du ménage, toujours pour notre commune de référence Sucy-en-Brie RP %&gt;% mutate(Anciennete=case_when(ANEMR==&quot;00&quot; ~ &quot;Depuis moins de 2 ans&quot;, ANEMR==&quot;01&quot; ~ &quot;De 2 à 4 ans&quot;, ANEMR==&quot;02&quot; ~ &quot;De 5 à 9 ans&quot;, as.numeric(ANEMR)&gt;3 ~ &quot;10 ans ou plus&quot;), Anciennete = factor(Anciennete, levels=c(&quot;Depuis moins de 2 ans&quot;,&quot;De 2 à 4 ans&quot;,&quot;De 5 à 9 ans&quot;, &quot;10 ans ou plus&quot;)), Np_pieces=as.numeric(as.character(NBPI), na.rm=TRUE), LPRM_1 = case_when(LPRM == &quot;1&quot; ~ &quot;1&quot;, TRUE ~ &quot;0&quot;)) %&gt;% mean_var(codecom =&quot;94071&quot;, list_mod=c(&quot;1&quot;), var=Np_pieces, Anciennete, nom_var=Nbmoy_pieces_anc) `summarise()` ungrouping output (override with `.groups` argument) # A tibble: 4 x 2 Anciennete Nbmoy_pieces_anc &lt;fct&gt; &lt;dbl&gt; 1 Depuis moins de 2 ans 3.27 2 De 2 à 4 ans 3.40 3 De 5 à 9 ans 3.92 4 10 ans ou plus 4.45 On peut également faire une fonction pour avoir une somme et non une moyenne, cela nous servira pour notre analyse de clustering (prochaine séance). sum_var &lt;- function(data, codecom,list_mod, ..., nom_var) { var_sum &lt;- data %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(LPRM_1 %in% list_mod &amp; COM == codecom) %&gt;% group_by(...) %&gt;% summarise({{ nom_var }} := sum(IPONDI)) return(var_sum) } RP %&gt;% mutate(LPRM_1 = case_when(LPRM == &quot;1&quot; ~ &quot;1&quot;, TRUE ~ &quot;0&quot;)) %&gt;% sum_var(codecom = &quot;94071&quot;,list_mod = c(&quot;0&quot;,&quot;1&quot;), IRIS, nom_var = nbhab) `summarise()` ungrouping output (override with `.groups` argument) # A tibble: 11 x 2 IRIS nbhab &lt;fct&gt; &lt;dbl&gt; 1 940710101 2151. 2 940710102 2204. 3 940710103 2843. 4 940710104 2631. 5 940710105 3006. 6 940710106 2368. 7 940710107 2545. 8 940710108 2853. 9 940710109 2528. 10 940710110 1525. 11 940710111 1825. 2.4.5 Enregistrer/Stocker ses fonctions Pour cela, il faut copier le seul code de la fonction ou des fonctions écrites et le(s) mettre dans un script (il faut bien les mettre l’une après l’autre si vous souhaitez en sauvegarder plusieurs dans un même fichier), puis enregistrer ce script. Vous pouvez pour cela créer un nouveau dossier dans votre projet et le nommer “Fonctions”. Ensuite, pour l’appeler il faudra faire appel à la fonction source(). Vous pouvez le mettre en 1ère commande dans un nouveau script. #si j&#39;ai enregistré mes 5 fonctions intitulé dans ce script `tab_var`, `graph_baton1`, `graph_baton3`, `mean_var` et `sum_var` dans un fichier/script &quot;mes_fonctions&quot; dans le dossier &quot;Fonctions&quot; de mon projet, alors je l&#39;appelerai ainsi au début d&#39;un nouveau script si je veux les réutiliser : source(&quot;fonctions/mes_fonctions.R&quot;) "],["21-cartography.html", "Chapitre 3 Analyse cartographique I (C.G.) 3.1 Introduction 3.2 Le package cartography 3.3 Création de fonctions", " Chapitre 3 Analyse cartographique I (C.G.) 3.1 Introduction L’objectif de cette section est d’apprendre à réaliser des cartographies statiques d’indicateurs relatifs aux unités spatiales à différentes échelles à l’aide du package cartography. de créer des fonctions permetant d’automatiser la tâche de cartographie à l’échelle des communes 3.1.1 Packages utilisés Nous allons nous limiter à un nombre limité de packages dplyr et tidyr: pour la manipulation des tableaux et leur agrégation (inutile de charger l’ensemble du package tidyverse) knitr : pour afficher proprement les tableaux de résultats ggplot2 : pour visualiser les résultats sous formes de graphiques sf : pour manipuler les données cartographiques et les agréger cartography : pour la réalisation de cartes statiques de qualité imprimables aux formats .pdf ou .doc library(knitr) library(tidyr) library(dplyr) library(ggplot2) library(sf) library(cartography) 3.1.2 Chargement des données Nous avons besoin uniquement de trois fichiers Le fichier des individus le fichier des métadonnées relatives aux individus le fonds de carte des IRIS indiv &lt;- readRDS(&quot;data/indiv2017.Rdata&quot;) meta &lt;- readRDS(&quot;data/indiv2017_meta.Rdata&quot;) map &lt;-readRDS(&quot;data/map_iris.Rdata&quot;) 3.2 Le package cartography Le package cartography permet de réaliser des cartes statiques de très haute qualité. Il a en effet été mis au point par des cartographes et des géomaticiens professionnels. Il propose une gamme de possibilités sans équivalent. On ne verra ici qu’une toute petite partie de ses possibilités. Nous allons prendre comme exemple l’analyse d’un tableau du nombre d’automobiles par ménage en nous limitant aux ménages ordinaires c’est-à-dire en excluant les personnes habitant dans des logements collectifs (pensionnats, prisons, congrégations religieuses, …) Nous ne conservons que les individus chefs de ménages (LPRM=1) ce qui va logiquement éliminer les individus présents dans les ménages non ordinaires (LPRM=Z) ainsi que tous les membres d’un logement qui ne sont pas chefs de ménages. menag&lt;-indiv %&gt;% filter(LPRM==1) 3.2.1 Création du tableau de contingence Nous souhaitons ventiler les ménages en fonction de leur localisation géographique (IRIS) et de leur nombre d’automobile (VOIT) en tenant compte de leur poids (IPONDI) puisque les données sont issues d’uin échantillonage qu’il faut redresser. Cette opération se réalise très facilement à l’aide du package dplyr à l’aide des fonctions group_by, mutate et summarize : tab &lt;- menag %&gt;% group_by(IRIS, VOIT) %&gt;% summarise(nbmen = sum(IPONDI)) %&gt;% ungroup() `summarise()` regrouping output by &#39;IRIS&#39; (override with `.groups` argument) str(tab) tibble [2,070 × 3] (S3: tbl_df/tbl/data.frame) $ IRIS : Factor w/ 4243 levels &quot;751010101&quot;,&quot;751010102&quot;,..: 3300 3300 3300 3300 3301 3301 3301 3301 3302 3302 ... $ VOIT : Factor w/ 5 levels &quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,..: 1 2 3 4 1 2 3 4 1 2 ... $ nbmen: num [1:2070] 674.1 679.5 142.2 29.5 801.4 ... head(tab,5) # A tibble: 5 x 3 IRIS VOIT nbmen &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; 1 940020101 0 674. 2 940020101 1 679. 3 940020101 2 142. 4 940020101 3 29.5 5 940020102 0 801. Le résultat est un tibble au format “long” qui comporte 4 lignes différentes pour chaque IRIS, correspondant aux nombres de ménages ayant respectivement 0, 1, 2 et 3 voitures ou plus. Nous allons transformer ce tableau en format “large” pour placer côte à côte les différentes modalités du nombre de voitures. Pour cela il faut utiliser la fonction pivot_widerdu package tidyr. library(tidyr) tabcont &lt;- tab %&gt;% pivot_wider(names_from = VOIT, values_from = nbmen, names_prefix = &quot;MEN_VOIT&quot;, values_fill = 0) head(tabcont) # A tibble: 6 x 5 IRIS MEN_VOIT0 MEN_VOIT1 MEN_VOIT2 MEN_VOIT3 &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 940020101 674. 679. 142. 29.5 2 940020102 801. 903. 170. 24.8 3 940020103 661. 703. 76.0 10.6 4 940020104 694. 701. 126. 23.0 5 940020105 434. 960. 237. 29.3 6 940020106 625. 735. 166. 29.2 Grâce à cette transformation, nous disposons maintenant pour chaque IRIS de la distribution des ménages en fonction de leur nombre de voitures, ce qui constitue le tableau de contingence recherché. 3.2.2 Ajout d’un tableau de pourcentage Nous allons maintenant calculer le nombre total de ménage puis en déduire la proportion de ménages en fonction de leur nombre d’automobile pour chacun des IRIS. tabdon &lt;- tabcont %&gt;% mutate (MEN_TOTAL = MEN_VOIT0+MEN_VOIT1+MEN_VOIT2+MEN_VOIT3, PCT_VOIT0 = 100* MEN_VOIT0 / MEN_TOTAL, PCT_VOIT1 = 100* MEN_VOIT1 / MEN_TOTAL, PCT_VOIT2 = 100* MEN_VOIT2 / MEN_TOTAL, PCT_VOIT3 = 100* MEN_VOIT3 / MEN_TOTAL) head(tabdon[,c(1,6:10)]) # A tibble: 6 x 6 IRIS MEN_TOTAL PCT_VOIT0 PCT_VOIT1 PCT_VOIT2 PCT_VOIT3 &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 940020101 1525. 44.2 44.5 9.32 1.93 2 940020102 1899. 42.2 47.6 8.93 1.31 3 940020103 1450. 45.6 48.5 5.24 0.729 4 940020104 1544. 45.0 45.4 8.14 1.49 5 940020105 1660. 26.1 57.8 14.3 1.76 6 940020106 1555. 40.2 47.3 10.7 1.87 3.2.3 Estimation du nombre moyen d’automobile par menages Il n’est pas possible d’estimer le nombre exact d’automobile par ménage car l’INSEE ne détaille pas la catégorie VOIT = 3 qui correspond à “Trois automobiles ou +”. On peut néanmoins procéder à une estimation minimale du nombre d’automobile en supposant que les ménages de ce type ont exactement rois automobiles. On en déduit alors le nombre total d’automobile par IRIS (VOIT_TOTAL) et le nombre moyen d’automobile par ménage (VOIT_MEN). tabdon &lt;-tabdon %&gt;% mutate(VOIT_TOTAL = MEN_VOIT1 + 2*MEN_VOIT2 + 3*MEN_VOIT3, VOIT_MEN = VOIT_TOTAL / MEN_TOTAL) head(tabdon[,c(1,6,11,12)]) # A tibble: 6 x 4 IRIS MEN_TOTAL VOIT_TOTAL VOIT_MEN &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 940020101 1525. 1052. 0.690 2 940020102 1899. 1317. 0.694 3 940020103 1450. 886. 0.611 4 940020104 1544. 1021. 0.662 5 940020105 1660. 1522. 0.917 6 940020106 1555. 1154. 0.742 3.2.4 Analyse statistique Avant de passer à la cartographie, on peut analyser quelques variables intéressantes. 3.2.4.1 Part des ménages sans automobiles Les ménages sans automobiles sont une catégorie intéressante, même si elle peut recouper des situations très diverses (étudiants, personnes âgées, pauvres, …). summary(tabdon$PCT_VOIT0) Min. 1st Qu. Median Mean 3rd Qu. Max. 0.00 21.94 30.95 31.13 40.84 65.31 ggplot(tabdon, aes(x=PCT_VOIT0)) + geom_histogram(bins=20, fill=&quot;gray30&quot;) + scale_y_continuous(&quot;Nombre d&#39;IRIS&quot;)+ scale_x_continuous(&quot;% de ménages&quot;)+ ggtitle(&quot;Par des ménages sans automobiles en 2017&quot;) La distribution apparaît très variable puisque les ménages sans automobiles sont absents de certains IRIS alors qu’ils représentent plus de la moitié des ménages dans d’autres IRIS. 3.2.4.2 Nombre moyen d’automobiles par ménage Même s’il est légèrement sous-estimé, le nombre d’automobile par ménage est un bon indicateur de la dépendance de certains logements mals desservis par les transports en commun. summary(tabdon$VOIT_MEN) Min. 1st Qu. Median Mean 3rd Qu. Max. 0.3944 0.7190 0.8675 0.9003 1.0458 2.0000 ggplot(tabdon, aes(x=VOIT_MEN)) + geom_histogram(bins=20, fill=&quot;gray30&quot;) + scale_y_continuous(&quot;Nombre d&#39;IRIS&quot;)+ scale_x_continuous(&quot;voitures / ménage&quot;)+ ggtitle(&quot;Nombre moyen d&#39;automobile par ménage en 2017&quot;) Alors qu’on trouve en général entre 0.6 et 1.2 automobiles par ménage, certains IRIS affichent des valeurs moyennes de 1.5 à 2 automobiles par ménage. 3.2.5 Sauvegarde du tableau et jointure avec le fonds de carte On commence par effectuer une sauvegarde simple de notre tableau : saveRDS(tabdon,&quot;data/VOIT_IRIS.Rdata&quot;) Puis on effectue une jointure avec le fonds de carte map_iris et on réalise une sauvegarde sous un autre nom. tabfin&lt;-tabdon %&gt;% rename(CODE_IRIS = IRIS) map_VOIT_IRIS&lt;-left_join(map, tabfin) %&gt;% st_as_sf() Joining, by = &quot;CODE_IRIS&quot; saveRDS(map_VOIT_IRIS, &quot;data/map_VOIT_IRIS.Rdata&quot;) 3.2.6 Carte de stock Une carte de stock représente la localisation de quantités que l’on peut aditionner et dont le total a un sens. Par exemple un nombre d’habitants, un nombre de ménages, un nombre d’automobiles. Ce quantités doivent être représentées par des figures (cercles, carrés, …) dont la surface est proportionelle au stock afin que l’oeil du lecteur puisse les aditionner visuellement. Dans le package cartography, on réalise ce type de carte à l’aide de la fonction PropSymbolLayer et on complète l’habillage de la carte (titre, sources, auteur, …) à l’aide de la fonction layoutLayer 3.2.6.1 Distribution des ménages map_com&lt;-readRDS(&quot;data/map_com.Rdata&quot;) map_iris&lt;-readRDS(&quot;data/map_VOIT_IRIS.Rdata&quot;) par(mar=c(0,0,2,0)) plot(map_iris$geometry, col=&quot;lightyellow&quot;, border=&quot;gray80&quot;,lwd=0.4) plot(map_com$geometry, col=NA, border=&quot;gray40&quot;,lwd=0.8, add=T) propSymbolsLayer(x = map_iris, var = &quot;MEN_TOTAL&quot;, col=&quot;blue&quot;, inches = 0.06, legend.title.txt = &quot;Nb ménages&quot;, legend.pos = &quot;left&quot;) layoutLayer(title = &quot;Distribution des ménages du Val de Marne en 2017&quot;, author = &quot;Master MECI / Option data mining&quot;, sources = &quot;INSEE, RP 2017, fichiers détail&quot;) 3.2.6.2 Distribution des automobiles map_com&lt;-readRDS(&quot;data/map_com.Rdata&quot;) map_iris&lt;-readRDS(&quot;data/map_VOIT_IRIS.Rdata&quot;) par(mar=c(0,0,2,0)) plot(map_iris$geometry, col=&quot;lightyellow&quot;, border=&quot;gray80&quot;,lwd=0.4) plot(map_com$geometry, col=NA, border=&quot;gray40&quot;,lwd=0.8, add=T) propSymbolsLayer(x = map_iris, var = &quot;VOIT_TOTAL&quot;, col=&quot;red&quot;, inches = 0.06, legend.title.txt = &quot;nb. véhicules&quot;, legend.pos = &quot;left&quot;) layoutLayer(title = &quot;Distribution des automobiles des ménages du Val de Marne en 2017&quot;, author = &quot;Master MECI / Option data mining&quot;, sources = &quot;INSEE, RP 2017, fichiers détail&quot;) 3.2.7 Carte d’intensité (choroplèthe) Une carte d’intensité représente un phénomène relatif dont la somme n’a pas de sens. Par exemple, il serait absurde d’aditionner les nombres d’automobiles par habitant des IRIS du Val de Marne. Ces variables d’intensité caractèrisent donc l’état général d’une zone (choros) at elles vont être représentées par une couleur appliquée à toute la surface de la zone, d’où leur nom de cartes choroplèthes. La fonction u package cartography adaptée aux variables d’intensité est la fonction Chorolayer. Comme précédemment on la combine avec la fonction LayoutLayerpour réaliser l’habillage de la carte. 3.2.7.1 Part des ménages sans automobile On va réaliser une carte allant du vert clair au vert foncé au fur et à mesure que le nombre de ménages sans automobiles augmente. map_com&lt;-readRDS(&quot;data/map_com.Rdata&quot;) map_iris&lt;-readRDS(&quot;data/map_VOIT_IRIS.Rdata&quot;) par(mar=c(0,0,2,0)) mybreaks = c(0, 10, 20, 30, 40, 50, 60, 70) mycols &lt;-carto.pal(pal1 = &quot;green.pal&quot;, n1 = 7) choroLayer(x = map_iris, var = &quot;PCT_VOIT0&quot;, breaks = mybreaks, col= mycols, lwd=0.2, colNA = &quot;gray80&quot;, legend.title.txt = &quot;% ménages&quot;, legend.pos = &quot;left&quot;, legend.values.rnd = 2, legend.nodata = &quot;Pas de données&quot;) plot(map_com$geometry, col=NA, border=&quot;gray10&quot;,lwd=0.8, add=T) layoutLayer(title = &quot;Part des ménages sans automobiles du Val de Marne en 2017&quot;, author = &quot;Master MECI / Option data mining&quot;, sources = &quot;INSEE, RP 2017, fichiers détail&quot;) 3.2.7.2 Nombre moyen d’automobiles par ménage On va prendre comme référence la valeur de 1 automobile par ménage et on va construire une double palette qui se dirrige vers le brun lorsque le nombre d’automobile par ménage augmente et vers l’orange lorsque le nombre d’automobile par ménage diminue map_com&lt;-readRDS(&quot;data/map_com.Rdata&quot;) map_iris&lt;-readRDS(&quot;data/map_VOIT_IRIS.Rdata&quot;) par(mar=c(0,0,2,0)) mybreaks = c(0.3,0.5, 0.6,0.7,0.8,0.9, 1,1.1, 1.2,1.3,1.4,1.5,2.1) mycols &lt;-carto.pal(pal1 = &quot;green.pal&quot;, n1 = 6, pal2 = &quot;orange.pal&quot;, n2 = 6) choroLayer(x = map_iris, var = &quot;VOIT_MEN&quot;, breaks = mybreaks, col= mycols, lwd=0.2, colNA = &quot;gray80&quot;, legend.title.txt = &quot;auto. / menage&quot;, legend.pos = &quot;left&quot;, legend.values.rnd = 2, legend.nodata = &quot;Pas de données&quot;) plot(map_com$geometry, col=NA, border=&quot;gray10&quot;,lwd=0.8, add=T) layoutLayer(title = &quot;Dépendance automobile des ménages du Val de Marne en 2017&quot;, author = &quot;Master MECI / Option data mining&quot;, sources = &quot;INSEE, RP 2017, fichiers détail&quot;) 3.2.8 Carte de stock + intensité On peut combiner les deux modes cartographiques. Prenons à titre d’exemple le cas des ménages ayant trois automobiles ou plus. Onn peut décrire ce phénomène soit en terme de stock, soit en termes d’intensité. summary(map_iris$MEN_VOIT3) Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s 0.00 12.50 21.42 26.20 33.77 145.76 9 summary(map_iris$PCT_VOIT3) Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s 0.000 1.170 1.943 2.510 3.160 16.114 9 On réalise les deux cartes successivement en commençant par la carte de taux puis en lui ajoutant la carte de stock par dessus. map_com&lt;-readRDS(&quot;data/map_com.Rdata&quot;) map_iris&lt;-readRDS(&quot;data/map_VOIT_IRIS.Rdata&quot;) par(mar=c(0,0,2,0)) mybreaks = c(0, 1,2,4,8,17) mycols &lt;-carto.pal(pal1 = &quot;taupe.pal&quot;, n1 = 5) choroLayer(x = map_iris, var = &quot;PCT_VOIT3&quot;, breaks = mybreaks, col= mycols, lwd=0.2, colNA = &quot;gray80&quot;, legend.title.txt = &quot;% ménages&quot;, legend.pos = &quot;topleft&quot;, legend.values.rnd = 2, legend.nodata = &quot;Pas de données&quot;) plot(map_com$geometry, col=NA, border=&quot;gray10&quot;,lwd=0.8, add=T) propSymbolsLayer(x = map_iris, var = &quot;MEN_VOIT3&quot;, col=&quot;red&quot;, inches = 0.06, legend.title.txt = &quot;nb. ménages&quot;, legend.pos = &quot;left&quot;) layoutLayer(title = &quot;Nombre et proportion des ménages ayant 3 automobiles ou plus en 2017&quot;, author = &quot;Master MECI / Option data mining&quot;, sources = &quot;INSEE, RP 2017, fichiers détail&quot;) 3.3 Création de fonctions L’objectif de cette section est de préparer des fonctions de cartographie qui pourront être intégrés dans une application shiny. On va pour cela reprendre les fonctions mises au point dans la partie statistiques et les coupler avec des procédures de cartographie. On se limitera dans l’immédiat à l’emploi des packages sfet cartography,mais on pourra par la suite créer d’autres fonctions fondées sur des packages tels que leaflet, plotlyou tmap… 3.3.1 fonction tab_cont_iris() On va prendre comme point de départ la création d’un tableau de contingence spatial c’est-à-dire un tableau dont les lignes correspondent aux IRIS d’une commune et les colonnes aux modalités d’une variable de type factor. On récupère les fonctions statistiques mises au point précédemment source(&quot;fonctions/mes_fonctions.R&quot;) On charge le fichier de données en lui ajoutant la variable LPRM_1 dont nous aurons besoin pour distinguer les données par ménage et pour l’ensemble de la population. 3.3.1.1 création du tableau avec la fonction tab_var tab&lt;-tab_var(data = RP, codecom = &quot;94071&quot;, list_mod = c(&quot;1&quot;), var = VOIT, IRIS) 3.3.1.2 pivotage du tableau On opére deux opérations de pivotage du tableau pour récupérer les valeurs brutes (raw) et les valeurs en % (pct). tab_raw &lt;- pivot_wider(data = tab %&gt;% select(-pct), names_from = VOIT, values_from = n, values_fill = 0) names(tab_raw)[-1] &lt;- paste(&quot;count_&quot;,names(tab_raw)[-1], sep=&quot;&quot;) tab_pct &lt;- pivot_wider(data = tab %&gt;% select(-n), names_from = VOIT, values_from = pct, values_fill = 0) names(tab_pct)[-1] &lt;- paste(&quot;pct_&quot;,names(tab_pct)[-1], sep=&quot;&quot;) 3.3.1.3 Ajout de la géométrie On fusionne les deux tableaux précédents et bon effectue la jointure avec le fonds de carte, ce qui suppose de renommer la variable IRIS en CODE_IRIS. tab_geo &lt;- left_join(tab_raw, tab_pct) %&gt;% rename(CODE_IRIS=IRIS) %&gt;% left_join(map_iris) %&gt;% st_as_sf() Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; 3.3.1.4 Création d’une fonction unique On reprend les étapes précédentes pour en faire une fonction unique appelée tab_cont_irisqui prend en entrée une variable quelconque de type factor et produit en sortie le tableau de contingence spatial soit par individu, soit par ménages. tab_cont_iris &lt;- function(data, codecom, list_mod, var) { # Create tab tab &lt;-tab_var(data, codecom, list_mod, {{var}}, IRIS) # Pivot count tab_raw &lt;- pivot_wider(data = tab %&gt;% select(-pct), names_from = {{var}}, values_from = n, values_fill = 0) names(tab_raw)[-1] &lt;- paste(&quot;count_&quot;,names(tab_raw)[-1], sep=&quot;&quot;) # Pivot pct tab_pct &lt;- pivot_wider(data = tab %&gt;% select(-n), names_from = {{var}}, values_from = pct, values_fill = 0) names(tab_pct)[-1] &lt;- paste(&quot;pct_&quot;,names(tab_pct)[-1], sep=&quot;&quot;) # join with geom tab_geo &lt;- left_join(tab_raw, tab_pct) %&gt;% rename(CODE_IRIS=IRIS) %&gt;% left_join(map_iris) %&gt;% st_as_sf() return(tab_geo) } 3.3.1.5 Test de la fonction On peut tester la fonction sur la variable SEXE en effectuant un comptage : soit pour la population totale en prenant list_mod = “0” SEXE_IRIS_pop &lt;- tab_cont_iris(RP,&quot;94071&quot;,&quot;0&quot;,SEXE) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; head(SEXE_IRIS_pop,3) # A tibble: 3 x 12 CODE_IRIS count_1 count_2 pct_1 pct_2 INSEE_COM NOM_COM IRIS NOM_IRIS &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 940710101 620 718 46.3 53.7 94071 Sucy-e… 0101 Le Gran… 2 940710102 645 737 46.7 53.3 94071 Sucy-e… 0102 La Foss… 3 940710103 776 1018 43.3 56.7 94071 Sucy-e… 0103 La Cite… # … with 3 more variables: TYP_IRIS &lt;chr&gt;, geometry &lt;MULTIPOLYGON [m]&gt;, # DEPT &lt;chr&gt; soit pour les chefs de ménage en prenant list_mod = “1” SEXE_IRIS_men &lt;- tab_cont_iris(RP,&quot;94071&quot;,&quot;1&quot;,SEXE) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; head(SEXE_IRIS_men,3) # A tibble: 3 x 12 CODE_IRIS count_1 count_2 pct_1 pct_2 INSEE_COM NOM_COM IRIS NOM_IRIS &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 940710101 474 338 58.4 41.6 94071 Sucy-e… 0101 Le Gran… 2 940710102 411 411 50 50 94071 Sucy-e… 0102 La Foss… 3 940710103 553 496 52.7 47.3 94071 Sucy-e… 0103 La Cite… # … with 3 more variables: TYP_IRIS &lt;chr&gt;, geometry &lt;MULTIPOLYGON [m]&gt;, # DEPT &lt;chr&gt; 3.3.2 fonction map_count_iris Nous allons créer différentes fonctions de cartographie selon que la variable à représenter est un stock (count_x) ou une intensité (pct_xx). Dans l’immédiat nous allons nous limiter aux fonctions de base du package cartographymais ou pourra par la suite proposer d’autres solutions. 3.3.2.1 Objectifs On prend comme entrée un tableau de contingence spatial et on décide de représenter l’une des modalités de type count. Soit par exemple la modalité 3 de la variable VOIT mesurée en nombre de ménages map&lt;-tab_cont_iris(RP,&quot;94071&quot;,&quot;0&quot;,VOIT) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; par(mar=c(0,0,2,0)) plot(map$geometry, col=&quot;lightyellow&quot;, border=&quot;gray80&quot;,lwd=0.4) propSymbolsLayer(x = map, var = &quot;count_3&quot;, col=&quot;blue&quot;, inches = 0.06, legend.title.txt = &quot;Nb ménages&quot;, legend.pos = &quot;topright&quot;) layoutLayer(title = &quot;Ménages avec trois voitures ou plus&quot;, author = &quot;Master MECI / Option data mining&quot;, sources = &quot;INSEE, RP 2017, fichiers détail&quot;) 3.3.2.2 Fonction minimale On va maintenant créer une fonction ayant autant de paramètres que nécessaire pour pouvoir s’appliquer à n’importe quelle modalité de n’importe quelle variable. La fonction minimale devra comporter 5 paramètres map_count_iris &lt;- function (data, codecom, list_mod, var, mod, titre) { mymap&lt;-tab_cont_iris(data,codecom,list_mod,{{var}}) myvar &lt;- paste(&quot;count_&quot;,mod, sep=&quot;&quot;) if (list_mod==0) {myleg = &quot;nb. d&#39;habitants&quot;} else {myleg = &quot;nb de ménages&quot;} par(mar=c(0,0,2,0)) plot(mymap$geometry, col=&quot;lightyellow&quot;, border=&quot;gray80&quot;,lwd=0.4) propSymbolsLayer(x = mymap, var = myvar, col=&quot;blue&quot;, inches = 0.06, legend.title.txt = myleg, legend.pos = &quot;topright&quot;) layoutLayer(title = titre, author = &quot;Master MECI / Option data mining&quot;, sources = &quot;INSEE, RP 2017, fichiers détail&quot;) } On teste la fonction sur les ménages ayant plus de trois voitures à Sucy-en-Brie map_count_iris(data = RP, codecom = &quot;94071&quot;, list_mod = &quot;1&quot;, var = VOIT, mod = 3, &quot;Ménages avec trois voitures ou plus&quot;) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; On vérifie qu’elle marche également sur une autre commune comme Saint-Maur-des-Fossés (94068). map_count_iris(data = RP, codecom = &quot;94068&quot;, list_mod = &quot;1&quot;, var = VOIT, mod = 3, &quot;Ménages avec trois voitures ou plus&quot;) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; … ou bien sur une autre modalité d’une autre variable. Par exemple la distribution des ménages dont la personne de référence est ouvrier à Sucy-en-Brie map_count_iris(data = RP, codecom = &quot;94071&quot;, list_mod = &quot;1&quot;, var = CS1, mod = 6, &quot;Ménages ouvriers en 2017&quot;) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; 3.3.2.3 Fonction améliorée Vous pouvez maintenant améliorer la fonction en lui ajoutant d’autres paramètres variables tels que : la source l’auteur la couleur de remplissage des cercles la couleur d’arrière-plan des iris le zoom d’aggrandissement des cercles etc. 3.3.3 fonction map_pct_iris Nous allons maintenant préparer un pogramme pour cartographier une variable d’intensité (pct_xx) dont la somme n’a pas de sens et qui doit donc utiliser le mode cartographique zonal (carte choroplèthe). 3.3.3.1 Objectifs On prend comme entrée le tableau de contingence spatial qui a été transformé en profil en ligne avec des modalités de type pct. Comme nous allons devoir établir automatiquement des classes sans connaître la forme de la distribution, nous devons utiliser une solution robuste. La méthode des quantiles apparaît alors comme la plus adaptée puisqu’elle consiste à découper la distribution en classes d’effectifs égaux. Concernant le nombre de classes, il doit dépendre du nombre d’éléments (ici d’IRIS) et nous allons utiliser pour cela la formule de Huntsberger qui indique le nombre maximum de classes souhaitable (K) en fonction du nombre d’élément (n). \\(K = 1 + \\frac{10}{3}.log_{10}(x)\\) On définit à partir de là une carte-type en prenant l’exemple du % de ménages n’ayant pas de voiture à Sucy-en-Brie huntsberger &lt;- function(x) {round(1+(10/3)*log10(x))} map&lt;-tab_cont_iris(RP,&quot;94071&quot;,&quot;0&quot;,VOIT) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; par(mar=c(0,0,2,0)) nbc&lt;-huntsberger(nrow(map)) choroLayer( x = map, nclass = nbc, method = &quot;quantile&quot;, var = &quot;pct_0&quot;, legend.title.txt = &quot;% ménages&quot;, legend.pos = &quot;topright&quot;, legend.values.rnd = 1) layoutLayer(title = &quot;Ménages n&#39;ayant pas de voiture&quot;, author = &quot;Master MECI / Option data mining&quot;, sources = &quot;INSEE, RP 2017, fichiers détail&quot;) 3.3.3.2 Fonction minimale On va maintenant créer une fonction ayant autant de paramètres que nécessaire pour pouvoir s’appliquer à n’importe quelle modalité de n’importe quelle variable. La fonction minimale devra comporter 5 paramètres map_pct_iris &lt;- function ( data, codecom, list_mod, var, mod, titre) { mymap&lt;-tab_cont_iris(data,codecom,list_mod,{{var}}) myvar &lt;- paste(&quot;pct_&quot;,mod, sep=&quot;&quot;) if (list_mod==0) {myleg = &quot;% des habitants&quot;} else {myleg = &quot;% des ménages&quot;} huntsberger &lt;- function(x) {round(1+(10/3)*log10(x))} nbc&lt;-huntsberger(nrow(map)) par(mar=c(0,0,2,0)) choroLayer( x = mymap, var = myvar, nclass = nbc, method = &quot;quantile&quot;, legend.title.txt = myleg, legend.pos = &quot;topright&quot;, legend.values.rnd = 1) layoutLayer(title = titre, author = &quot;Master MECI / Option data mining&quot;, sources = &quot;INSEE, RP 2017, fichiers détail&quot;) } On teste la fonction sur les ménages ayant plus de trois voitures à Sucy-en-Brie map_pct_iris(data = RP, codecom = &quot;94071&quot;, list_mod = &quot;1&quot;, var = VOIT, mod = 3, &quot;Ménages avec trois voitures ou plus&quot;) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; On vérifie qu’elle marche également sur une autre commune comme Saint-Maur-des-Fossés (94068). map_pct_iris(data = RP, codecom = &quot;94068&quot;, list_mod = &quot;1&quot;, var = VOIT, mod = 3, &quot;Ménages avec trois voitures ou plus&quot;) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; … ou bien sur une autre modalité d’une autre variable. Par exemple la distribution des ménages dont la personne de référence est ouvrier à Sucy-en-Brie map_pct_iris(data = RP, codecom = &quot;94071&quot;, list_mod = &quot;1&quot;, var = CS1, mod = 6, &quot;Ménages ouvriers en 2017&quot;) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; 3.3.3.3 Fonction améliorée Vous pouvez maintenant améliorer la fonction en lui ajoutant d’autres paramètres variables tels que : la source l’auteur la palette de couleur le nombre de classes le mode de découpage des classes etc. 3.3.4 Sauvegarde des fonctions On sauvegarde les nouvelles fonctions dans un nouveau fichier mes_fonctions_V2.R qui comporte les fonctions statistiques précédents et les nouvelles fonctions cartographiques mises au point dans ce chapitre. "]]

[["index.html", "Projet DATA MINING 2021 Master Meci - Parcours Data - Options PISE et CCESE", " Projet DATA MINING 2021 Master Meci - Parcours Data - Options PISE et CCESE C. Grasland et C. Signoretto 2021-05-04 "],["00-presentation.html", "Présentation", " Présentation À propos de ce document Ce document est la première version du cours de Data Mining dispensé aux étudiants de deuxième année de l’ option Data du master MECI Il est basé sur R version 4.0.2 (2020-06-22). Ce document est régulièrement corrigé et mis à jour. La version de référence est disponible en ligne à l’adresse : https://ClaudeGrasland.github.io/DataMiningProject2021. Pour toute suggestion ou correction, il est possible de contacter par mais les auteurs des chapitres Claude Grasland (CG) et Camille Signoretto (CS) Prérequis Le seul prérequis pour suivre ce document est d’avoir installé R et RStudio sur votre ordinateur. Il s’agit de deux logiciels libres, gratuits, téléchargeables en ligne et fonctionnant sous PC, Mac et Linux. Pour installer R, il suffit de se rendre sur une des pages suivantes 1 : Installer R sous Windows Installer R sous Mac Pour installer RStudio, rendez-vous sur la page suivante et téléchargez la version adaptée à votre système : https://www.rstudio.com/products/rstudio/download/#download Remerciements Ce document a bénéficié de la relecture et des suggestions … des étudiants qui en ont été les cobayes des premières versions. Ce document est généré par l’excellente extension bookdown de Yihui Xie et il s’est servi du template proposé par Julien Barnier pour introduire des exercices interactifs dans son cours de tidyverse. Licence Ce document est mis à disposition selon les termes de la Licence Creative Commons Attribution - Pas d’Utilisation Commerciale - Partage dans les Mêmes Conditions 4.0 International. Licence Creative Commons Sous Linux, utilisez votre gestionnaire de packages habituel.↩︎ "],["11-data.html", "Chapitre 1 Préparation des données (CG) 1.1 Introduction 1.2 Données statistiques sur les individus 1.3 Données statistiques sur les logements ordinaires 1.4 Données géométriques 1.5 Bilan et nettoyage", " Chapitre 1 Préparation des données (CG) library(knitr) library(dplyr) library(data.table) Attaching package: &#39;data.table&#39; The following objects are masked from &#39;package:dplyr&#39;: between, first, last The following object is masked from &#39;package:purrr&#39;: transpose library(readr) library(sf) Linking to GEOS 3.8.1, GDAL 3.1.4, PROJ 6.3.1 library(ggplot2) 1.1 Introduction L’objectif du projet Data Mining 2021 consistera à étudier les inégalités sociales et spatiales dans le département du Val de Marne à partir des données du dernier recensement de population de 2017. Ces inégalités seront envisagées à différentes échelles ce qui impliquera des procédures d’agrégation des fichiers détails. 1.2 Données statistiques sur les individus Nous partirons des fichiers détail de l’INSEE car, à la différence des tableaux prédéfinis, ils permettent virtuellement toutes les formes de croisement d’indicateurs. Ils sont évidemment beaucoup plus volumineux, mais ce sera justement l’occasion pour les étudiants en data mining d’être confrontés à des problèmes d’optimisation et de big data. On trouve leur description détaillée sur le site de l’INSEE dans la page consacrée au recensement : https://www.insee.fr/fr/statistiques/4508161 Nous avons opté pour le fichier des individus localisés au canton-ou-ville qui présente une grande polyvalence d’usage puisqu’il permet de reconstituer des tableau agrégés ou l’unité de compte peut-être soit le ménage, soit l’individu selon le critère de pondération adopté. 1.2.1 Etape 1 : téléchargement des données et stockage temporaire Nous allons télécharger ici le fichier des données pour la région Ile-de-France au format .csv et l’enregistrer dans un dossier spécial tmp qui pourra ulétérieurement être détruit ou déplacé afin de libérer de la place N.B. Ce programme qui prend quelques minutes sera exécuté une seule fois. On ajoutera ensuite dans l’en-tête du chunk eval=FALSE ce qui veut dire que ce bloc de code ne sera plus executé automatiquement lorsqu’on réalise un knit du document Rmd. Il sera néanmoins toujours possible de l’executer manuellement en cliquant sur sa petite flèche verte. ### Téléchargement du fichier INSEE download.file(url=&quot;https://www.insee.fr/fr/statistiques/fichier/4802064/RP2017_INDCVIZA_csv.zip&quot;, destfile = &quot;tmp/indiv2017.zip&quot;) ## Decompression du fichier INSEE unzip(zipfile = &quot;tmp/indiv2017.zip&quot;, exdir = &quot;tmp&quot;) ## Examen du contenu list.files(&quot;tmp&quot;) Nous constatons que le document zippé contenait en fait deux fichiers différents Le fichier de données individuelles FD_INDCVIZA_2017.csv : qui pèse au bas mot 1014.3 Mo (1 Giga) et dont nous verrons par la suite qu’il comporte 4.3 millions de lignes et 88 colonnes. Le fichier de métadonnées varmod_INDCVI_2017.csv : qui ne pèse que 1.8 Mo et comprend la description précise du label de chacune des modalités de variables. 1.2.2 Etape 2 : Transformation des données au format R L’importation d’un tableau aussi gros (4.3 millions de lignes et 88 colonnes) donne l’occasion de faire quelques tests de vitesses sur les différents packages capables de lire des fichiers .csv. Nous allons pour cela utiliser la fonction Sys.time()qui permet de repérer l’heure au début et à la fin d’une action. Les résultats dépendront évidemment de la vitesse de l’ordinateur. Il s’agit ici d’un MacBook Pro 2.9 Ghz, disposant de 4 coeurs et 16 Go de mémoire. 1.2.2.1 Chargement avec la fonction read.csv Avec la fonctionread.csv ui fait partie du R-base , le temps de chargement est de 150 secondes. Le tableau résultant est de classe data.frame puisque nous avons utilisé une fonction native de R-base t1&lt;-Sys.time() tab&lt;-read.csv(&quot;tmp/FD_INDCVIZA_2017.csv&quot;, sep = &quot;;&quot;, header =T) t2&lt;-Sys.time() paste (&quot;chargement effectué en&quot;,t2-t1,) dim(tab) class(tab) 1.2.2.2 Chargement avec la fonction read_csv2 avec la fonction read_csv2 du package readr, le chargement est effectué en 59 secondes sur le même ordinateur. Le tableau résultant garde la classe data.frame mais est aussi un tibble puisque le package readr fait partie de l’écosystème tibble/tidyverse. Le temps de chrgement est donc divisé par deux. library(readr) t1&lt;-Sys.time() tab&lt;-read_csv2(&quot;tmp/FD_INDCVIZA_2017.csv&quot;) t2&lt;-Sys.time() paste (&quot;chargement effectué en&quot;,t2-t1, &quot;secondes&quot;) dim(tab) class(tab) 1.2.2.3 Chargement avec la fonction fread avec la fonction fread du package data.table, le chargement est effectué en 31 secondes sur le même ordinateur.Le tableau résultant conserve la classe data.frame mais possède aussi la classe data.table puisque la fonction fread est issue de ce package. Le temps est divisé encore une fois par deux. library(data.table) t1&lt;-Sys.time() tab&lt;-fread(&quot;tmp/FD_INDCVIZA_2017.csv&quot;) t2&lt;-Sys.time() paste (&quot;chargement effectué en&quot;,t2-t1, &quot;secondes&quot;) dim(tab) class(tab) On voit donc que le temps de chargement peut différer fortement selon le choix des packages. Il en va ensuite de même pour les traitements d’agrégation des données qui seront plus ou moins rapides selon que l’on utilise les fonctions de R-base applicables à un data.frame, celles du package tidyverse applicables à un tibble ou enfin celles du package data.table applicables à un data.table. 1.2.3 Etape 3 : Sélection des données utiles et sauvegarde au format .Rdata Nos différentes tableaux peuvent être enregistés au format interne de .R ce qui réduira considérablement leur taille par rapport au fichier texte au format csv qui pèse 1.06 Go. Nous allons également limiter la taille du document en ne conservant que les données qui nous intéressent, en l’occurence celles du département du Val de Marne. Comme ces données bvont nous servir durant tout le projet, elles seront stockées dans le dossier data situé à l’intérieur du projet et non pas dans le dossier tmp qui sera détruit si l’on n’en a plus besoin pour libérer de la place. N.B. On ramène l’objet à la classe d’objet unique data.frame pour éviter des conflits possibles entre package. On pourra toujours le retransformer ensuite en data.table ou en tibble. ## Chargement avec fread (+ rapide) tab&lt;-fread(&quot;tmp/FD_INDCVIZA_2017.csv&quot;) ## Suppression de la classe data.table tab&lt;-as.data.frame(tab) ## Selection des données relatives au Val de Marne sel &lt;- tab %&gt;% filter(DEPT == 94) ## Vérification des dimensions du tableau dim(sel) ## Sauvegarde au format RDS saveRDS(object = sel, file = &quot;data/indiv2017.Rdata&quot;) On peut effectuer de façon facultative une sauvegarde au format .csv ce qui évitera des problème d’ouverture du fichier .Rdata pour les personnes ayant des versions anciennes de R. Mais du coup cela engendrera un fichier très volumineux (200 Mo). ## Sauvegarde au format CSV (facultatif) write.table(x=sel, file = &quot;data/indiv2017.csv&quot;, sep=&quot;;&quot;, dec = &quot;.&quot;, fileEncoding = &quot;UTF-8&quot;) 1.2.3.1 Etape 4 : Chargement et sauvegarde des méta-données Il ne faut surtout pas oublier le fichier des métadonnées qui va permettre de recoder facilement tous les facteurs et de décoder les chiffres correspondant aux classes. On va donc le transformer au format R puis l’enregistrer également dans le dossier data. # Lecture du fichier de métadonnées meta&lt;-fread(&quot;tmp/varmod_INDCVI_2017.csv&quot;) # Enregistrement dans le dossier data saveRDS(object = meta, file = &quot;data/indiv2017_meta.Rdata&quot;) 1.3 Données statistiques sur les logements ordinaires Nous allons reproduire sans les commenter de façon aussi détaillée les mêmes étapes que précédemment pour construire un fichier des logements ordinaires dont la description se trouve à l’adresse suivante : https://www.insee.fr/fr/statistiques/4802056?sommaire=4508161 1.3.1 Etape 1 : récupération des fichiers ### Téléchargement du fichier INSEE download.file(url=&quot;https://www.insee.fr/fr/statistiques/fichier/4802056/RP2017_LOGEMTZA_csv.zip&quot;, destfile = &quot;tmp/logmt2017.zip&quot;) ## Decompression du fichier INSEE unzip(zipfile = &quot;tmp/logmt2017.zip&quot;, exdir = &quot;tmp&quot;) ## Examen du contenu list.files(&quot;tmp&quot;) Comme dans le cas du fichier des individus, on trouve un fichier des données et un fichier des métadonnées qu’il faut tous les deux récupérer. 1.3.2 Etape 2 : Transformation des données au format R On utilise la fonction fread du package data.table qui est la plus rapide ## Chargement avec fread (+ rapide) tab&lt;-fread(&quot;tmp/FD_LOGEMTZA_2017.csv&quot;) 1.3.3 Etape 3 : Sélection des données utiles et sauvegarde au format .Rdata On remet le tableau au format standard data.frame , on sélectionne la zone d’étude et on sauvegarde au format .Rdata. N.B Comme la variable DEPT n’existe pas on utilise les deux premiers chiffres du code de la variable COMMUNE pour la créer ## Suppression de la classe data.table tab&lt;-as.data.frame(tab) ## Selection des données relatives au Val de Marne sel &lt;- tab %&gt;% mutate(DEPT = substr(COMMUNE,1,2)) %&gt;% filter(DEPT == &quot;94&quot;) ## Vérification des dimensions du tableau dim(sel) ## Sauvegarde au format RDS saveRDS(object = sel, file = &quot;data/logmt2017.Rdata&quot;) 1.3.3.1 Etape 4 : Chargement et sauvegarde des méta-données Comme dans le cas des logements, on sauvegarde précieusement le fichier des métadonnées. # Lecture du fichier de métadonnées meta&lt;-fread(&quot;tmp/varmod_LOGEMT_2017.csv&quot;) # Enregistrement dans le dossier data saveRDS(object = meta, file = &quot;data/logmt2017_meta.Rdata&quot;) 1.4 Données géométriques Les contours des unités spatiales correspondant aux codes de l’INSEE sont produits par l’IGN et disponibles sur le site géoservice en accès libre : https://geoservices.ign.fr/documentation/diffusion/telechargement-donnees-libres.html 1.4.1 Etape 1 : récupération du fonds IRIS au format shapefile La principale difficulté est de s’orienter dans l’ensemble des produits disponibles. Dans l’exemple présent, nous cherchhons le contour des IRIS, c’est-à-dire des entités infra-communales correspondant au découpage utilisé lors du recensement de 2017. Comme précédemment, nous allons stocker le résultat du téléchargement dans notre fichier tmp qui sera détruit ou déplacé lorsque nous aurons récupéré toutes les données utiles. download.file(url=&quot;https://wxs.ign.fr/1yhlj2ehpqf3q6dt6a2y7b64/telechargement/inspire/CONTOURS-IRIS-2017-06-30%24CONTOURS-IRIS_2-1__SHP__FRA_2017-06-30/file/CONTOURS-IRIS_2-1__SHP__FRA_2017-06-30.7z&quot;, destfile = &quot;tmp/geom.7z&quot;) Il n’est apparemment pas possible de décompresser le fichier avec la fonction unzip de R, donc on effectue cette opération manuellement. Il en résulte une arborescence très complexe de dossiers et de sous-dossiers correspondant aux IRIS de la Francé métropolitaine mais aussi de chacun des DOM. Il faut alors aller repérer dans cet arborescence le dossier où se trouve le fonds IRIS de la France métropolitaine qui est au format shapefile et comporte plusieurs fichiers avec des extensions différentes. list.files(&quot;tmp/CONTOURS-IRIS_2-1__SHP__FRA_2017-06-30/CONTOURS-IRIS/1_DONNEES_LIVRAISON_2016/CONTOURS-IRIS_2-1_SHP_LAMB93_FE-2016&quot;) [1] &quot;CONTOURS-IRIS.cpg&quot; &quot;CONTOURS-IRIS.dbf&quot; &quot;CONTOURS-IRIS.prj&quot; [4] &quot;CONTOURS-IRIS.shp&quot; &quot;CONTOURS-IRIS.shx&quot; &quot;LISTE.csv&quot; 1.4.2 Etape 2 : Importation et transformation au format sf La cartographie et plus généralement les opérations géométriques sur des données spatiales dans R peuvent facilement être effectuées avec le package sf (spatial features) qui crée des objets ubniques rassemblant à la fois un tableau de données (l’équivalent du fichier .dbf) une géométrie (l’équivalent du fichier .shp) une projection (l’équivalent du fichier .prj) Lorsqu’on récupère des fonds de carte au format shapefile (.shp) ou dans d’autres formats standards comme GeoJson, la première tâche consiste donc à les convertir au formt sf afin de pouvoir les utiliser facilement dans R. L’importation se fait à l’aide de l’instruction st_read en indiquant juste le nom du fichier .shp à charger. Les autres fichiers (.dbf ou .proj) seront lus également et intégrés dans l’objet qui hérite de la double classe data.frame et sf library(sf) map &lt;- st_read(&quot;tmp/CONTOURS-IRIS_2-1__SHP__FRA_2017-06-30/CONTOURS-IRIS/1_DONNEES_LIVRAISON_2016/CONTOURS-IRIS_2-1_SHP_LAMB93_FE-2016/CONTOURS-IRIS.shp&quot;) Reading layer `CONTOURS-IRIS&#39; from data source `/Users/claudegrasland1/Documents/cg/cours/2020_M2_MECI_Datamining/DataMiningProject2021/tmp/CONTOURS-IRIS_2-1__SHP__FRA_2017-06-30/CONTOURS-IRIS/1_DONNEES_LIVRAISON_2016/CONTOURS-IRIS_2-1_SHP_LAMB93_FE-2016/CONTOURS-IRIS.shp&#39; using driver `ESRI Shapefile&#39; Simple feature collection with 49404 features and 6 fields Geometry type: MULTIPOLYGON Dimension: XY Bounding box: xmin: 99040 ymin: 6049662 xmax: 1242445 ymax: 7110479 Projected CRS: RGF93_Lambert_93 dim(map) [1] 49404 7 class(map) [1] &quot;sf&quot; &quot;data.frame&quot; head(map,2) # A tibble: 2 x 7 INSEE_COM NOM_COM IRIS CODE_IRIS NOM_IRIS TYP_IRIS geometry &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;MULTIPOLYGON [m]&gt; 1 72191 Mayet 0000 721910000 Mayet Z (((498083.5 6747517, 4981… 2 77248 Lesches 0000 772480000 Lesches Z (((685753.1 6868613, 6857… 1.4.3 Etape 3 : Extraction des IRIS de la zone d’étude Le fichier comporte près de 50 000 unités spatiales qui correspondent soit à des communes suffisamment grandes pour être découpées en IRIS, soit à des communes non découpées. On reconnaît ces dernières au fait que leur code IRIS se termine par ‘00000’. Supposons qu’on veuille extraire le fonds de carte du Val de Marne. On va commencer par créer une variable DEPT en extrayant les dxeux premiers caractères du code communal, puis on va sélectionner le départements correspondant : map_iris&lt;-map %&gt;% mutate(DEPT = substr(INSEE_COM,1,2)) %&gt;% filter(DEPT %in% c(&quot;94&quot;)) dim(map_iris) [1] 527 8 class(map_iris) [1] &quot;sf&quot; &quot;data.frame&quot; head(map_iris,2) # A tibble: 2 x 8 INSEE_COM NOM_COM IRIS CODE_IRIS NOM_IRIS TYP_IRIS geometry &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;MULTIPOLYGON [m]&gt; 1 94021 Chevil… 0107 940210107 Sorbiers H (((652774.3 6853051, 652… 2 94068 Saint-… 0204 940680204 Le Vieu… H (((662096.5 6856264, 662… # … with 1 more variable: DEPT &lt;chr&gt; Le nouveau tableau ne comporte plus que 2749 unités spatiales et 8 colonnes au lieu de 7 puisqu’ l’on a ajouté une colonne DEPT. On peut visualiser le résultat à l’aide de la fonction geom_sfdu package ggplot2 : ggplot(map_iris)+geom_sf(fill=&quot;lightyellow&quot;,col=&quot;red&quot;) + theme_void() On sauvegarde le résultat dans notre dossier data au format interne de R : saveRDS(object = map_iris, file = &quot;data/map_iris.Rdata&quot;) On peut également effectuer (de façon facultative) une sauvegarde au format shapefile afin de pouvoir réutiliser le fonds de carte à l’aide d’autres applications externes à R. st_write(obj = map_iris, dsn= &quot;data/map_iris.shp&quot;, # indique le format de sortie par l&#39;extension .shp delete_dsn = TRUE, # écrase le fichier s&#39;il existe déjà quiet = TRUE) # évite que R fasse des commentaires 1.4.4 Etape 4 : création d’un fonds de carte des communes Comme nous serons amenés à travailler à plusieurs échelles, nous produisons tout de suite un fonds de carte des communes en utilisant les fonctions d’agrégation du packages sf combinées avec celles de dplyr. map_com &lt;- map_iris %&gt;% group_by(INSEE_COM) %&gt;% summarise(NOM_COM = min(NOM_COM)) %&gt;% st_as_sf() `summarise()` ungrouping output (override with `.groups` argument) on vérifie que l’agrégation s’est bien passée : ggplot(map_com)+geom_sf(fill=&quot;lightyellow&quot;,col=&quot;red&quot;) + theme_void() Et on sauvegarde le fonds de carte saveRDS(object = map_com, file = &quot;data/map_com.Rdata&quot;) 1.4.5 Etape 5 : création d’un fonds de carte par département Enfin, on construit un fonds de carte des départements selon la même procédure : map_dep &lt;- map_iris %&gt;% mutate(DEPT = substr(INSEE_COM,1,2))%&gt;% group_by(DEPT) %&gt;% summarise() %&gt;% st_as_sf() `summarise()` ungrouping output (override with `.groups` argument) ggplot(map_dep)+geom_sf(fill=&quot;lightyellow&quot;,col=&quot;red&quot;) + theme_void() saveRDS(object = map_dep, file = &quot;data/map_dep.Rdata&quot;) 1.4.6 Etape 6: Superposition des trois fonds de carte On va utiliser la fonction plot du package sf qui permet de visualiser la variable geometry et facilite les superpositions avec l’instruction add=TRUE. par(mar=c(0,0,0,0)) plot(map_iris$geometry, col= &quot;lightyellow&quot;, border = &quot;gray80&quot;, lwd=0.5) plot(map_com$geometry, col= NA, border = &quot;gray50&quot;, lwd=1, add=TRUE) plot(map_dep$geometry, col= NA, border = &quot;gray30&quot;, lwd=2, add=TRUE) 1.5 Bilan et nettoyage Nous avons désormais un dossier data qui comporte : Le fichier des individus et ses métadonnées Le fichier des logements ordinaires et ses métadonnées Les fonds de carte par iris, commune et département. list.files(&quot;data&quot;) [1] &quot;bpe2019_94_map.Rdata&quot; &quot;bpe2019_94.csv&quot; [3] &quot;bpe2019_meta.csv&quot; &quot;indiv_2017_meta.Rdata&quot; [5] &quot;indiv2017_meta.Rdata&quot; &quot;indiv2017.Rdata&quot; [7] &quot;logmt2017_meta.Rdata&quot; &quot;logmt2017.Rdata&quot; [9] &quot;map_com.Rdata&quot; &quot;map_dep.Rdata&quot; [11] &quot;map_iris.Rdata&quot; &quot;map_VOIT_IRIS.Rdata&quot; [13] &quot;mapdon_94068.Rdata&quot; &quot;mapdon_94071.Rdata&quot; [15] &quot;sel_map_act_csp.Rdata&quot; &quot;sel_map_men_auto.Rdata&quot; [17] &quot;sel_map_men_csp.Rdata&quot; &quot;sel_map_pop_csp.Rdata&quot; [19] &quot;sel_map_pop_hlm.Rdata&quot; &quot;VDM_RP2017_ANEMR_IRIS_MEN.Rdata&quot; [21] &quot;VDM_RP2017_CS1_IRIS_POP.Rdata&quot; &quot;VDM_RP2017_TRANS_IRIS_ACT.Rdata&quot; [23] &quot;VOIT_IRIS.Rdata&quot; On peut alors décider de détruire le dossier tmp qui contient des dossiers très volumineux et pas forcément indispensables. "],["12-statistics.html", "Chapitre 2 Analyse statistique (CS) 2.1 Introduction 2.2 Quelques statistiques sur les logements et ménages 2.3 Quelles caractéristiques des individus résidant dans le Val de Marne en 2017 ? 2.4 La création de fonctions", " Chapitre 2 Analyse statistique (CS) # On charge les librairies principales que l&#39;on va utiliser library(knitr) library(tidyverse) library(data.table) library(questionr) library(RColorBrewer) 2.1 Introduction 2.1.1 Les données du Recensement de la Population (RP) Il existe plusieurs fichiers disponibles sur le site de l’Insee concernant l’enquête du Recensement de la Population, la dernière année disponible datant de 2017. Ces fichiers sont lourds, ils peuvent être téléchargés par zone, c’est ce que nous allons faire ensuite. Soit vous le téléchargez via internet et enregistrez le fichier dans un de vos dossiers bien spécifiés et vous le “dézippez”, soit vous le télécharger directement dans R. On va s’intéresser au fichier “Individus localisés au canton-ou-ville” : on le télécharge pour la zone A c’est-à-dire l’Ile-de-France. download.file(url=&quot;https://www.insee.fr/fr/statistiques/fichier/4802064/RP2017_INDCVIZA_csv.zip&quot;, destfile = &quot;tmp/RP2017_INDCVIZA_csv.zip&quot;) #Le fichier a donc été téléchargé dans le dossier intitulé &quot;tmp&quot; du projet R, on va maintenant le dézippé et enregistrer les fichiers extraits dans le même dossier. unzip(&quot;tmp/RP2017_INDCVIZA_csv.zip&quot;, exdir = &quot;tmp&quot;) Il nous reste plus qu’à charger les données dans R : pour cela on utilise la commande fread du package data.table car cela va bien plus vite que les fonctions plus habituelles du type read.csv, et on vérifie en regardant les premiers éléments de la table qu’elle a bien été chargée : #library(data.table) RP &lt;- fread(&quot;tmp/FD_INDCVIZA_2017.csv&quot;, stringsAsFactors=TRUE) RP &lt;- as.data.frame(RP) head(RP) str(RP) On a donc 88 variables et plus de 4 341 175 observations pour l’ensemble de l’Ile de France. Le fait que le nombre d’individus recensés soit inférieur à la population totale de l’Ile de France (plus de 12 millions d’habitants au RP 2017) s’explique par les méthodes de sondage utilisées dans le nouveau recensement en France depuis les années 2000. C’est la raison pour laquelle tous les calculs doivent être pondérés par la variable IPONDIpour être représentatifs Certaines des variables ont été codées comme numériques alors que, selon le dictionnaire des variables, elles devraient être toutes en caractères ou ici dans R en facteurs, on va regarder quelles variables sont concernées et on va les transformer pour qu’elles soient dans le bon format. Ci-dessous, la fonction select_if du package dplyr permet de sélectionner les variables avec une condition (d’où le “if”) donnée entre parenthèses, ici donc si ces variables ont le format “numeric” : RP %&gt;% select_if(is.numeric) %&gt;% names() On en a 23 sur 88, mais attention il y a la variable de pondération IPONDI qui, elle, doit rester numérique, donc on peut procéder au changement de type pour l’ensemble de ces variables sauf celle de pondération, avec la fonction mutate_at en spécifiant l’ensemble des variables concernées (copiées-collées depuis la sortie précédente en veillant bien sûr à bien enlever IPONDI), et vérifier. RP %&gt;% mutate_at(c(&quot;AGED&quot;, &quot;AGER20&quot;, &quot;AGEREV&quot;, &quot;AGEREVQ&quot;, &quot;ANAI&quot;, &quot;CATPC&quot;, &quot;COUPLE&quot;, &quot;CS1&quot;, &quot;DEPT&quot;, &quot;ETUD&quot;, &quot;IMMI&quot;, &quot;INAI&quot;, &quot;INATC&quot;, &quot;MOCO&quot;, &quot;MODV&quot;, &quot;NAIDT&quot;, &quot;ORIDT&quot;, &quot;REGION&quot;, &quot;SEXE&quot;, &quot;STAT_CONJ&quot;,&quot;TACT&quot;, &quot;TACTD16&quot;), factor) %&gt;% select_if(is.numeric) %&gt;% head(5) On remplace maintenant la table et dans le même temps on ne garde que le département du Val de Marne (variable DEPT, modalité '94') sur lequel on va travailler. On procède donc finalement avec le code suivant : RP &lt;- RP %&gt;% mutate_at(c(&quot;AGED&quot;, &quot;AGER20&quot;, &quot;AGEREV&quot;, &quot;AGEREVQ&quot;, &quot;ANAI&quot;, &quot;CATPC&quot;, &quot;COUPLE&quot;, &quot;CS1&quot;, &quot;DEPT&quot;, &quot;ETUD&quot;, &quot;IMMI&quot;, &quot;INAI&quot;, &quot;INATC&quot;, &quot;MOCO&quot;, &quot;MODV&quot;, &quot;NAIDT&quot;, &quot;ORIDT&quot;, &quot;REGION&quot;, &quot;SEXE&quot;, &quot;STAT_CONJ&quot;, &quot;TACT&quot;, &quot;TACTD16&quot;), factor) %&gt;% filter(DEPT==&#39;94&#39;) On se retrouve avec une table moins lourde puisqu’il y a dorénavant 530 007 observations. On peut enregistrer ce fichier, ainsi que celui contenant les métadonnées dans le dossier R au format RDS avec la fonction saveRDS. saveRDS(object = RP, file = &quot;data/indiv2017.Rdata&quot;) # Lecture du fichier de métadonnées et enregistrement dans le dossier Data de notre projet meta &lt;- fread(&quot;tmp/varmod_INDCVI_2017.csv&quot;) # Enregistrement dans le dossier data saveRDS(object = meta, file = &quot;data/indiv_2017_meta.Rdata&quot;) Pour l’importer, il faudra utiliser la fonction readRDS, comme l’exemple ci-dessous (sans l’exécuter) : RP&lt;-readRDS(file =&quot;data/indiv2017.Rdata&quot;) 2.1.2 Quelles variables sont présentes dans les données ? Quelle spécificité ? L’une des difficultés pour l’analyse de cette base de données réside dans les différents niveaux présents : “individu” pour la personne de référence du ménage ; “ménage” regroupant l’ensemble des occupants d’une résidence principale, qu’ils aient ou non des liens de parenté ; “famille” partie d’un ménage comprenant au moins 2 personnes (par exemple, un couple, ou un adulte avec un enfant…) ; et enfin “logement” qui comprend ici les résidences principales, et rassemble des informations décrivant les types de logement. Pour se familiariser avec cette base de données, puisque cette année le projet que vous devrez réaliser porte sur cette base, il faut d’abord étudier les variables qu’elle contient. Un premier travail va ainsi consister à trier les 88 variables selon 5 thèmes : variables décrivant le logement ; variables décrivant le ménage ; variables décrivant la famille ; variables décrivant l’individu ; variables géographiques. Une fois cela effectué, il faut comprendre comment utiliser à bon escient ces différents niveaux. Ainsi, pour toute variable au niveau logement, ménage et famille, il faudra utiliser un filtre : ne prendre que la personne de référence du ménage. On peut toutefois vouloir donner des statistiques sur la “population des ménages”. C’est ce que nous allons voir, en prenant appui sur les statistiques produites par l’Insee pour ce département. 2.2 Quelques statistiques sur les logements et ménages Premier exercice à faire : étudier l’équipement automobile des ménages, en essayant de retrouver les statistiques ci-dessous de l’Insee dont la source est ici. #Emplacement stationnement : RP %&gt;% filter(LPRM==&quot;1&quot;) %&gt;% mutate(Stationnement=recode(GARL, &quot;1&quot;=&quot;Au moins un emplacement réservé au stationnement&quot;, &quot;2&quot; = &quot;Aucun emplacement&quot;)) %&gt;% count(Stationnement, wt=IPONDI) %&gt;% mutate(n=round(n,0),pct=prop.table(n)*100, pct=round(pct, 1)) %&gt;% kable(format.args = list(big.mark = &quot; &quot;)) Stationnement n pct Au moins un emplacement réservé au stationnement 321 768 54.8 Aucun emplacement 264 910 45.2 #Voiture : RP %&gt;% filter(LPRM==&quot;1&quot;) %&gt;% mutate(Voiture=case_when(VOIT %in% c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;) ~ &quot;Au moins une voiture&quot;, VOIT==&quot;0&quot; ~ &quot;Pas de voiture&quot;)) %&gt;% count(Voiture, wt=IPONDI) %&gt;% mutate(n=round(n,0),pct=prop.table(n)*100, pct=round(pct, 1)) %&gt;% kable(format.args = list(big.mark = &quot; &quot;)) Voiture n pct Au moins une voiture 400 704 68.3 Pas de voiture 185 974 31.7 RP %&gt;% filter(LPRM==&quot;1&quot;) %&gt;% mutate(Nb_voiture=case_when(VOIT==&quot;1&quot; ~ &quot;1 voiture&quot;, VOIT %in% c(&quot;2&quot;, &quot;3&quot;) ~ &quot;2 voitures ou plus&quot;, VOIT==&quot;0&quot; ~ &quot;Pas de voiture&quot;)) %&gt;% count(Nb_voiture, wt=IPONDI) %&gt;% mutate(n=round(n,0),pct=prop.table(n)*100, pct=round(pct, 1)) %&gt;% kable(format.args = list(big.mark = &quot; &quot;)) Nb_voiture n pct 1 voiture 295 286 50.3 2 voitures ou plus 105 418 18.0 Pas de voiture 185 974 31.7 Second exercice à faire : étudier l’ancienneté d’emménagement dans la résidence principale en 2017, en essayant de retrouver de même les statistiques ci-dessous de l’Insee (même source : ici) : #Ancienneté d&#39;emménagement en nombre de ménage RP %&gt;% filter(LPRM==&quot;1&quot;) %&gt;% mutate(Anciennete=case_when(ANEMR==&quot;00&quot; ~ &quot;Depuis moins de 2 ans&quot;, ANEMR==&quot;01&quot; ~ &quot;De 2 à 4 ans&quot;, ANEMR==&quot;02&quot; ~ &quot;De 5 à 9 ans&quot;, as.numeric(ANEMR)&gt;3 ~ &quot;10 ans ou plus&quot;), Anciennete = factor(Anciennete, levels=c(&quot;Depuis moins de 2 ans&quot;,&quot;De 2 à 4 ans&quot;,&quot;De 5 à 9 ans&quot;,&quot;10 ans ou plus&quot;))) %&gt;% count(Anciennete, wt=IPONDI) %&gt;% mutate(n=round(n,0),pct=prop.table(n)*100, pct=round(pct, 1)) %&gt;% bind_rows(summarise(Anciennete = &quot;Ensemble&quot;, RP[RP$LPRM==&quot;1&quot;, ], n = sum(IPONDI), pct = 100.0)) %&gt;% kable(format.args = list(big.mark = &quot; &quot;)) Anciennete n pct Depuis moins de 2 ans 67 956 11.6 De 2 à 4 ans 125 587 21.4 De 5 à 9 ans 109 449 18.7 10 ans ou plus 283 686 48.4 Ensemble 586 678 100.0 #Ancienneté d&#39;emménagement en population des ménages RP %&gt;% filter(CATL==&quot;1&quot;) %&gt;% mutate(Anciennete=case_when(ANEMR==&quot;00&quot; ~ &quot;Depuis moins de 2 ans&quot;, ANEMR==&quot;01&quot; ~ &quot;De 2 à 4 ans&quot;, ANEMR==&quot;02&quot; ~ &quot;De 5 à 9 ans&quot;, as.numeric(ANEMR)&gt;3 ~ &quot;10 ans ou plus&quot;), Anciennete = factor(Anciennete, levels=c(&quot;Depuis moins de 2 ans&quot;,&quot;De 2 à 4 ans&quot;,&quot;De 5 à 9 ans&quot;,&quot;10 ans ou plus&quot;)), nb_pieces=as.numeric(as.character(NBPI))) %&gt;% count(Anciennete, wt=IPONDI) %&gt;% mutate(n=round(n,0), pct=prop.table(n)*100, pct=round(pct, 1)) %&gt;% bind_rows(summarise(Anciennete = &quot;Ensemble&quot;, RP[RP$CATL==&quot;1&quot;, ], n = sum(IPONDI), pct = 100.0)) %&gt;% kable(format.args = list(big.mark = &quot; &quot;)) Anciennete n pct Depuis moins de 2 ans 141 773 10.4 De 2 à 4 ans 296 324 21.7 De 5 à 9 ans 293 371 21.5 10 ans ou plus 632 159 46.4 Ensemble 1 363 627 100.0 #Nombre moyen de pièces par logement RP %&gt;% filter(LPRM==&quot;1&quot;) %&gt;% mutate(Anciennete=case_when(ANEMR==&quot;00&quot; ~ &quot;Depuis moins de 2 ans&quot;, ANEMR==&quot;01&quot; ~ &quot;De 2 à 4 ans&quot;, ANEMR==&quot;02&quot; ~ &quot;De 5 à 9 ans&quot;, as.numeric(ANEMR)&gt;3 ~ &quot;10 ans ou plus&quot;), Anciennete = factor(Anciennete, levels=c(&quot;Depuis moins de 2 ans&quot;,&quot;De 2 à 4 ans&quot;,&quot;De 5 à 9 ans&quot;,&quot;10 ans ou plus&quot;)), Np_pieces=as.numeric(as.character(NBPI))) %&gt;% group_by(Anciennete) %&gt;% summarise(Np_pieces_moy=weighted.mean(Np_pieces, IPONDI, na.rm=T)) %&gt;% bind_rows(summarise(Anciennete = &quot;Ensemble&quot;, RP[RP$LPRM==&quot;1&quot;, ], Np_pieces_moy = weighted.mean(as.numeric(as.character(NBPI)), IPONDI, na.rm=T))) %&gt;% mutate(Np_pieces_moy=round(Np_pieces_moy, 1)) %&gt;% kable(format.args = list(big.mark = &quot; &quot;)) `summarise()` ungrouping output (override with `.groups` argument) Anciennete Np_pieces_moy Depuis moins de 2 ans 2.6 De 2 à 4 ans 2.8 De 5 à 9 ans 3.2 10 ans ou plus 3.7 Ensemble 3.3 #Nombre moyen de pièces par personne RP %&gt;% filter(CATL==&quot;1&quot;) %&gt;% mutate(nb_pieces=as.numeric(as.character(NBPI)), nb_pers=as.numeric(as.character(INPER)), np_pieces_pers=nb_pieces/nb_pers, Anciennete=case_when(ANEMR==&quot;00&quot; ~ &quot;Depuis moins de 2 ans&quot;, ANEMR==&quot;01&quot; ~ &quot;De 2 à 4 ans&quot;, ANEMR==&quot;02&quot; ~ &quot;De 5 à 9 ans&quot;, as.numeric(ANEMR)&gt;3 ~ &quot;10 ans ou plus&quot;), Anciennete = factor(Anciennete, levels=c(&quot;Depuis moins de 2 ans&quot;,&quot;De 2 à 4 ans&quot;,&quot;De 5 à 9 ans&quot;,&quot;10 ans ou plus&quot;))) %&gt;% group_by(Anciennete) %&gt;% summarise(Moy_pieces_pers=weighted.mean(np_pieces_pers, IPONDI, na.rm=T)) %&gt;% bind_rows(summarise(Anciennete = &quot;Ensemble&quot;, RP[RP$CATL==&quot;1&quot;, ], Moy_pieces_pers=weighted.mean(as.numeric(as.character(NBPI))/as.numeric(as.character(INPER)), IPONDI, na.rm=T))) %&gt;% mutate(Moy_pieces_pers=round(Moy_pieces_pers, 1)) %&gt;% kable(format.args = list(big.mark = &quot; &quot;)) `summarise()` ungrouping output (override with `.groups` argument) Anciennete Moy_pieces_pers Depuis moins de 2 ans 1.2 De 2 à 4 ans 1.2 De 5 à 9 ans 1.2 10 ans ou plus 1.6 Ensemble 1.4 C’est néanmoins plutôt du côté des graphiques que R excelle en la matière, avec le fameux package ggplot. On va maintenant essayer de travailler ce package avec ses différentes fonctions. Si besoin, pour vous aider à démarrer avec ggplot, 2 liens utiles : ici et là. Dans la continuité des statistiques réalisées précédemment, troisième exercice à faire : réalisez d’abord un graphique représentant l’ancienneté d’emménagement des ménages dans le Val de Marne en 2017, selon 6 catégories (“Depuis moins de 2 ans”, “De 2 à 4 ans”, “De 5 à 9 ans”, “De 10 à 19 ans”, “De 20 à 29 ans”, “30 ans ou plus”) et en pourcentage. On peut repartir du 1er code précédent en ajoutant des catégories, puis en utilisant un ggplot(). # 2 exemples : #Avec geom_col() qui crée un diagramme à barres ou graphique en colonnes RP %&gt;% filter(LPRM==&quot;1&quot; &amp; CATL==&quot;1&quot;) %&gt;% mutate(anc=case_when(ANEMR==&quot;00&quot; ~ &quot;Depuis moins de 2 ans&quot;, ANEMR==&quot;01&quot; ~ &quot;De 2 à 4 ans&quot;, ANEMR==&quot;02&quot; ~ &quot;De 5 à 9 ans&quot;, ANEMR==&quot;03&quot; ~ &quot;De 10 à 19 ans&quot;, ANEMR==&quot;04&quot; ~ &quot;De 20 à 29 ans&quot;, as.numeric(ANEMR)&gt;=5 ~ &quot;30 ans ou plus&quot;), anc = factor(anc, levels=c(&quot;Depuis moins de 2 ans&quot;, &quot;De 2 à 4 ans&quot;, &quot;De 5 à 9 ans&quot;, &quot;De 10 à 19 ans&quot;, &quot;De 20 à 29 ans&quot;, &quot;30 ans ou plus&quot;))) %&gt;% count(anc, wt=IPONDI) %&gt;% mutate(pct=prop.table(n)*100, pct=round(pct, 1)) %&gt;% ggplot() + aes(x=anc, y=pct, fill=anc) + geom_col() + scale_fill_brewer(palette = &quot;Set2&quot;) + geom_text(aes(y=pct, label=pct), vjust=1.5, color=&quot;gray30&quot;, size=4) + labs(title = &quot;Ancienneté d&#39;emménagement des ménages en 2017 dans le Val de Marne&quot;, x=&quot;&quot;, y=&quot;&quot;) + theme_bw() + theme(legend.position = &quot;none&quot;) #Ou avec geom_bar(), mais en mettant l&#39;option &quot; stat=&quot;identity&quot; &quot; car on donne déjà les valeurs avec y=pct RP %&gt;% filter(LPRM==&quot;1&quot; &amp; CATL==&quot;1&quot;) %&gt;% mutate(anc=case_when(ANEMR==&quot;00&quot; ~ &quot;Depuis moins de 2 ans&quot;, ANEMR==&quot;01&quot; ~ &quot;De 2 à 4 ans&quot;, ANEMR==&quot;02&quot; ~ &quot;De 5 à 9 ans&quot;, ANEMR==&quot;03&quot; ~ &quot;De 10 à 19 ans&quot;, ANEMR==&quot;04&quot; ~ &quot;De 20 à 29 ans&quot;, as.numeric(ANEMR)&gt;=5 ~ &quot;30 ans ou plus&quot;), anc = factor(anc, levels=c(&quot;Depuis moins de 2 ans&quot;, &quot;De 2 à 4 ans&quot;, &quot;De 5 à 9 ans&quot;, &quot;De 10 à 19 ans&quot;, &quot;De 20 à 29 ans&quot;, &quot;30 ans ou plus&quot;))) %&gt;% count(anc, wt=IPONDI) %&gt;% mutate(pct=prop.table(n)*100, pct=round(pct, 1)) %&gt;% ggplot() + aes(x=anc, y=pct, fill=anc) + geom_bar(stat=&quot;identity&quot;) + scale_fill_brewer(palette = &quot;Dark2&quot;) + geom_text(aes(y=pct, label=pct), vjust=1.5, color=&quot;gray22&quot;, size=4) + labs(title = &quot;Ancienneté d&#39;emménagement des ménages en 2017 dans le Val de Marne&quot;, x=&quot;&quot;, y=&quot;&quot;) + theme(legend.position = &quot;none&quot;) Réalisez ensuite un graphique de la distribution du nombre de pièces par type de logement en ne considérant que les maisons et appartements. Par exemple, cela pourrait donner cela : RP %&gt;% filter(LPRM==&quot;1&quot; &amp; TYPL %in% c(&quot;1&quot;, &quot;2&quot;)) %&gt;% mutate(nb_pieces=as.numeric(as.character(NBPI)), TYPL=recode(TYPL, &quot;1&quot;=&quot;Maison&quot;, &quot;2&quot;=&quot;Appartement&quot;)) %&gt;% ggplot() + aes(x=nb_pieces, y=TYPL, fill=TYPL) + geom_boxplot(outlier.shape = NA) + coord_flip() + stat_summary(fun=mean, geom=&quot;point&quot;, shape=20, size=4) + scale_x_continuous(limits = c(1, 8)) + labs(title=&quot;Nombre de pièces par ménage selon le type de logement en 2017&quot;, x=&quot;Nombre de pièces&quot;, y=&quot;Type de logement&quot;) + theme(legend.position = &quot;none&quot;) 2.3 Quelles caractéristiques des individus résidant dans le Val de Marne en 2017 ? On va s’intéresser maintenant aux caractéristiques des individus qui résident dans ce département du Val de Marne. On peut ainsi décrire la population selon les variables suivantes : l’âge, le sexe, la situation quant à l’immigration, le diplôme, la catégorie sociale, le type d’activité ou encore les conditions d’emploi. Premier exercice à faire : faire un graphique décrivant la population de 15 ans ou plus selon la catégorie socioprofessionnelle (CS). Puis un second, différenciant la population par sexe, en plus de la CS (vous pourrez enlever les agriculteurs peu nombreux). #Population de 15 ans ou plus selon la catégorie socioprofessionnelle (et sans les agriculteurs trop peu nombreux) RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT!=&quot;23&quot; &amp; CS1!=&quot;1&quot;) %&gt;% count(CS1, wt=IPONDI) %&gt;% mutate(pct=prop.table(n)*100, pct=round(pct, 1), CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;)) %&gt;% ggplot() + aes(x=CS1, y=pct, fill=CS1) + geom_col() + scale_fill_brewer(palette = &quot;Set2&quot;) + geom_text(aes(y=pct, label=pct), vjust=1.5, color=&quot;gray30&quot;, size=4) + labs(title = &quot;Population de 15 ans ou plus selon la catégorie socioprofessionnelle&quot;, x=&quot;&quot;, y=&quot;&quot;) + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 75, hjust=1)) #Population de 15 ans ou plus par sexe et catégorie socioprofessionnelle (et sans les agriculteurs trop peu nombreux) RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT!=&quot;23&quot; &amp; CS1!=&quot;1&quot;) %&gt;% group_by(SEXE) %&gt;% count(CS1, wt=IPONDI) %&gt;% mutate(pct=prop.table(n)*100, pct=round(pct, 1), CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;), SEXE=recode(SEXE, &quot;1&quot;=&quot;Homme&quot;, &quot;2&quot;=&quot;Femme&quot;)) %&gt;% ggplot() + aes(x=CS1, y=pct, fill=CS1) + geom_bar(stat=&quot;identity&quot;)+ facet_wrap(~SEXE,nrow=1, ncol=2) + scale_fill_brewer(palette = &quot;Set2&quot;) + geom_text(aes(y=pct, label=pct), vjust=1, color=&quot;gray23&quot;, size=3.5) + labs(title = &quot;Population de 15 ans ou plus par sexe et catégorie socioprofessionnelle&quot;, x=&quot;&quot;, y=&quot;&quot;) + theme_grey() + theme(axis.text.x=element_blank(), axis.ticks.x=element_blank(), legend.position=&quot;bottom&quot;, legend.title = element_blank(), plot.title = element_text(hjust = 0.5)) On peut dorénavant s’intéresser aux personnes en emploi, second exercice à faire : faîtes un graphique représentant la population de 15 ans ou plus en emploi par statut (salariés/non-salariés), sexe et catégorie socioprofessionnelle (en enlevant de nouveau les agriculteurs) RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT==&quot;11&quot; &amp; CS1!=&quot;1&quot;) %&gt;% mutate(EMPL=case_when(EMPL %in% c(&quot;11&quot;,&quot;12&quot;,&quot;13&quot;,&quot;14&quot;,&quot;15&quot;,&quot;16&quot;) ~ &quot;Salariés&quot;, EMPL %in% c(&quot;21&quot;,&quot;22&quot;,&quot;23&quot;) ~ &quot;Non Salariés&quot;), CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;), SEXE=recode(SEXE, &quot;1&quot;=&quot;Homme&quot;, &quot;2&quot;=&quot;Femme&quot;)) %&gt;% group_by(SEXE, EMPL) %&gt;% count(CS1, wt=IPONDI) %&gt;% mutate(pct=prop.table(n)*100, pct=round(pct, 1)) %&gt;% ggplot() + aes(x =SEXE, y=pct, fill = CS1) + geom_bar(stat=&quot;identity&quot;) + facet_wrap(~EMPL, nrow=1, ncol=2) + scale_fill_brewer(palette = &quot;Set2&quot;) + geom_text(aes(label = after_stat(y)), color=&quot;gray24&quot;, position = position_stack(.5)) + labs(title = &quot;Population de 15 ans ou plus en emploi par statut, sexe et catégorie socioprofessionnelle&quot;, x=&quot;&quot;, y=&quot;&quot;, fill=&quot;Catégorie socio-professionnelle&quot;) + theme_grey() + theme(legend.position=&quot;right&quot;) 2.4 La création de fonctions Et oui, le copier-coller c’est bien et simple, mais voilà pour ré-utiliser un code de façon plus automatique, créer des fonctions est très utile (et on peut même les stocker dans un fichier .r pour les réutiliser plus tard pour une autre étude). L’idée est qu’à partir d’un bloc d’instructions ou de lignes de code, on l’intègre dans une fonction qui portera un nom et qui pourra être appliquée sur les paramètres que l’on veut (table/objet différent, ici communes différentes, variables différentes) et qui nous retournera une valeur en sortie (qu’il faut préciser donc). Par exemple : #Les &quot;...&quot; seront des instructions bien sûr ! nom_fonction &lt;- function(data, var) { tab &lt;- data %&gt;% ... %&gt;% ... return(tab) } #L&#39;appel de la fonction devra ainsi préciser la table de données sur laquelle l&#39;appliquer et les autres arguments : nom_fonction(data = nom_de_ma_table , var = nom_de_ma_variable) #De plus, on pourra créer un nouvel objet (ici &quot;tab_var&quot;) pour stocker la table qui est en valeur de sortie de la fonction : tab_var &lt;- nom_fonction(data = nom_de_ma_table , var = nom_de_ma_variable) 2.4.1 Création d’une fonction pour retourner un tableau Alors, reprenons notre code précédent (ci-dessous), et essayons d’écrire une fonction pour faire des sorties de tableaux, de sorte qu’il suffise d’appeler cette fonction en indiquant le nom de notre table, de notre commune et de notre variable. On n’exécute pas de nouveau ce code, mais on l’affiche seulement sur notre script : pour cela il faut, dans le chunk, mettre l’option eval=FALSE comme ceci : {r eval=FALSE}. #Rappel exemple code précédent (avec ajout de la commune prise en référence - Sucy-en-Brie) : RP %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(LPRM==&quot;1&quot; &amp; COM == &quot;94071&quot;) %&gt;% mutate(Nb_voiture=case_when(VOIT==&quot;1&quot; ~ &quot;1 voiture&quot;, VOIT %in% c(&quot;2&quot;, &quot;3&quot;) ~ &quot;2 voitures ou plus&quot;, VOIT==&quot;0&quot; ~ &quot;Pas de voiture&quot;)) %&gt;% count(Nb_voiture, wt=IPONDI) %&gt;% mutate(n=round(n,0),pct=prop.table(n)*100, pct=round(pct, 1)) On crée donc une fonction qu’on appelle tab_menage avec comme paramètres “data”, “codecom” et “var” qui s’appliquerait dans le cas de statistiques au niveau “ménages” : tab_menage &lt;- function(data, codecom, var) { tab &lt;- data %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(LPRM==&quot;1&quot; &amp; COM == codecom) %&gt;% count({{ var }}, wt=IPONDI) %&gt;% mutate(n=round(n,0), pct=prop.table(n)*100, pct=round(pct, 1)) return(tab) } Le plus difficile ici est l’appel de la variable dans la fonction notamment lorsqu’on utilise le langage dplyr : une méthode (mais il en existe une autre, cf. ici) est d’utiliser les {{ }}. En outre, il ne faut pas oublier de préciser la valeur de sortie avec return(). En revanche, si l’on veut recoder la variable soit en regroupant des modalités, soit en renommant les modalités (ou les 2 !), il faudra le faire dans une étape préalable. De manière générale, il est bien comme on l’a vu dans les 2 premières séances de ce ciyrs (cf. script de cours associé) de prendre le temps de bien préparer la table, recoder toutes les variables comme on le souhaite, inspecter et traiter les valeurs manquantes, etc., avant l’étape de l’analyse statistique des données. Ainsi, si l’on reprend l’exemple des trois premiers tableaux que nous avons réalisés lors de la dernière séance (cf. plus haut), on peut le refaire en 2 étapes : préparation de la table, et appel des fonctions. (On peut aussi intégrer la fonction dans un code dplyr en ajoutant un %&gt;%, dans ce cas il faut enlever le paramètre “data =” dans la fonction lorsqu’on l’appelle, cf. après.) # Etape 1 : création d&#39;une nouvelle table (ou en remplacement si on l&#39;appelle de la même façon) RP &lt;- RP %&gt;% mutate(Stationnement = recode(GARL, &quot;1&quot; = &quot;Au moins un emplacement réservé au stationnement&quot;, &quot;2&quot; = &quot;Aucun emplacement&quot;), Voiture = case_when(VOIT %in% c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;) ~ &quot;Au moins une voiture&quot;, VOIT == &quot;0&quot; ~ &quot;Pas de voiture&quot;), Nb_voiture = case_when(VOIT == &quot;1&quot; ~ &quot;1 voiture&quot;, VOIT %in% c(&quot;2&quot;, &quot;3&quot;) ~ &quot;2 voitures ou plus&quot;, VOIT == &quot;0&quot; ~ &quot;Pas de voiture&quot;)) #Etape 2 : création des tableaux, soit en sortie dans la console (1er cas), soit en nouvel objet R (cas suivants) tab_menage(data = RP, codecom = &quot;94071&quot;, var = Stationnement) # A tibble: 2 x 3 Stationnement n pct &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Au moins un emplacement réservé au stationnement 7432 69.4 2 Aucun emplacement 3284 30.6 tab_voit &lt;- tab_menage(data = RP, codecom = &quot;94071&quot;, var = Voiture) tab_nbvoit &lt;- tab_menage(data = RP, codecom = &quot;94071&quot;, var = Nb_voiture) #Visualisation des 2 tables créées tab_voit # A tibble: 2 x 3 Voiture n pct &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Au moins une voiture 9011 84.1 2 Pas de voiture 1705 15.9 tab_nbvoit # A tibble: 3 x 3 Nb_voiture n pct &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 voiture 5399 50.4 2 2 voitures ou plus 3611 33.7 3 Pas de voiture 1705 15.9 On peut créer une même fonction pour réaliser des statistiques cette fois au niveau individus, il suffit de supprimer le 1er filtre avec la variable LPRM(). tab_indiv &lt;- function(data, codecom, var) { tab &lt;- data %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(COM == codecom) %&gt;% count({{ var }}, wt=IPONDI) %&gt;% mutate(n=round(n,0), pct=prop.table(n)*100, pct=round(pct, 1)) return(tab) } Exemple, avec la variable CS de catégorie socio-professionnelle #Pour être pertinent, table restreinte à la population de 15 ans ou plus (sans les agriculteurs non plus, trop peu nobmreux) : RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT!=&quot;23&quot; &amp; CS1!=&quot;1&quot;) %&gt;% mutate(CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;)) %&gt;% tab_indiv(codecom = &quot;94071&quot;, var = CS1) # A tibble: 7 x 3 CS1 n pct &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Artisans, commerçants et chefs d&#39;entreprise 713 3.3 2 Cadres et professions intellectuelles supérieures 3487 16.1 3 Professions Intermédiaires 3317 15.3 4 Employés 3244 14.9 5 Ouvriers 1691 7.8 6 Retraités 5610 25.8 7 Autres personnes sans activité professionnelle 3644 16.8 Et si on cherchait à n’avoir qu’une fonction à appliquer, que nos statistiques ensuite soient au niveau ménages ou au niveau individus ? tab_var &lt;- function(data, codecom, list_mod, var) { tab &lt;- data %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(LPRM %in% list_mod &amp; COM == codecom) %&gt;% count({{ var }}, wt=IPONDI) %&gt;% mutate(n=round(n,0), pct=prop.table(n)*100, pct=round(pct, 1)) return(tab) } Ce qui donnerait pour le niveau ménage l’appel de la fonction : tab_var(data = RP, codecom = &quot;94071&quot;, list_mod=c(&quot;1&quot;), var = Nb_voiture) # A tibble: 3 x 3 Nb_voiture n pct &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 voiture 5399 50.4 2 2 voitures ou plus 3611 33.7 3 Pas de voiture 1705 15.9 Et pour l’ensemble des individus : RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT!=&quot;23&quot; &amp; CS1!=&quot;1&quot;) %&gt;% mutate(CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;)) %&gt;% tab_var(codecom = &quot;94071&quot;, list_mod=c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;Z&quot;), var = CS1) # A tibble: 7 x 3 CS1 n pct &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Artisans, commerçants et chefs d&#39;entreprise 713 3.3 2 Cadres et professions intellectuelles supérieures 3487 16.1 3 Professions Intermédiaires 3317 15.3 4 Employés 3244 14.9 5 Ouvriers 1691 7.8 6 Retraités 5610 25.8 7 Autres personnes sans activité professionnelle 3644 16.8 C’est un peu fastidieux ici de rentrer toutes les modalités de la variable LPRM. Une solution rapide est de créer une nouvelle variable à partir de LPRM qu’on appelerait LPRM_1 qui n’ait que 2 modalités, ce qui peut être fait idéalement dans l’étape initiale de préparation des données (sinon comme ci-dessous) ! tab_var &lt;- function(data, codecom, list_mod, var) { tab &lt;- data %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(LPRM_1 %in% list_mod &amp; COM == codecom) %&gt;% count({{ var }}, wt=IPONDI) %&gt;% mutate(n=round(n,0), pct=prop.table(n)*100, pct=round(pct, 1)) return(tab) } # Appliquée sur le même exemple que précédemment : RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT!=&quot;23&quot; &amp; CS1!=&quot;1&quot;) %&gt;% mutate(CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;), LPRM_1 = case_when(LPRM == &quot;1&quot; ~ &quot;1&quot;, TRUE ~ &quot;0&quot;)) %&gt;% tab_var(codecom = &quot;94071&quot;, list_mod=c(&quot;1&quot;, &quot;0&quot;), var = CS1) # A tibble: 7 x 3 CS1 n pct &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Artisans, commerçants et chefs d&#39;entreprise 713 3.3 2 Cadres et professions intellectuelles supérieures 3487 16.1 3 Professions Intermédiaires 3317 15.3 4 Employés 3244 14.9 5 Ouvriers 1691 7.8 6 Retraités 5610 25.8 7 Autres personnes sans activité professionnelle 3644 16.8 2.4.2 Création d’une fonction pour retourner un graphique Maintenant, créons, de la même façon, une fonction qui retourne en valeur de sortie un graphique, comme ceux que l’on a construit plus haut. On peut dans un premier temps, partir du principe que l’on appelera d’abord notre fonction tab_var() pour créer le tableau en sortie, à partir duquel on appliquera la fonction du graphe. Pour rappel, voici le code initialement utilisé pour créer un graphique représentant la population de 15 ans ou plus selon la catégorie socioprofessionnelle dans notre commune de référence (de nouveau, on ne l’exécute pas ici, et on spécifie eval=FALSE). #Population de 15 ans ou plus selon la catégorie socioprofessionnelle (sans les agriculteurs ; et avec ajout de la commune prise en référence - Sucy-en-Brie) RP %&gt;% mutate(COM = substr(IRIS, 1, 5)) %&gt;% filter(COM == &quot;94071&quot; &amp; !AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT!=&quot;23&quot; &amp; CS1!=&quot;1&quot;) %&gt;% count(CS1, wt=IPONDI) %&gt;% mutate(pct=prop.table(n)*100, pct=round(pct, 1), CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;)) %&gt;% ggplot() + aes(x=CS1, y=pct, fill=CS1) + geom_col() + scale_fill_brewer(palette = &quot;Set2&quot;) + geom_text(aes(y=pct, label=pct), vjust=1.4, color=&quot;gray30&quot;, size=3.5) + labs(title = &quot;Population de 15 ans ou plus selon la catégorie socioprofessionnelle&quot;, x=&quot;&quot;, y=&quot;&quot;) + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 75, hjust=1)) On s’intéresse donc aux dernières lignes de codes pour créer notre fonction qu’on appelera par exemple graph_baton, en considérant qu’on aura avant un tableau avec 3 colonnes : la variable, le nombre “n” et le pourcentage “pct”. On peut donc réutiliser certains de ces noms de variables dans la fonction, ou se laisser la possibilité de l’indiquer dans les paramètres de la fonction (les lignes de codes suivantes ne sont pas exécutées, de nouveau l’option {r eval=FALSE} est ici inscrite dans le script Markdown). # On peut proposer une première écriture avec &quot;pct&quot; comme variable indiquée pour &quot;y=&quot; car ici c&#39;est le pourcentage qu&#39;on reprend, et dans nos tableaux il portera toujours le nom de &quot;pct&quot; : graph_baton &lt;- function(data, var_x, nom_titre) { graph &lt;- data %&gt;% ggplot() + aes(x = {{ var_x }}, y = pct, fill = {{ var_x }}) + geom_col() + scale_fill_brewer(palette = &quot;Set2&quot;) + geom_text(aes(y = pct, label = pct), vjust=1.4, color=&quot;gray30&quot;, size=3.5) + labs(title = nom_titre, x=&quot;&quot;, y=&quot;&quot;) + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 75, hjust=1)) return(graph) } # Mais si on veut se laisser la possibilité de ne pas forcément mettre le pourcentage mais aussi les effectifs... alors il vaut mieux indiquer un nouveau paramètre que l&#39;on aura à &quot;remplir&quot; en appelant la fonction : graph_baton &lt;- function(data, var_x, var_y, nom_titre) { graph &lt;- data %&gt;% ggplot() + aes(x = {{ var_x }}, y = {{ var_y }}, fill = {{ var_x }}) + geom_col() + scale_fill_brewer(palette = &quot;Set2&quot;) + geom_text(aes(y = {{ var_y }}, label = {{ var_y }}), vjust=1.4, color=&quot;gray30&quot;, size=3.5) + labs(title = nom_titre, x=&quot;&quot;, y=&quot;&quot;) + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 75, hjust=1)) return(graph) } #On avait vu qu&#39;on pouvait également utiliser la fonction `geom_bar()` en mettant l&#39;option &quot;(stat=&quot;identity&quot;)&quot; à la place de `geom_col()`, c&#39;est ce que nous allons privilégier ensuite : graph_baton &lt;- function(data, var_x, var_y, nom_titre) { graph &lt;- data %&gt;% ggplot() + aes(x = {{ var_x }}, y = {{ var_y }}, fill = {{ var_x }}) + geom_bar(stat=&quot;identity&quot;) + scale_fill_brewer(palette = &quot;Set2&quot;) + geom_text(aes(y = {{ var_y }}, label = {{ var_y }}), vjust=1.4, color=&quot;gray30&quot;, size=3.5) + labs(title = nom_titre, x=&quot;&quot;, y=&quot;&quot;) + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 75, hjust=1)) return(graph) } Essayons de l’appliquer en lien avec le code initial : graph_baton &lt;- function(data, var_x, var_y, nom_titre) { graph &lt;- data %&gt;% ggplot() + aes(x = {{ var_x }}, y = {{ var_y }}, fill = {{ var_x }}) + geom_bar(stat=&quot;identity&quot;) + scale_fill_brewer(palette = &quot;Set2&quot;) + geom_text(aes(y = {{ var_y }}, label = {{ var_y }}), vjust=1.4, color=&quot;gray30&quot;, size=3.5) + labs(title = nom_titre, x=&quot;&quot;, y=&quot;&quot;) + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 75, hjust=1)) return(graph) } #Restreignons là aussi l&#39;analyse aux 15 ans ou plus (sans les agriculteurs de nouveau) tab_CS &lt;- RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT!=&quot;23&quot; &amp; CS1!=&quot;1&quot;) %&gt;% mutate(CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;), LPRM_1 = case_when(LPRM == &quot;1&quot; ~ &quot;1&quot;, TRUE ~ &quot;0&quot;)) %&gt;% tab_var(codecom = &quot;94071&quot;, list_mod=c(&quot;1&quot;, &quot;0&quot;), var = CS1) graph_baton(data = tab_CS, var_x = CS1, var_y = pct, nom_titre =&quot;Population de 15 ans ou plus selon la catégorie socioprofessionnelle&quot;) Si certaines options du graphique ne s’adapteront pas bien pour d’autres variables, il est possible dans la fonction créée d’enlever les lignes de codes comprenant les fonctions geom_text() et theme(), et de les ajouter ensuite au graphe que l’on aura stocké préalablement dans un objet. De même, ici on a voulu “économiser” le nombre de paramètres cités pour le graphe en reprenant le même nom de variables que pour le tableau, mais il sera finalement peut-être plus judicieux de bien distinguer les variables appelées dans le tableau et les variables appelées dans le graphe. On le verra plus loin. 2.4.3 Création d’une seule fonction comprenant tableau et graphe Vous l’avez compris, on peut constamment optimiser son code, y compris ses fonctions. Par exemple ici, au lieu d’appeler la fonction tableau, puis ensuite la fonction graphe, on peut créer une fonction qui renverra le graphique voulu en intégrant l’étape du tableau. On va l’appeler graph_baton1 : #Fonction Graph intégrant la fonction tab graph_baton1 &lt;- function(data, codecom, list_mod, var, var_x, var_y, nom_titre) { tabvar &lt;- tab_var(data = data, codecom = codecom, list_mod, var = {{ var }}) graph &lt;- tabvar %&gt;% ggplot() + aes(x = {{ var_x }}, y = {{ var_y }}, fill = {{ var_x }}) + geom_bar(stat=&quot;identity&quot;) + scale_fill_brewer(palette = &quot;Set2&quot;) + geom_text(aes(y = {{ var_y }}, label = {{ var_y }}), vjust=1.4, color=&quot;gray30&quot;, size=3.5) + labs(title = nom_titre, x=&quot;&quot;, y=&quot;&quot;) + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 75, hjust=1)) return(graph) } RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT!=&quot;23&quot; &amp; CS1!=&quot;1&quot;) %&gt;% mutate(CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;), LPRM_1 = case_when(LPRM == &quot;1&quot; ~ &quot;1&quot;, TRUE ~ &quot;0&quot;)) %&gt;% graph_baton1(codecom = &quot;94071&quot;, list_mod = c(&quot;1&quot;, &quot;0&quot;), var = CS1,var_x=CS1, var_y = pct, nom_titre = &quot;Population de 15 ans ou plus selon la catégorie socioprofessionnelle&quot;) En revanche, vous voyez ici qu’il nous renvoie le seul graphique. Et si on veut aussi le tableau ? Le problème est qu’a priori une fonction ne sait pas renvoyer plusieurs valeurs de sortie. Par conséquent, on est obligés de contourner le problème en utilisant une petite astuce : on crée une liste d’objets. graph_baton2 &lt;- function(data, codecom, list_mod, var, var_x, var_y, nom_titre) { tabvar &lt;- tab_var(data = data, codecom = codecom, list_mod, var = {{ var }}) graph &lt;- tabvar %&gt;% ggplot() + aes(x = {{ var_x }}, y = {{ var_y }}, fill = {{ var_x }}) + geom_bar(stat=&quot;identity&quot;) + scale_fill_brewer(palette = &quot;Set2&quot;) + geom_text(aes(y = {{ var_y }}, label = {{ var_y }}), vjust=1.4, color=&quot;gray30&quot;, size=3.5) + labs(title = nom_titre, x=&quot;&quot;, y=&quot;&quot;) + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 75, hjust=1)) return(list(tabvar, graph)) } RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT!=&quot;23&quot; &amp; CS1!=&quot;1&quot;) %&gt;% mutate(CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;), LPRM_1 = case_when(LPRM == &quot;1&quot; ~ &quot;1&quot;, TRUE ~ &quot;0&quot;)) %&gt;% graph_baton2(codecom = &quot;94071&quot;, list_mod = c(&quot;1&quot;, &quot;0&quot;), var = CS1, var_x=CS1, var_y = pct, nom_titre = &quot;Population de 15 ans ou plus selon la catégorie socioprofessionnelle&quot;) [[1]] CS1 n pct 1 Artisans, commerçants et chefs d&#39;entreprise 713 3.3 2 Cadres et professions intellectuelles supérieures 3487 16.1 3 Professions Intermédiaires 3317 15.3 4 Employés 3244 14.9 5 Ouvriers 1691 7.8 6 Retraités 5610 25.8 7 Autres personnes sans activité professionnelle 3644 16.8 [[2]] 2.4.4 Et pour distinguer par groupe ? Et pour avoir des moyennes… ? Et si on veut représenter la population par catégorie socio-professionnelle en distinguant par sexe, comme précédemment ? Il faut rajouter la fonction group_by(), mais en faisant en sorte qu’on ne sache pas d’une part quelle variable on va mettre, ni combien de variables on va mettre, et d’autre part on pourrait se laisser le choix de ne pas en mettre du tout. On peut repartir de notre fonction tab_var, pour rappel ci-dessous (non-exécutée) : tab_var &lt;- function(data, codecom, list_mod, var) { tab &lt;- data %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(LPRM_1 %in% list_mod &amp; COM == codecom) %&gt;% count({{ var }}, wt=IPONDI) %&gt;% mutate(n=round(n,0), pct=prop.table(n)*100, pct=round(pct, 1)) return(tab) } Procédons par étapes : on lui ajoute la fonction group_by() qui nous permettrait de distinguer selon une seule autre variable : tab_var1 &lt;- function(data, codecom, list_mod, var, var2) { tab &lt;- data %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(LPRM_1 %in% list_mod &amp; COM == codecom) %&gt;% group_by({{ var2 }}) %&gt;% count({{ var }}, wt=IPONDI) %&gt;% mutate(n=round(n,0), pct=prop.table(n)*100, pct=round(pct, 1)) return(tab) } RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT!=&quot;23&quot; &amp; CS1!=&quot;1&quot;) %&gt;% mutate(SEXE=recode(SEXE, &quot;1&quot;=&quot;Homme&quot;, &quot;2&quot;=&quot;Femme&quot;), CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;), LPRM_1 = case_when(LPRM == &quot;1&quot; ~ &quot;1&quot;, TRUE ~ &quot;0&quot;)) %&gt;% tab_var1(codecom=&quot;94071&quot;, list_mod=c(&quot;1&quot;, &quot;0&quot;), var=CS1, var2=SEXE) # A tibble: 14 x 4 SEXE CS1 n pct &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Homme Artisans, commerçants et chefs d&#39;entreprise 516 5 2 Homme Cadres et professions intellectuelles supérieures 2018 19.7 3 Homme Professions Intermédiaires 1409 13.8 4 Homme Employés 857 8.4 5 Homme Ouvriers 1407 13.8 6 Homme Retraités 2466 24.1 7 Homme Autres personnes sans activité professionnelle 1555 15.2 8 Femme Artisans, commerçants et chefs d&#39;entreprise 197 1.7 9 Femme Cadres et professions intellectuelles supérieures 1469 12.8 10 Femme Professions Intermédiaires 1908 16.6 11 Femme Employés 2387 20.8 12 Femme Ouvriers 284 2.5 13 Femme Retraités 3143 27.4 14 Femme Autres personnes sans activité professionnelle 2089 18.2 Mais on voudrait pouvoir éventuellement distinguer selon plusieurs variables, par IRIS et sexe par exemple, ou tout autre chose ; et puis on voudrait aussi pendant qu’on y est n’avoir qu’une seule fonction tab_var pour avoir un tableau selon une seule variable ou selon plusieurs autres variables. Pour laisser à la fonction la possibilité d’appeler plusieurs paramètres (ou aucun !), il faut utiliser les “…”, que l’on va ici mettre dans la fonction group_by(...). tab_var &lt;- function(data, codecom, list_mod, var, ...) { tab &lt;- data %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(LPRM_1 %in% list_mod &amp; COM == codecom) %&gt;% group_by(...) %&gt;% count({{ var }}, wt=IPONDI) %&gt;% mutate(n=round(n,0), pct=prop.table(n)*100, pct=round(pct, 1)) return(tab) } #Ici, je crée un nouvel objet, pour pouvoir lancer les 2 fonctions de test à la suite RP_stats &lt;- RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT!=&quot;23&quot; &amp; CS1!=&quot;1&quot;) %&gt;% mutate(SEXE=recode(SEXE, &quot;1&quot;=&quot;Homme&quot;, &quot;2&quot;=&quot;Femme&quot;), CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;), LPRM_1 = case_when(LPRM == &quot;1&quot; ~ &quot;1&quot;, TRUE ~ &quot;0&quot;)) tab_var(data=RP_stats, codecom=&quot;94071&quot;, list_mod=c(&quot;1&quot;, &quot;0&quot;), var=CS1) # A tibble: 7 x 3 CS1 n pct &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Artisans, commerçants et chefs d&#39;entreprise 713 3.3 2 Cadres et professions intellectuelles supérieures 3487 16.1 3 Professions Intermédiaires 3317 15.3 4 Employés 3244 14.9 5 Ouvriers 1691 7.8 6 Retraités 5610 25.8 7 Autres personnes sans activité professionnelle 3644 16.8 tab_var(data=RP_stats, codecom=&quot;94071&quot;, list_mod=c(&quot;1&quot;, &quot;0&quot;), var=CS1, SEXE) # A tibble: 14 x 4 SEXE CS1 n pct &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Homme Artisans, commerçants et chefs d&#39;entreprise 516 5 2 Homme Cadres et professions intellectuelles supérieures 2018 19.7 3 Homme Professions Intermédiaires 1409 13.8 4 Homme Employés 857 8.4 5 Homme Ouvriers 1407 13.8 6 Homme Retraités 2466 24.1 7 Homme Autres personnes sans activité professionnelle 1555 15.2 8 Femme Artisans, commerçants et chefs d&#39;entreprise 197 1.7 9 Femme Cadres et professions intellectuelles supérieures 1469 12.8 10 Femme Professions Intermédiaires 1908 16.6 11 Femme Employés 2387 20.8 12 Femme Ouvriers 284 2.5 13 Femme Retraités 3143 27.4 14 Femme Autres personnes sans activité professionnelle 2089 18.2 Et on peut réécrire ainsi notre fonction graph_baton1() pour intégrer cette nouvelle version de notre fonction tabvar() ! graph_baton1 &lt;- function(data, codecom, list_mod, var, ..., var_x, var_y, nom_titre) { tabvar &lt;- tab_var(data = data, codecom = codecom, list_mod, var = {{ var }}, ...) graph &lt;- tabvar %&gt;% ggplot() + aes(x = {{ var_x }}, y = {{ var_y }}, fill = {{ var_x }}) + geom_bar(stat=&quot;identity&quot;) + scale_fill_brewer(palette = &quot;Set2&quot;) + geom_text(aes(y = {{ var_y }}, label = {{ var_y }}), vjust=1.4, color=&quot;gray30&quot;, size=3.5) + labs(title = nom_titre, x=&quot;&quot;, y=&quot;&quot;) + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 75, hjust=1)) return(graph) } Ainsi, pour avoir un graphique similaire à celui de fin de section précédente (qui s’intitulait “Population de 15 ans ou plus par sexe et catégorie socioprofessionnelle”), on y arrive avec ce code, c’est-à-dire en sauvegardant le résultat de notre fonction dans un objet graphe (intitulé ici “gg”) puis en lui ajoutant ensuite la fonction facet_wrap() et la variable qu’on a utilisée dans le group_by() à l’intérieur de la fonction (ici donc le sexe), et en lui spécifiant éventuellement quelques ajouts supplémentaires concernant l’arrière-plan du graphique avec theme() : gg &lt;- RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT!=&quot;23&quot; &amp; CS1!=&quot;1&quot;) %&gt;% mutate(CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;, &quot;7&quot;=&quot;Retraités&quot;, &quot;8&quot;=&quot;Autres personnes sans activité professionnelle&quot;), SEXE=recode(SEXE, &quot;1&quot;=&quot;Homme&quot;, &quot;2&quot;=&quot;Femme&quot;), LPRM_1 = case_when(LPRM == &quot;1&quot; ~ &quot;1&quot;, TRUE ~ &quot;0&quot;)) %&gt;% graph_baton1(codecom= &quot;94071&quot;, list_mod= c(&quot;1&quot;, &quot;0&quot;), var=CS1, SEXE, var_x=CS1, var_y= pct, nom_titre= &quot;Population de 15 ans ou plus par sexe et catégorie socioprofessionnelle&quot;) gg + facet_wrap(~SEXE,nrow=1, ncol=2) + theme_grey() + theme(axis.text.x=element_blank(), axis.ticks.x=element_blank(), legend.position=&quot;bottom&quot;, legend.title = element_blank(), plot.title = element_text(hjust = 0.5)) En réalité, pour une utilisation plus générale, il est sans doute préférable de ne pas indiquer dans la fonction les éléments relatifs ni au theme(), ni à geom_text(), et enfin de distinguer les variables utilisées pour le tableau, et les variables utilisées dans le graphique car dès qu’on sera sur des graphiques plus complexes avec plusieurs variables dans le group_by(), les choses risquent de ne pas fonctionner avec une fonction ne distinguant pas bien l’ensemble des variables. On peut donc finalement, ou en plus, proposer cette fonction, en ajoutant un paramètre “var_z” pour bien distinguer les différentes variables : graph_baton3 &lt;- function(data, codecom, list_mod, var, ..., var_x, var_y, var_z, nom_titre) { tabvar &lt;- tab_var(data = data, codecom = codecom, list_mod, var = {{ var }}, ...) graph &lt;- tabvar %&gt;% ggplot() + aes(x = {{ var_x }}, y = {{ var_y }}, fill = {{ var_z }}) + geom_bar(stat=&quot;identity&quot;) + scale_fill_brewer(palette = &quot;Set2&quot;) + labs(title = nom_titre, x=&quot;&quot;, y=&quot;&quot;) return(graph) } Elle est par exemple utile pour réaliser le graphique en fin de section précédente qui était intitulé : “Population de 15 ans ou plus en emploi par statut, sexe et catégorie socioprofessionnelle”: gg &lt;-RP %&gt;% filter(!AGER20 %in% c(&quot;02&quot;, &quot;05&quot;, &quot;10&quot;, &quot;14&quot;) &amp; TACT==&quot;11&quot; &amp; CS1!=&quot;1&quot;) %&gt;% mutate(EMPL=case_when(EMPL %in% c(&quot;11&quot;,&quot;12&quot;,&quot;13&quot;,&quot;14&quot;,&quot;15&quot;,&quot;16&quot;) ~ &quot;Salariés&quot;, EMPL %in% c(&quot;21&quot;,&quot;22&quot;,&quot;23&quot;) ~ &quot;Non Salariés&quot;), CS1=recode(CS1, &quot;2&quot;=&quot;Artisans, commerçants et chefs d&#39;entreprise&quot;, &quot;3&quot;=&quot;Cadres et professions intellectuelles supérieures&quot;, &quot;4&quot;=&quot;Professions Intermédiaires&quot;, &quot;5&quot;=&quot;Employés&quot;, &quot;6&quot;=&quot;Ouvriers&quot;), SEXE=recode(SEXE, &quot;1&quot;=&quot;Homme&quot;, &quot;2&quot;=&quot;Femme&quot;), LPRM_1 = case_when(LPRM == &quot;1&quot; ~ &quot;1&quot;, TRUE ~ &quot;0&quot;)) %&gt;% graph_baton3(codecom= &quot;94071&quot;, list_mod= c(&quot;1&quot;, &quot;0&quot;), var = CS1, SEXE, EMPL, var_x = SEXE, var_y = pct, var_z = CS1, nom_titre= &quot;Population de 15 ans ou plus en emploi par statut, sexe et catégorie socioprofessionnelle&quot;) gg + facet_wrap(~EMPL, nrow=1, ncol=2) + geom_text(aes(label = after_stat(y)), color=&quot;gray24&quot;, position = position_stack(.5), size=3.5) + labs(fill=&quot;Catégorie socio-professionnelle&quot;) + theme(legend.position=&quot;right&quot;) Enfin, on peut vouloir créer une fonction pour réaliser des statistiques sur des variables quantitatives, comme on le fait avec la fonction summarise(). On avait par exemple calculé, plus haut, le nombre moyen de pièces par logement selon l’ancienneté d’emménagement du ménage. On peut prendre exemple sur le code de notre fonction tabvar() et intégrer la fonction summarise() au lieu de count() ; et ajouter un paramètre pour expliciter le nom que l’on souhaite donner à la variable de sortie (la moyenne ici), avec les {{ }} comme pour la variable (paramètre “nom_var” ici donc). mean_var &lt;- function(data, codecom,list_mod, var, ..., nom_var) { var_mean &lt;- data %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(LPRM_1 %in% list_mod &amp; COM == codecom) %&gt;% group_by(...) %&gt;% summarise({{ nom_var }} = weighted.mean({{ var }}, IPONDI, na.rm=T)) return(var_mean) } Mais si vous exécutez ce code, cela devrait vous mettre un message d’erreur en rouge : “Erreur : ‘=’ inattendu(e) in: \"group_by(…) %&gt;% summarise({{ nom }} =\"”. Et oui, ça ne fonctionne pas car la fonction summarise() ne comprend pas le paramètre “nom_var”, il faut en fait mettre avant weighted.mean() un := et non un simple = ! mean_var &lt;- function(data, codecom,list_mod, var, ..., nom_var) { var_mean &lt;- data %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(LPRM_1 %in% list_mod &amp; COM == codecom) %&gt;% group_by(...) %&gt;% summarise({{ nom_var }} := weighted.mean({{ var }}, IPONDI, na.rm=T)) return(var_mean) } On la teste : # Nombre moyen de pièces par logement, pour notre commune de référence Sucy-en-Brie RP %&gt;% mutate(Np_pieces=as.numeric(as.character(NBPI), na.rm=TRUE), LPRM_1 = case_when(LPRM == &quot;1&quot; ~ &quot;1&quot;, TRUE ~ &quot;0&quot;)) %&gt;% mean_var(codecom =&quot;94071&quot;, list_mod=c(&quot;1&quot;), var=Np_pieces, nom_var=Nbmoy_pieces) # A tibble: 1 x 1 Nbmoy_pieces &lt;dbl&gt; 1 4.09 # Nombre moyen de pièces par logement selon l&#39;ancienneté d&#39;emménagement du ménage, toujours pour notre commune de référence Sucy-en-Brie RP %&gt;% mutate(Anciennete=case_when(ANEMR==&quot;00&quot; ~ &quot;Depuis moins de 2 ans&quot;, ANEMR==&quot;01&quot; ~ &quot;De 2 à 4 ans&quot;, ANEMR==&quot;02&quot; ~ &quot;De 5 à 9 ans&quot;, as.numeric(ANEMR)&gt;3 ~ &quot;10 ans ou plus&quot;), Anciennete = factor(Anciennete, levels=c(&quot;Depuis moins de 2 ans&quot;,&quot;De 2 à 4 ans&quot;,&quot;De 5 à 9 ans&quot;, &quot;10 ans ou plus&quot;)), Np_pieces=as.numeric(as.character(NBPI), na.rm=TRUE), LPRM_1 = case_when(LPRM == &quot;1&quot; ~ &quot;1&quot;, TRUE ~ &quot;0&quot;)) %&gt;% mean_var(codecom =&quot;94071&quot;, list_mod=c(&quot;1&quot;), var=Np_pieces, Anciennete, nom_var=Nbmoy_pieces_anc) `summarise()` ungrouping output (override with `.groups` argument) # A tibble: 4 x 2 Anciennete Nbmoy_pieces_anc &lt;fct&gt; &lt;dbl&gt; 1 Depuis moins de 2 ans 3.27 2 De 2 à 4 ans 3.40 3 De 5 à 9 ans 3.92 4 10 ans ou plus 4.45 On peut également faire une fonction pour avoir une somme et non une moyenne, cela nous servira pour notre analyse de clustering (prochaine séance). sum_var &lt;- function(data, codecom,list_mod, ..., nom_var) { var_sum &lt;- data %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(LPRM_1 %in% list_mod &amp; COM == codecom) %&gt;% group_by(...) %&gt;% summarise({{ nom_var }} := sum(IPONDI)) return(var_sum) } RP %&gt;% mutate(LPRM_1 = case_when(LPRM == &quot;1&quot; ~ &quot;1&quot;, TRUE ~ &quot;0&quot;)) %&gt;% sum_var(codecom = &quot;94071&quot;,list_mod = c(&quot;0&quot;,&quot;1&quot;), IRIS, nom_var = nbhab) `summarise()` ungrouping output (override with `.groups` argument) # A tibble: 11 x 2 IRIS nbhab &lt;fct&gt; &lt;dbl&gt; 1 940710101 2151. 2 940710102 2204. 3 940710103 2843. 4 940710104 2631. 5 940710105 3006. 6 940710106 2368. 7 940710107 2545. 8 940710108 2853. 9 940710109 2528. 10 940710110 1525. 11 940710111 1825. 2.4.5 Enregistrer/Stocker ses fonctions Pour cela, il faut copier le seul code de la fonction ou des fonctions écrites et le(s) mettre dans un script (il faut bien les mettre l’une après l’autre si vous souhaitez en sauvegarder plusieurs dans un même fichier), puis enregistrer ce script. Vous pouvez pour cela créer un nouveau dossier dans votre projet et le nommer “Fonctions”. Ensuite, pour l’appeler il faudra faire appel à la fonction source(). Vous pouvez le mettre en 1ère commande dans un nouveau script. #si j&#39;ai enregistré mes 5 fonctions intitulé dans ce script `tab_var`, `graph_baton1`, `graph_baton3`, `mean_var` et `sum_var` dans un fichier/script &quot;mes_fonctions&quot; dans le dossier &quot;Fonctions&quot; de mon projet, alors je l&#39;appelerai ainsi au début d&#39;un nouveau script si je veux les réutiliser : source(&quot;fonctions/mes_fonctions.R&quot;) "],["21-cartography_V2.html", "Chapitre 3 Cartes statistiques avec mapsf (CG) 3.1 Introduction 3.2 Préparation des données 3.3 Le package mapsf 3.4 Création de fonctions", " Chapitre 3 Cartes statistiques avec mapsf (CG) 3.1 Introduction L’objectif de cette section est d’apprendre à réaliser des cartographies statiques d’indicateurs relatifs aux unités spatiales à différentes échelles à l’aide du package mapsf. de créer des fonctions permetant d’automatiser la tâche de cartographie à l’échelle des communes 3.1.1 Packages utilisés Nous allons nous limiter à un nombre limité de packages dplyr et tidyr: pour la manipulation des tableaux et leur agrégation (inutile de charger l’ensemble du package tidyverse) knitr : pour afficher proprement les tableaux de résultats ggplot2 : pour visualiser les résultats sous formes de graphiques sf : pour manipuler les données cartographiques et les agréger mapsf : pour la réalisation de cartes statiques de qualité imprimables aux formats .pdf ou .doc. Le package mapsf remplace le package cartography dpuis le 1er avril 2021 library(knitr) library(tidyr) library(dplyr) library(ggplot2) library(sf) library(mapsf) 3.2 Préparation des données Avant de réaliser des cartes, nous devons préparer des variables, les analyser sur le plan statistique et enfin effectuer leur jointure avec le fonds de carte pour obtenir un objet de type sf (spatial features) 3.2.1 Chargement des fichiers de référence Nous avons besoin uniquement de trois fichiers Le fichier des individus le fichier des métadonnées relatives aux individus le fonds de carte des IRIS indiv &lt;- readRDS(&quot;data/indiv2017.Rdata&quot;) meta &lt;- readRDS(&quot;data/indiv2017_meta.Rdata&quot;) map &lt;-readRDS(&quot;data/map_iris.Rdata&quot;) 3.2.2 Choix d’un indicateur Nous allons prendre comme exemple l’analyse d’un tableau du nombre d’automobiles par ménage en nous limitant aux ménages ordinaires c’est-à-dire en excluant les personnes habitant dans des logements collectifs (pensionnats, prisons, congrégations religieuses, …) Nous ne conservons que les individus chefs de ménages (LPRM=1) ce qui va logiquement éliminer les individus présents dans les ménages non ordinaires (LPRM=Z) ainsi que tous les membres d’un logement qui ne sont pas chefs de ménages. menag&lt;-indiv %&gt;% filter(LPRM==1) 3.2.3 Création du tableau de contingence Nous souhaitons ventiler les ménages en fonction de leur localisation géographique (IRIS) et de leur nombre d’automobile (VOIT) en tenant compte de leur poids (IPONDI) puisque les données sont issues d’uin échantillonage qu’il faut redresser. Cette opération se réalise très facilement à l’aide du package dplyr à l’aide des fonctions group_by, mutate et summarize : tab &lt;- menag %&gt;% group_by(IRIS, VOIT) %&gt;% summarise(nbmen = sum(IPONDI)) %&gt;% ungroup() `summarise()` regrouping output by &#39;IRIS&#39; (override with `.groups` argument) str(tab) tibble [2,070 × 3] (S3: tbl_df/tbl/data.frame) $ IRIS : Factor w/ 4243 levels &quot;751010101&quot;,&quot;751010102&quot;,..: 3300 3300 3300 3300 3301 3301 3301 3301 3302 3302 ... $ VOIT : Factor w/ 5 levels &quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,..: 1 2 3 4 1 2 3 4 1 2 ... $ nbmen: num [1:2070] 674.1 679.5 142.2 29.5 801.4 ... head(tab,5) # A tibble: 5 x 3 IRIS VOIT nbmen &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; 1 940020101 0 674. 2 940020101 1 679. 3 940020101 2 142. 4 940020101 3 29.5 5 940020102 0 801. Le résultat est un tibble au format “long” qui comporte 4 lignes différentes pour chaque IRIS, correspondant aux nombres de ménages ayant respectivement 0, 1, 2 et 3 voitures ou plus. Nous allons transformer ce tableau en format “large” pour placer côte à côte les différentes modalités du nombre de voitures. Pour cela il faut utiliser la fonction pivot_widerdu package tidyr. library(tidyr) tabcont &lt;- tab %&gt;% pivot_wider(names_from = VOIT, values_from = nbmen, names_prefix = &quot;MEN_VOIT&quot;, values_fill = 0) head(tabcont) # A tibble: 6 x 5 IRIS MEN_VOIT0 MEN_VOIT1 MEN_VOIT2 MEN_VOIT3 &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 940020101 674. 679. 142. 29.5 2 940020102 801. 903. 170. 24.8 3 940020103 661. 703. 76.0 10.6 4 940020104 694. 701. 126. 23.0 5 940020105 434. 960. 237. 29.3 6 940020106 625. 735. 166. 29.2 Grâce à cette transformation, nous disposons maintenant pour chaque IRIS de la distribution des ménages en fonction de leur nombre de voitures, ce qui constitue le tableau de contingence recherché. 3.2.4 Création d’un tableau de pourcentages en ligne Nous allons maintenant calculer le nombre total de ménage puis en déduire la proportion de ménages en fonction de leur nombre d’automobile pour chacun des IRIS. tabdon &lt;- tabcont %&gt;% mutate (MEN_TOTAL = MEN_VOIT0+MEN_VOIT1+MEN_VOIT2+MEN_VOIT3, PCT_VOIT0 = 100* MEN_VOIT0 / MEN_TOTAL, PCT_VOIT1 = 100* MEN_VOIT1 / MEN_TOTAL, PCT_VOIT2 = 100* MEN_VOIT2 / MEN_TOTAL, PCT_VOIT3 = 100* MEN_VOIT3 / MEN_TOTAL) head(tabdon[,c(1,6:10)]) # A tibble: 6 x 6 IRIS MEN_TOTAL PCT_VOIT0 PCT_VOIT1 PCT_VOIT2 PCT_VOIT3 &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 940020101 1525. 44.2 44.5 9.32 1.93 2 940020102 1899. 42.2 47.6 8.93 1.31 3 940020103 1450. 45.6 48.5 5.24 0.729 4 940020104 1544. 45.0 45.4 8.14 1.49 5 940020105 1660. 26.1 57.8 14.3 1.76 6 940020106 1555. 40.2 47.3 10.7 1.87 3.2.5 Estimation du nombre moyen d’automobile par menages Il n’est pas possible d’estimer le nombre exact d’automobile par ménage car l’INSEE ne détaille pas la catégorie VOIT = 3 qui correspond à “Trois automobiles ou +”. On peut néanmoins procéder à une estimation minimale du nombre d’automobile en supposant que les ménages de ce type ont exactement rois automobiles. On en déduit alors le nombre total d’automobile par IRIS (VOIT_TOTAL) et le nombre moyen d’automobile par ménage (VOIT_MEN). tabdon &lt;-tabdon %&gt;% mutate(VOIT_TOTAL = MEN_VOIT1 + 2*MEN_VOIT2 + 3*MEN_VOIT3, VOIT_MEN = VOIT_TOTAL / MEN_TOTAL) head(tabdon[,c(1,6,11,12)]) # A tibble: 6 x 4 IRIS MEN_TOTAL VOIT_TOTAL VOIT_MEN &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 940020101 1525. 1052. 0.690 2 940020102 1899. 1317. 0.694 3 940020103 1450. 886. 0.611 4 940020104 1544. 1021. 0.662 5 940020105 1660. 1522. 0.917 6 940020106 1555. 1154. 0.742 3.2.6 Analyse statistique des vraiables Avant de passer à la cartographie, on peut analyser quelques variables intéressantes. 3.2.6.1 Part des ménages sans automobiles Les ménages sans automobiles sont une catégorie intéressante, même si elle peut recouper des situations très diverses (étudiants, personnes âgées, pauvres, …). summary(tabdon$PCT_VOIT0) Min. 1st Qu. Median Mean 3rd Qu. Max. 0.00 21.94 30.95 31.13 40.84 65.31 ggplot(tabdon, aes(x=PCT_VOIT0)) + geom_histogram(bins=20, fill=&quot;gray30&quot;) + scale_y_continuous(&quot;Nombre d&#39;IRIS&quot;)+ scale_x_continuous(&quot;% de ménages&quot;)+ ggtitle(&quot;Par des ménages sans automobiles en 2017&quot;) La distribution apparaît très variable puisque les ménages sans automobiles sont absents de certains IRIS alors qu’ils représentent plus de la moitié des ménages dans d’autres IRIS. 3.2.6.2 Nombre moyen d’automobiles par ménage Même s’il est légèrement sous-estimé, le nombre d’automobile par ménage est un bon indicateur de la dépendance de certains logements mals desservis par les transports en commun. summary(tabdon$VOIT_MEN) Min. 1st Qu. Median Mean 3rd Qu. Max. 0.3944 0.7190 0.8675 0.9003 1.0458 2.0000 ggplot(tabdon, aes(x=VOIT_MEN)) + geom_histogram(bins=20, fill=&quot;gray30&quot;) + scale_y_continuous(&quot;Nombre d&#39;IRIS&quot;)+ scale_x_continuous(&quot;voitures / ménage&quot;)+ ggtitle(&quot;Nombre moyen d&#39;automobile par ménage en 2017&quot;) Alors qu’on trouve en général entre 0.6 et 1.2 automobiles par ménage, certains IRIS affichent des valeurs moyennes de 1.5 à 2 automobiles par ménage. 3.2.7 Jointure avec le fonds de carte On commence par effectuer une sauvegarde simple de notre tableau statistique saveRDS(tabdon,&quot;data/VOIT_IRIS.Rdata&quot;) Puis on effectue une jointure avec le fonds de carte map_iris et on réalise une sauvegarde sous un autre nom. tabfin&lt;-tabdon %&gt;% rename(CODE_IRIS = IRIS) map_VOIT_IRIS&lt;-left_join(map, tabfin) %&gt;% st_as_sf() Joining, by = &quot;CODE_IRIS&quot; saveRDS(map_VOIT_IRIS, &quot;data/map_VOIT_IRIS.Rdata&quot;) 3.3 Le package mapsf Le package mapsf permet de réaliser des cartes statiques de très haute qualité. Il a en effet été mis au point par des cartographes et des géomaticiens professionnels de l’UMS RIATE. Il prend la suite du package cartography dont la maintenance demeurera assuré quelque temps encore mais ne fera plus l’objet de développements futurs. Le package mapsf présente l’avantage d’être totalement compatibvle avec le package sf ce qui n’était pas autant le cas pour le package cartography, plus ancien, et créé pour être compatible avec l’ancien package sp. On trouvera la documentation du package mapsf à l’adresse suivante : https://riatelab.github.io/mapsf/index.html 3.3.1 Création d’un template cartographique Nous allons dans un premier temps apprendre à créer un fonds de carte vierge mais comportant tout l’habillage nécessaire (“template”). Pour cela nous allons charger différentes couches cartographiques correspondant respectivement au département, aux communes et aux iris : map_dep &lt;- readRDS(&quot;data/map_dep.Rdata&quot;) map_com &lt;- readRDS(&quot;data/map_com.Rdata&quot;) map_iris &lt;- readRDS(&quot;data/map_iris.Rdata&quot;) https://riatelab.github.io/mapsf/articles/mapsf.html 3.3.1.1 tracé d’un fonds de carte La fonction mf_map() avec le paramètre type = \"base\"permet de tracer une carte vide mf_map(map_iris, type = &quot;base&quot;) 3.3.1.2 Superposition de couches On peut toutefois ajouter toute une série de paramètres supplémentaire (col=, border=, lwd=, …) et superposer plusieurs fonds de carte avec le paramètre add = TRUE. L’ajout de la fonction layout permet de rajouter un cadre une légende. #library(mapsf) # Trace les Iris avec des paramètres mf_map(map_iris, type = &quot;base&quot;, col = &quot;lightyellow&quot;, border=&quot;gray80&quot;, lwd=0.3) # Ajoute les contours des communes mf_map(map_com, type = &quot;base&quot;, col = NA, border=&quot;red&quot;, lwd=1, add = TRUE) # Ajoute un cadre, un titre et des sources mf_layout(title = &quot;Val de Marne&quot;, credits = &quot;Sources : IGN et INSEE&quot;) 3.3.1.3 Ajout d’un thème On peut finalement modifier l’ensemble de la carte en lui ajoutant une instruction mf_theme() qui peut reprendre des styles existants ( “default”, “brutal”, “ink”, “dark”, “agolalight”, “candy”, “darkula”, “iceberg”, “green”, “nevermind”, “jsk”, “barcelona”) mais aussi créer ses propres thèmes #library(mapsf) mf_theme(&quot;candy&quot;) # Trace les Iris avec des paramètres mf_map(map_iris, type = &quot;base&quot;, col = &quot;lightyellow&quot;, border=&quot;gray80&quot;, lwd=0.3) # Ajoute les contours des communes mf_map(map_com, type = &quot;base&quot;, col = NA, border=&quot;red&quot;, lwd=1, add = TRUE) # Ajoute un cadre, un titre et des sources mf_layout(title = &quot;Val de Marne&quot;, frame = TRUE, credits = &quot;Sources : IGN et INSEE&quot;) 3.3.1.4 Ajout de texte On peut ajouter une couche de texte avec la fonction mf_label(). Par exemple, on va ajouter à la carte précédente le nom des communes #library(mapsf) mf_theme(&quot;candy&quot;) # Trace les Iris avec des paramètres mf_map(map_iris, type = &quot;base&quot;, col = &quot;lightyellow&quot;, border=&quot;gray80&quot;, lwd=0.3) # Ajoute les contours des communes mf_map(map_com, type = &quot;base&quot;, col = NA, border=&quot;red&quot;, lwd=1, add = TRUE) # Ajoute les contours des communes mf_label(map_com, var=&quot;NOM_COM&quot;, cex=0.4, overlap = FALSE) # Ajoute un cadre, un titre et des sources mf_layout(title = &quot;Communes et Iris du Val de Marne en 2017&quot;, frame = TRUE, credits = &quot;Sources : IGN et INSEE&quot;) 3.3.2 Carte de stock Une carte de stock représente la localisation de quantités que l’on peut aditionner et dont le total a un sens. Par exemple un nombre d’habitants, un nombre de ménages, un nombre d’automobiles. Ce quantités doivent être représentées par des figures (cercles, carrés, …) dont la surface est proportionelle au stock afin que l’oeil du lecteur puisse les aditionner visuellement. Dans le package map_sf, on réalise ce type de carte à l’aide de la fonction mf_map()en lui donnant le paramètre type=\"prop\". On va tenter à titre d’exemple de représenter la distribution du nombre de voitures par IRIS : 3.3.2.1 Carte minimale Les instructions minimales sont les suivantes : map_com&lt;-readRDS(&quot;data/map_com.Rdata&quot;) map_iris&lt;-readRDS(&quot;data/map_VOIT_IRIS.Rdata&quot;) # Trace les contours des communes mf_map(x= map_iris, type = &quot;base&quot;) # Ajoute le nombre de ménages par IRIS mf_map(x =map_iris, type =&quot;prop&quot;, var = &quot;VOIT_TOTAL&quot;, add=TRUE ) Mais le résultat est peu satisfaisant car les cercles sont trop grands. Il faut en pratique toujours effectuer un réglage de ceux-ci avec l’instruction inches= 3.3.2.2 Carte habillée map_com&lt;-readRDS(&quot;data/map_com.Rdata&quot;) map_iris&lt;-readRDS(&quot;data/map_VOIT_IRIS.Rdata&quot;) mf_theme(&quot;candy&quot;) # Trace les Iris avec des paramètres mf_map(map_iris, type = &quot;base&quot;, col = &quot;lightyellow&quot;, border=&quot;gray80&quot;, lwd=0.3) # Ajoute les contours des communes mf_map(map_com, type = &quot;base&quot;, col = NA, border=&quot;black&quot;, lwd=1, add = TRUE) # Ajoute les cercles proportionnels mf_map( x =map_iris, var = &quot;MEN_TOTAL&quot;, type = &quot;prop&quot;, inches = 0.04, col = &quot;red&quot;, leg_pos = &quot;left&quot;, leg_title = &quot;Nombre de voitures&quot;, add=TRUE ) # Ajoute un cadre, un titre et des sources mf_layout(title = &quot;Distribution des voitures du Val de Marne en 2017&quot;, frame = TRUE, credits = &quot;Sources : IGN et INSEE&quot;) 3.3.3 Carte d’intensité (choroplèthe) Une carte d’intensité représente un phénomène relatif dont la somme n’a pas de sens. Par exemple, il serait absurde d’aditionner les nombres d’automobiles par habitant des IRIS du Val de Marne. Ces variables d’intensité caractèrisent donc l’état général d’une zone (choros) at elles vont être représentées par une couleur appliquée à toute la surface de la zone, d’où leur nom de cartes choroplèthes. La fonction du package mapsf adaptée aux variables d’intensité est la fonction mf_map()munie du paramètre type = \"choro\". On va prendre l’exemple du nombre de voitures par ménage. 3.3.3.1 Carte minimale Si on ne précise rien, la carte est réalisée à l’aide de la palette par défaut avec un découpage des classes en quantiles (effectifs égaux). map_iris&lt;-readRDS(&quot;data/map_VOIT_IRIS.Rdata&quot;) # Carte choroplèthe mf_map( x = map_iris, var = &quot;VOIT_MEN&quot;, type = &quot;choro&quot; ) 3.3.3.2 Carte avec habillage On peut arriver à une carte beaucoup plus satisfaisante en contrôlant l’ensemble des paramètres de couleur et de découpage des classes. Puis en superposant les contours de communes au dessus de la carte des IRIS pour faciliter le repérage. map_com&lt;-readRDS(&quot;data/map_com.Rdata&quot;) map_iris&lt;-readRDS(&quot;data/map_VOIT_IRIS.Rdata&quot;) # Choisit les classes mybreaks = c(0.3,0.5, 0.6,0.7,0.8,0.9, 1,1.1, 1.2,1.3,1.4,1.5,2.1) # Crée une palette mypal &lt;- mf_get_pal(n = c(6, 6), pal = c(&quot;Greens&quot;, &quot;Reds&quot;)) # Trace la carte choroplèthe mf_map( x = map_iris, var = &quot;VOIT_MEN&quot;, type = &quot;choro&quot;, breaks = mybreaks, pal = mypal, border=&quot;white&quot;, col_na = &quot;gray80&quot;, leg_title = &quot;voiture/ménage&quot; ) # Ajoute les contours des communes mf_map(map_com, type = &quot;base&quot;, col = NA, border=&quot;black&quot;, lwd=1, add = TRUE) # Ajoute un cadre, un titre et des sources mf_layout(title = &quot;Dépendance automobile dans le Val de Marne en 2017&quot;, frame = TRUE, credits = &quot;Sources : IGN et INSEE&quot;) 3.3.4 Carte de stock + intensité On peut combiner les deux modes cartographiques. Prenons à titre d’exemple le cas des ménages ayant trois automobiles ou plus. Onn peut décrire ce phénomène soit en terme de stock, soit en termes d’intensité. summary(map_iris$MEN_VOIT3) Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s 0.00 12.50 21.42 26.20 33.77 145.76 9 summary(map_iris$PCT_VOIT3) Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s 0.000 1.170 1.943 2.510 3.160 16.114 9 On réalise les deux cartes successivement en commençant par la carte de taux puis en lui ajoutant la carte de stock par dessus. map_com&lt;-readRDS(&quot;data/map_com.Rdata&quot;) map_iris&lt;-readRDS(&quot;data/map_VOIT_IRIS.Rdata&quot;) # Choisit les classes # Trace la carte choroplèthe mf_map( x = map_iris, var = &quot;PCT_VOIT3&quot;, nbreaks = 5, type = &quot;choro&quot;, border=&quot;white&quot;, col_na = &quot;gray80&quot;, lwd=0.3, leg_title = &quot;% ménages&quot; ) # Ajoute les cercles proportionnels mf_map( x =map_iris, var = &quot;MEN_VOIT3&quot;, type = &quot;prop&quot;, inches = 0.04, col = &quot;red&quot;, leg_pos = &quot;right&quot;, leg_title = &quot;Nb ménages&quot;, add=TRUE ) # Ajoute les contours des communes mf_map(map_com, type = &quot;base&quot;, col = NA, border=&quot;white&quot;, lwd=1, add = TRUE) # Ajoute un cadre, un titre et des sources mf_layout(title = &quot;Les ménages ayant trois voitures et plus 2017&quot;, frame = TRUE, credits = &quot;Sources : IGN et INSEE&quot;) 3.4 Création de fonctions L’objectif de cette section est de préparer des fonctions de cartographie qui pourront être intégrés dans une application shiny. On va pour cela reprendre les fonctions mises au point dans la partie statistiques et les coupler avec des procédures de cartographie. On se limitera dans l’immédiat à l’emploi des packages sfet cartography,mais on pourra par la suite créer d’autres fonctions fondées sur des packages tels que leaflet, plotlyou tmap… 3.4.1 fonction tab_cont_iris() On va prendre comme point de départ la création d’un tableau de contingence spatial c’est-à-dire un tableau dont les lignes correspondent aux IRIS d’une commune et les colonnes aux modalités d’une variable de type factor. On récupère les fonctions statistiques mises au point précédemment source(&quot;fonctions/mes_fonctions_V4.R&quot;) On charge le fichier de données en lui ajoutant la variable LPRM_1 dont nous aurons besoin pour distinguer les données par ménage et pour l’ensemble de la population. 3.4.1.1 création du tableau avec la fonction tab_var2 tab&lt;-tab_var2(data = RP, listcom = &quot;94071&quot;, menag = TRUE, var = VOIT, IRIS) 3.4.1.2 pivotage du tableau On opére deux opérations de pivotage du tableau pour récupérer les valeurs brutes (raw) et les valeurs en % (pct). tab_raw &lt;- pivot_wider(data = tab %&gt;% select(-pct), names_from = VOIT, values_from = n, values_fill = 0) names(tab_raw)[-1] &lt;- paste(&quot;count_&quot;,names(tab_raw)[-1], sep=&quot;&quot;) tab_pct &lt;- pivot_wider(data = tab %&gt;% select(-n), names_from = VOIT, values_from = pct, values_fill = 0) names(tab_pct)[-1] &lt;- paste(&quot;pct_&quot;,names(tab_pct)[-1], sep=&quot;&quot;) 3.4.1.3 Ajout de la géométrie On fusionne les deux tableaux précédents et bon effectue la jointure avec le fonds de carte, ce qui suppose de renommer la variable IRIS en CODE_IRIS. tab_geo &lt;- left_join(tab_raw, tab_pct) %&gt;% rename(CODE_IRIS=IRIS) %&gt;% left_join(map_iris) %&gt;% st_as_sf() Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; 3.4.1.4 Création d’une fonction unique On reprend les étapes précédentes pour en faire une fonction unique appelée tab_cont_irisqui prend en entrée une variable quelconque de type factor et produit en sortie le tableau de contingence spatial soit par individu, soit par ménages. tab_cont_iris &lt;- function(data, map, listcom, menag, var) { # Create tab tab &lt;-tab_var2(data, listcom, menag, {{var}}, IRIS) # Pivot count tab_raw &lt;- pivot_wider(data = tab %&gt;% select(-pct), names_from = {{var}}, values_from = n, values_fill = 0) names(tab_raw)[-1] &lt;- paste(&quot;count_&quot;,names(tab_raw)[-1], sep=&quot;&quot;) # Pivot pct tab_pct &lt;- pivot_wider(data = tab %&gt;% select(-n), names_from = {{var}}, values_from = pct, values_fill = 0) names(tab_pct)[-1] &lt;- paste(&quot;pct_&quot;,names(tab_pct)[-1], sep=&quot;&quot;) # join with geom tab_geo &lt;- left_join(tab_raw, tab_pct) %&gt;% rename(CODE_IRIS=IRIS) %&gt;% left_join(map) %&gt;% st_as_sf() return(tab_geo) } 3.4.1.5 Test de la fonction On peut tester la fonction sur la variable SEXE en effectuant un comptage : soit pour la population totale en prenant menag = FALSE SEXE_IRIS_pop &lt;- tab_cont_iris(RP,map_iris,&quot;94071&quot;,menag = FALSE,SEXE) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; head(SEXE_IRIS_pop,3) # A tibble: 3 x 12 CODE_IRIS count_1 count_2 pct_1 pct_2 INSEE_COM NOM_COM IRIS NOM_IRIS &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 940710101 1094 1057 50.9 49.1 94071 Sucy-e… 0101 Le Gran… 2 940710102 1056 1148 47.9 52.1 94071 Sucy-e… 0102 La Foss… 3 940710103 1329 1515 46.7 53.3 94071 Sucy-e… 0103 La Cite… # … with 3 more variables: TYP_IRIS &lt;chr&gt;, geometry &lt;MULTIPOLYGON [m]&gt;, # DEPT &lt;chr&gt; soit pour les chefs de ménage en prenant menag = TRUE SEXE_IRIS_men &lt;- tab_cont_iris(RP,map_iris,&quot;94071&quot;,menag=TRUE,SEXE) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; head(SEXE_IRIS_men,3) # A tibble: 3 x 12 CODE_IRIS count_1 count_2 pct_1 pct_2 INSEE_COM NOM_COM IRIS NOM_IRIS &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 940710101 474 338 58.4 41.6 94071 Sucy-e… 0101 Le Gran… 2 940710102 411 411 50 50 94071 Sucy-e… 0102 La Foss… 3 940710103 553 496 52.7 47.3 94071 Sucy-e… 0103 La Cite… # … with 3 more variables: TYP_IRIS &lt;chr&gt;, geometry &lt;MULTIPOLYGON [m]&gt;, # DEPT &lt;chr&gt; 3.4.1.6 Préparation de fichiers sur une zone d’étude On prépare une séruie de fichiers pour étudier un ensemble de 5 communes sel &lt;- c(&quot;94071&quot;,&quot;94068&quot;,&quot;94011&quot;,&quot;94055&quot;, &quot;94019&quot;) # Selection des logements ordinaire don &lt;-RP %&gt;% filter(LPRM !=&quot;Z&quot;) # Equipement automobile des ménages map&lt;-tab_cont_iris(don, map_iris,sel,TRUE,VOIT) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; saveRDS(mapauto,&quot;data/sel_map_men_auto.Rdata&quot;) # LOGEMENT EN hlm don2&lt;-don %&gt;% filter(HLML !=&quot;Z&quot;) map&lt;-tab_cont_iris(don2, map_iris,sel,TRUE,HLML) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; saveRDS(map,&quot;data/sel_map_pop_hlm.Rdata&quot;) # Catégorie social des actifs don2&lt;-don %&gt;% filter(CS1 !=&quot;Z&quot;) map&lt;-tab_cont_iris(don2, map_iris,sel,TRUE,CS1) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; saveRDS(map,&quot;data/sel_map_pop_csp.Rdata&quot;) # Mode de transport des actifs don2&lt;-don %&gt;% filter(TRANS !=&quot;Z&quot;) map&lt;-tab_cont_iris(don2, map_iris,sel,FALSE,TRANS) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; saveRDS(map,&quot;data/sel_map_act_csp.Rdata&quot;) 3.4.2 fonction map_count_iris Nous allons créer différentes fonctions de cartographie selon que la variable à représenter est un stock (count_x) ou une intensité (pct_xx). Dans l’immédiat nous allons nous limiter aux fonctions de base du package cartographymais ou pourra par la suite proposer d’autres solutions. 3.4.2.1 Objectifs On prend comme entrée un tableau de contingence spatial et on décide de représenter l’une des modalités de type count. Soit par exemple la modalité 3 de la variable VOIT mesurée en nombre de ménages map&lt;-tab_cont_iris(RP, map_iris,&quot;94071&quot;,TRUE,VOIT) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; map&lt;-tab_cont_iris(RP, map_iris,c(&quot;94071&quot;,&quot;94068&quot;,&quot;94011&quot;,&quot;94055&quot;, &quot;94019&quot;),TRUE,VOIT) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; saveRDS(mapauto,&quot;data/sel_map_men_auto.Rdata&quot;) map&lt;-tab_cont_iris(RP, map_iris,c(&quot;94071&quot;,&quot;94068&quot;,&quot;94011&quot;,&quot;94055&quot;, &quot;94019&quot;),TRUE,CS1) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; saveRDS(map,&quot;data/sel_map_men_csp.Rdata&quot;) don&lt;-RP %&gt;% filter(TRANS !=&quot;Z&quot;) map&lt;-tab_cont_iris(don, map_iris,c(&quot;94071&quot;,&quot;94068&quot;,&quot;94011&quot;,&quot;94055&quot;, &quot;94019&quot;),FALSE,TRANS) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; saveRDS(map,&quot;data/sel_map_act_csp.Rdata&quot;) 3.4.2.2 Fonction minimale On va maintenant créer une fonction ayant autant de paramètres que nécessaire pour pouvoir s’appliquer à n’importe quelle modalité de n’importe quelle variable. La fonction minimale devra comporter 6 paramètres map_count_iris &lt;- function (data, map, listcom, menag, var, mod, titre) { mymap&lt;-tab_cont_iris(data,map_iris,listcom,menag,{{var}}) myvar &lt;- paste(&quot;count_&quot;,mod, sep=&quot;&quot;) if (menag==FALSE) {myleg = &quot;nb. d&#39;habitants&quot;} else {myleg = &quot;nb de ménages&quot;} mf_map(x= mymap, type = &quot;base&quot;, col=&quot;lightyellow&quot;, border=&quot;gray80&quot;,lwd=0.4) mf_map(x = mymap, var = myvar, type = &quot;prop&quot;, col=&quot;blue&quot;, leg_title = myleg, inches = 0.06) mf_layout(title = titre, frame = TRUE, credits =&quot;INSEE, RP 2017, fichiers détail&quot;) } On teste la fonction sur les ménages ayant plus de trois voitures à Sucy-en-Brie map_count_iris(data = RP, map = map_iris, listcom = &quot;94071&quot;, menag= TRUE, var = VOIT, mod = 3, &quot;Ménages avec trois voitures ou plus&quot;) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; On vérifie qu’elle marche également si on ajoute les communes voisines de Saint-Maur-des-Fossés (94068) , Bonneuil (94011), Ormesson (94055), Chennevières (94019) et Noiseau (94053) map_count_iris(data = RP, map = map_iris, listcom = c(&quot;94071&quot;,&quot;94068&quot;,&quot;94011&quot;,&quot;94055&quot;, &quot;94019&quot;), menag= TRUE, var = VOIT, mod = 3, &quot;Ménages avec trois voitures ou plus&quot;) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; … ou bien sur une autre modalité d’une autre variable. Par exemple la distribution des ménages dont la personne de référence est ouvrier. map_count_iris(data = RP, map = map_iris, listcom = c(&quot;94071&quot;,&quot;94068&quot;,&quot;94011&quot;,&quot;94055&quot;, &quot;94019&quot;), menag= TRUE, var = CS1, mod = 6, &quot;Ménages ouvriers en 2017&quot;) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; 3.4.2.3 Fonction améliorée Vous pouvez maintenant améliorer la fonction en lui ajoutant d’autres paramètres variables tels que : la couleur de remplissage des cercles la couleur d’arrière-plan des iris le zoom d’aggrandissement des cercles etc. 3.4.3 fonction map_pct_iris Nous allons maintenant préparer un pogramme pour cartographier une variable d’intensité (pct_xx) dont la somme n’a pas de sens et qui doit donc utiliser le mode cartographique zonal (carte choroplèthe). 3.4.3.1 Objectifs On prend comme entrée le tableau de contingence spatial qui a été transformé en profil en ligne avec des modalités de type pct. Comme nous allons devoir établir automatiquement des classes sans connaître la forme de la distribution, nous devons utiliser une solution robuste. La méthode des quantiles apparaît alors comme la plus adaptée puisqu’elle consiste à découper la distribution en classes d’effectifs égaux. Concernant le nombre de classes, il doit dépendre du nombre d’éléments (ici d’IRIS) et nous allons utiliser pour cela la formule de Huntsberger qui indique le nombre maximum de classes souhaitable (K) en fonction du nombre d’élément (n). \\(K = 1 + \\frac{10}{3}.log_{10}(x)\\) 3.4.3.2 Fonction minimale On va maintenant créer une fonction ayant autant de paramètres que nécessaire pour pouvoir s’appliquer à n’importe quelle modalité de n’importe quelle variable. La fonction minimale devra comporter 7 paramètres map_pct_iris &lt;- function ( data, map, listcom, menag, var, mod, titre) { mymap&lt;-tab_cont_iris(data,map,listcom,menag,{{var}}) myvar &lt;- paste(&quot;pct_&quot;,mod, sep=&quot;&quot;) if (menag==FALSE) {myleg = &quot;% des habitants&quot;} else {myleg = &quot;% des ménages&quot;} huntsberger &lt;- function(x) {round(1+(10/3)*log10(x))} nbc&lt;-huntsberger(nrow(mymap)) mf_map(x = mymap, var = myvar, type = &quot;choro&quot;, nbreaks = nbc, leg_title = myleg) mf_layout(title = titre, frame = TRUE, credits =&quot;INSEE, RP 2017, fichiers détail&quot;) } On teste la fonction sur les ménages ayant plus de trois voitures à Sucy-en-Brie map_pct_iris(data = RP, map= map_iris, listcom = &quot;94071&quot;, menag = &quot;1&quot;, var = VOIT, mod = 3, &quot;Ménages avec trois voitures ou plus&quot;) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; On vérifie qu’elle marche également sur un groupe de communes map_pct_iris(data = RP, map = map_iris, listcom = c(&quot;94071&quot;,&quot;94068&quot;,&quot;94011&quot;,&quot;94055&quot;, &quot;94019&quot;), menag= TRUE, var = VOIT, mod = 3, &quot;Ménages avec trois voitures ou plus&quot;) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; … ou bien sur une autre modalité d’une autre variable. Par exemple la distribution des ménages dont la personne de référence est ouvrier à Sucy-en-Brie map_pct_iris(data = RP, map = map_iris, listcom = c(&quot;94071&quot;,&quot;94068&quot;,&quot;94011&quot;,&quot;94055&quot;, &quot;94019&quot;), menag= TRUE, var = CS1, mod = 6, &quot;Ménages ouvriers en 2017&quot;) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; 3.4.3.3 Fonction améliorée Vous pouvez maintenant améliorer la fonction en lui ajoutant d’autres paramètres variables tels que : la palette de couleur le nombre de classes le mode de découpage des classes etc. 3.4.4 Sauvegarde des fonctions On sauvegarde les nouvelles fonctions dans un nouveau fichier mes_fonctions_V4.R qui comporte les fonctions statistiques précédents et les nouvelles fonctions cartographiques mises au point dans ce chapitre. "],["22-leaflet.html", "Chapitre 4 Cartes dynamiques (CG) Introduction 4.1 Une carte élémentaire 4.2 Une carte statistique", " Chapitre 4 Cartes dynamiques (CG) Ce cours propose de fournir les bases du logiciel Leaflet. Il est très largement inspiré d’un article d’Elena Salette publié sur l’excellent site de formation ThinkR et intitulé Cartographie interactive : comment visualiser mes données spatiales de manière dynamique avec leaflet ? Claude Grasland (Professeur à l’Université de Paris) Introduction Les cartes interactives se sont multipliées depuis quelques années sur les différents types d’écran (ordinateur, tablette, smartphone, …), le plus souvent sous la forme de figurés ponctuels (les fameuses “épingles” de Google) mais aussi désormais de plus en plus de grappes de points, de polygones ou de lignes. Le logiciel Leaflet a joué un rôle décisif dans cette révolution cartographique en raison de son caractère libre, de sa polyvalence en terme de langage (R, Python, …) et bien évidemment de ses qualités intrinsèques. Le package Leaflet est par ailleurs particulèrement adapté au couplage avec les applications interactives de type Shiny et plus généralement les outils de crétion de tableaux de bords (dashboard). Pour Elena Salette, c’es est clairement le logiciel de référence Je dirais que leaflet est LA star des packages de cartes interactifs. On le voit partout, et même si on lui reproche parfois sa lenteur d’affichage, il est ultra complet, et la doc est vraiment bien faite : https://rstudio.github.io/leaflet/. Ce package utilise la librairie Javascript open source du même nom qui est largement utilisée (cf. la partie “Trusted by the best” sur https://leafletjs.com/ ). Source : Elena Salette, ThinkR, 25-08-2020 Il n’est évidemment pas possible de donner en quelques heures une formation complète à Leaflet mais il est essentiel pour des étudiants se destinant au métier de data analyst ou de data scientist d’en maîtriser les bases, cde qui est l’objet du présent cours. BUG ! . : Pour une raison qui m’échappe, il peut arriver que la transformation du fichier .Rmd en .html ne s’opère pas et que vous voyiez apparaître le message d’erreur suivant RMarkdown cannot knit: html_dependency not found. Ce message d’erreur persiste même après avoir corrigé le code… ce qui est très pénible. Après avoir cherché sur les forums de discussion, j’ai trouvé une réponse ici qui consiste simplement à aller sur la flèche descendnate à droite du bouton knitr et effectuer un clear knitr cache avant de relancer le Knitr. Apparemment ça marche, sans que je sache bien pourquoi … 4.1 Une carte élémentaire 4.1.1 Lancement avec leaflet() Nous allons avoir besoin des packages suivants : Leaflet puisque c’est l’objet même du cours ! dplyr afin de pouvoir construire des programmes utilisant des pipes %&gt;% sf pour charger des fonds de carte de différents types (points, lignes polygones) htmltools et htmlwidgets pour ajouter des popups interactifs sur notre carte Pour vérifier que le package leaflet est bien installé, nous créons une première carte (vide !) map &lt;- leaflet() map Et il n’y a … RIEN ! si ce n’est un bouton de zoom 4.1.2 Remplissage avec addTiles() On ajoute sur ce fond de carte vide des “tuiles” cartographiques qui sont des images se modifiant selon l’échelle pour apporter plus ou moins de détails. Par défaut, le fonds de carte de référence est le fonds OpenStreetMap library(leaflet) map &lt;- leaflet() %&gt;% addTiles() map La carte est désormais interactive et on peut effectuer des zooms ou se déplacer. 4.1.3 Calage avec setView() Nous allons ensuite choisir un point de référence, par exemple la place de la gare à Sucy-en-Brie. Pour trouver les coordonnées de latitude et longitude, la solution la plus simple est d’utiliser Google Maps puis de zoomer sur la zone d’étude et enfin d’effectuer un click droit avec la souris sur le point dont on cherche les coordonnées pour obtenir dans un popup les coordonnées recherchées : On peut alors procéder à une double opération de centrage de notre carte et de définition d’une échelle d’observation afin que la carte produite par leafletcouvre bien la zone qui nous intéresse. Cette double opération est réalisée à l’aide de la fonction setView() assortie des trois paramètre suivants : lng = pour la longitude lat = pour la latitude zoom = pour le degré d’aggrandissement de la carte de 1 pour le Monde entier à 20 pour une vision ulra locale map &lt;- leaflet() %&gt;% addTiles() %&gt;% setView(lat = 48.77141, lng=2.50870, zoom = 17) map Une fois qu’on a vérifié le centrage avec un zoom fort (ici 17), on peut refaire la carte en utilisant un zoom plus faible, par exemple un zoom de 12 permettant de visualiser toute la commune de Sucy et les communes voisines. map &lt;- leaflet() %&gt;% addTiles() %&gt;% setView(lat = 48.77141, lng=2.50870, zoom = 12) map 4.1.4 Personalisation avec addProviderTiles() Les tuiles OpenStreetMap qui servent de fonds de carte par défaut peuvent être remplacés par des tuiles personalisées fournies par des producteurs publics ou privés. On peut obtenir la liste des tuiles disponibles en tapant providers dans la console de R studio et les tester une par une. Mais il est souvent plus simple et plus rapide d’aller visualiser les tuiles disponibles sur ce site web où l’on peut centrer le monde sur sa zone d’étude et voir ce que donnent les différentes familles de tuiles. A titre d’exemple, les tuiles Stamen.Watercolor donnent une touche pastel artistique à la carte : map &lt;- leaflet() %&gt;% addProviderTiles(&#39;Stamen.Watercolor&#39;) %&gt;% setView(lat = 48.77141, lng=2.50870, zoom = 12) map Tandis que la couche Esri.WorldTopoMap fournit une imagerie précise mais de couleurs plus neutre que les tuiles OpenStreetMap , ce qui sera intéressant si on superspose des marqueurs de couleur vive. map &lt;- leaflet() %&gt;% addProviderTiles(&#39;Esri.WorldTopoMap&#39;) %&gt;% setView(lat = 48.77141, lng=2.50870, zoom = 12) map 4.1.5 Affichage d’un point avec addMarkers() L’usage le plus fréquent de leafletconsiste à ajouter des éléments de localisation ponctuelle appelés markerset de rendre ces objets ponctuels interactifs avec l’ouverture de fenêtres popupslorsqu’on clique dessus avec la souris. On va donc voir pas à pas comment construire de telles cartes interactives en partant du cas le plus simple (marqueur unique) pour aller vers les cas plus complexes (ensemble de marqueurs de taille, couleur et formes différentes). Nous allons commencer par indiquer l’emplacement de la place de la gare de Sucy-en-Brie sur notre carte précédente à l’aide de la fonction addMarkers() : map &lt;- leaflet() %&gt;% addProviderTiles(&#39;Esri.WorldTopoMap&#39;) %&gt;% setView(lat = 48.77141, lng=2.50870, zoom = 12) %&gt;% addMarkers(lat = 48.77141, lng=2.50870) map On constate que le marqueur donne bien la position choisi mais n’est pas interactif. Il faut ajouter plus de paramètres pour assurer l’interactivité. 4.1.6 Ajout d’un labelou d’un popup On peut définir deux comportements d’un marker selon que la souris ne fait que passer dessus (label) ou selon que l’utilisateur effectue un click sur marker et déclenche l’ouverture d’une fenêtre (popup). Dans sa version la plus simple, l’interactivité consiste à ajouter une chaîne de caractère à ces deux paramètres. icone_gare &lt;-makeIcon(iconUrl = &quot;img/gare_sucy_coord_googlemap.png&quot;) map &lt;- leaflet() %&gt;% addProviderTiles(&#39;Esri.WorldTopoMap&#39;) %&gt;% setView(lat = 48.77141, lng=2.50870, zoom = 12) %&gt;% addMarkers(lat = 48.77141, lng=2.50870, # En passant la souris label = &quot;GARE DE SUCY-BONNEUIL&quot;, # En cliquant sur l&#39;icone popup = &quot;La gare RER A de Sucy Bonneuil est bien reliée aux communes environnantes par un réseau de bus partant dans toutes les directions&quot;) map 4.1.7 Amélioration du popup Mais on peut faire beaucoup mieux, notamment pour la fenêtre popupqui peut prendre la forme d’une mini-page web dont on fixe le contenu en html avec la fonction paste0() et les dimensions avec le sous-paramètre popupOptions(). # Préparation de la fenêtre Popup my_popup = paste0( &quot;&lt;b&gt; LA GARE DE SUCY&quot;, &quot;&lt;/b&gt;&lt;br/&gt;&lt;img src=https://upload.wikimedia.org/wikipedia/commons/thumb/6/68/Gare_Sucy-en-Brie.jpg/1200px-Gare_Sucy-en-Brie.jpg width=&#39;200px&#39;&gt;&lt;br/&gt;&quot;, &quot;La gare RER A de Sucy Bonneuil est bien reliée aux communes environnantes par un réseau de bus partant dans toutes les directions&quot;) # Réalisation de la carte map &lt;- leaflet() %&gt;% addProviderTiles(&#39;Esri.WorldTopoMap&#39;) %&gt;% setView(lat = 48.77141, lng=2.50870, zoom = 12) %&gt;% addMarkers(lat = 48.77141, lng=2.50870, # En passant la souris label = &quot;GARE DE SUCY-BONNEUIL&quot;, # En cliquant sur l&#39;icone popup = my_popup, # Quelques options de la popup popupOptions = list(maxHeight = 150, maxWidth = 200)) map Et voila, le tour est joué ! 4.2 Une carte statistique 4.2.1 Préparation des données On prend comme exemple les données relatives au nombres de personnes résidant en HLM dans une sélection de communes du Val de Marne à l’échelle des IRIS. Le fichier doit être impérativement au format sf et on s’en s’assure en passant la fonction st_as_sf() ` mapiris&lt;-readRDS(&quot;data/sel_map_pop_hlm.Rdata&quot;) # Fichier mapiris&lt;-st_as_sf(mapiris) # vérifie que le format est bien sf head(mapiris) # A tibble: 6 x 12 CODE_IRIS count_1 count_2 pct_1 pct_2 INSEE_COM NOM_COM IRIS NOM_IRIS &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 940110101 73 164 30.8 69.2 94011 Bonneu… 0101 Zone d&#39;… 2 940110102 204 876 18.9 81.1 94011 Bonneu… 0102 Centre … 3 940110103 56 690 7.5 92.5 94011 Bonneu… 0103 Haut Bo… 4 940110104 719 19 97.4 2.6 94011 Bonneu… 0104 Cite Fa… 5 940110105 940 6 99.4 0.6 94011 Bonneu… 0105 Saint-E… 6 940110106 657 111 85.5 14.5 94011 Bonneu… 0106 Salvado… # … with 3 more variables: TYP_IRIS &lt;chr&gt;, geometry &lt;MULTIPOLYGON [m]&gt;, # DEPT &lt;chr&gt; Les coordonnées géométriques sont actuellement projetées selon la projection (crs = RF93_Lambert_93 qui est la projection de référence utilisée en France. Cette projection permet de calculer au mieux les distances avec une précision de l’ordre du mètre. Mais les données ainsi projetées ne sont pas utilisables par leafletqui attend des coordonnées de latitude et longitude non projetées . On doit donc reprojeter le fond de carte pour le rendre utilisable par Leaflet et ajouter des colonnes lat et lng. Cela se fait facilement avec la fonction st_transform()du package sf en lui donnant comme paramètre (crs=4326) ce qui correspond à la projection WGS 84. mapiris&lt;-mapiris %&gt;% st_transform(crs = 4326) head(mapiris) # A tibble: 6 x 12 CODE_IRIS count_1 count_2 pct_1 pct_2 INSEE_COM NOM_COM IRIS NOM_IRIS &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 940110101 73 164 30.8 69.2 94011 Bonneu… 0101 Zone d&#39;… 2 940110102 204 876 18.9 81.1 94011 Bonneu… 0102 Centre … 3 940110103 56 690 7.5 92.5 94011 Bonneu… 0103 Haut Bo… 4 940110104 719 19 97.4 2.6 94011 Bonneu… 0104 Cite Fa… 5 940110105 940 6 99.4 0.6 94011 Bonneu… 0105 Saint-E… 6 940110106 657 111 85.5 14.5 94011 Bonneu… 0106 Salvado… # … with 3 more variables: TYP_IRIS &lt;chr&gt;, geometry &lt;MULTIPOLYGON [°]&gt;, # DEPT &lt;chr&gt; Le fichier est en apparence le même mais les coordonnées de la variable geometry sont désormais en degrés décimaux. Et on peut du coup extraire pour chaque polygone les coordonnées du point central à l’aide des fonctions st_centroid() et st_coordinates() coo&lt;-st_coordinates(st_centroid(mapiris)) head(coo) X Y 1 2.490429 48.77414 2 2.481459 48.77566 3 2.477026 48.77223 4 2.488028 48.77105 5 2.482796 48.77102 6 2.480329 48.76829 On ajoute ces deux variables de coordonnées dans notre fichier principal pour pouvoir les combiner avec les autres variables mapiris$lng&lt;-coo[,1] mapiris$lat&lt;-coo[,2] si nous de disposons pas déjà d’une carte de communes, on peut la réaliser facilement en agrégeant les données IRIS par la variable NOM_COM puis ajouter les centroïdes de ces dernières comme on l’a fait pour les IRIS. mapcom &lt;- mapiris %&gt;% group_by(NOM_COM) %&gt;% summarise() %&gt;% st_as_sf() coo&lt;-st_coordinates(st_centroid(mapcom)) mapcom$lng&lt;-coo[,1] mapcom$lat&lt;-coo[,2] Un message nous avertit qu’il aurait mieux valu calculer les centroïdes sur des données projetées mais ce n’est pas absolument indispensable si l’on ne cherche pas une précision absolue. 4.2.2 Contours des iris et communes avec addPolygons() La fonction leaflet de base pour tracer des polygones est addPolygons() qui est l’équivalent de addMarkers() que l’on a vu précédemment. Mais la différence importante est que l’on peut désormais fournir un fichier sf aux fonctions addPolygons et addMarkers puis accéder aux variables contenues dans ce fichier en utilisant un tilde ’~’suivi du nom de la variable. On peut par exemple construire une carte des communes avec un label donnant le nom # Réalisation de la carte map &lt;- leaflet() %&gt;% addProviderTiles(&#39;Esri.WorldTopoMap&#39;) %&gt;% setView(lat = 48.77, lng=2.53, zoom = 12) %&gt;% addPolygons(data = mapcom, color = c(&quot;red&quot;,&quot;orange&quot;,&quot;yellow&quot;,&quot;green&quot;,&quot;blue&quot;), label = ~NOM_COM) map On peut superposer plusieurs cartes de polygones à condition que certaines soient composée uniquement de lignes de contour (fill =) dont on peut régler l’épaisseur (weight=) ou la couleur (color =). Les labels ou popup ne pourront a priori concerner également qu’une seule couche. # Ajout de la variable couleur mapiris$comcolor&lt;-as.factor(mapiris$NOM_COM) levels(mapiris$comcolor)&lt;-c(&quot;red&quot;,&quot;orange&quot;,&quot;yellow&quot;,&quot;green&quot;,&quot;blue&quot;) # Réalisation de la carte map &lt;- leaflet() %&gt;% addProviderTiles(&#39;Esri.WorldTopoMap&#39;) %&gt;% setView(lat = 48.77, lng=2.53, zoom = 12) %&gt;% addPolygons(data = mapiris, fill = TRUE, color = ~comcolor, label = ~NOM_IRIS, weight = 1) %&gt;% addPolygons(data = mapcom, fill = FALSE, color = &quot;black&quot;, weight = 2) map 4.2.3 Cartes choroplèthes avec addPolygon() et colorBin() De la même manière que nous avons affiché la couleur des communes dans chaque IRIS, nous pouvons proposer une carte choroplèthe du % de personnes habitant dans des HLM et ajouter un popup donnant la valeur de l’indicateur si l’on clique. La seule difficulté est de préparer une palette de couleur à l’aide de l’une des fonction colorNumeric(), colorBin(), colorQuantile() ou colorFactor(). Voyons un exemple sur la variable pct_1 qui est le % de logements sociaux. Supposons que l’on veuille examiner la part des logements sociaux qui sont très supérieurs ou très inférieurs à 20% en prenant des classes qui suivent une progression géométrique : # Choix de la variable myvar &lt;-mapiris$pct_1 # Choix des classes mycut&lt;-c(0, 5, 10, 20,40,100) # Choix de la palette (c&#39;est une fonction !) mypal &lt;- colorBin(&#39;RdYlBu&#39;, myvar, bins=mycut) # Préparation des popups # mypop &lt;- lapply(seq(nrow(mapiris)), function(i) { # paste0( paste(&quot;Commune :&quot;,mapiris$NOM_COM[i]), &#39;&lt;p&gt;&#39;, # paste(&quot;Iris : &quot; ,mapiris$NOM_IRIS[i]), &#39;&lt;p&gt;&#39;, # paste(&quot;% pop. en HLM :&quot;, mapiris$pct_1[i]) # ) # }) # mypop&lt;-lapply(labs, htmltools::HTML) # Réalisation de la carte map &lt;- leaflet() %&gt;% addProviderTiles(&#39;Esri.WorldTopoMap&#39;) %&gt;% setView(lat = 48.77, lng=2.53, zoom = 12) %&gt;% addPolygons(data = mapiris, fillColor = ~mypal(pct_1), fillOpacity = 0.5, color = &quot;white&quot;, label = ~pct_1, # popup = mypop, weight = 1) %&gt;% addLegend(data = mapiris, pal = mypal, title = &quot;% population en HLM&quot;, values =~pct_1, position = &#39;topright&#39;) %&gt;% addPolygons(data = mapcom, fill = FALSE, color = &quot;black&quot;, weight = 2) map 4.2.4 Cartes de stock avec addCircleMarkers() Notre carte est intéressante mais elle ne permet pas de voir quelle est la population concernée par le logement social. En effet, certains IRIS sont très étendus alors qu’ils regroupent peu de population et d’autres sont très petits mais comporte beaucoup de logements sociaux. Ce qui est logique puisque les HLM sont le plus souvent des immeubles à plusieurs étages. Nous allons donc superposer sur la carte précédente le nombre de personnes vivant en logement social. Puisqu’il s’agit d’un stock, nous devrons utiliser un figuré ponctuel avec une surface proportionnelle au nombre d’habitants des logements sociaux. # Choix de la variable myvar &lt;-mapiris$pct_1 # Choix des classes mycut&lt;-c(0, 5, 10, 20,40,100) # Choix de la palette (c&#39;est une fonction !) mypal &lt;- colorBin(&#39;RdYlBu&#39;, myvar, bins=mycut) # Calcul du diamètre des cercles myradius &lt;-8*sqrt(mapiris$count_1/max(mapiris$count_1)) # Préparation des popups # mypop &lt;- lapply(seq(nrow(mapiris)), function(i) { # paste0( paste(&quot;Commune :&quot;,mapiris$NOM_COM[i]), &#39;&lt;p&gt;&#39;, # paste(&quot;Iris : &quot; ,mapiris$NOM_IRIS[i]), &#39;&lt;p&gt;&#39;, # paste(&quot;% pop. en HLM :&quot;, mapiris$pct_1[i]) # ) # }) # mypop&lt;-lapply(labs, htmltools::HTML) # Réalisation de la carte map &lt;- leaflet() %&gt;% addProviderTiles(&#39;Esri.WorldTopoMap&#39;) %&gt;% setView(lat = 48.77, lng=2.53, zoom = 12) %&gt;% addPolygons(data = mapiris, fillColor = ~mypal(pct_1), fillOpacity = 0.5, color = &quot;white&quot;, label = ~pct_1, # popup = mypop, weight = 1) %&gt;% addLegend(data = mapiris, pal = mypal, title = &quot;% population en HLM&quot;, values =~pct_1, position = &#39;topright&#39;) %&gt;% addCircleMarkers(data=mapiris, lat = ~lat, lng = ~lng, radius = myradius, stroke = FALSE, label = ~count_1, fillColor = &quot;gray50&quot;, fillOpacity = 0.5)%&gt;% addPolygons(data = mapcom, fill = FALSE, color = &quot;black&quot;, weight = 2) map 4.2.5 Finition avec un popup et highlightOptions() Et pour terminer notre belle carte, nous allons ajouter une fenêtre popup apportant à l’utilisateur tous les renseignements sur chaque IRIS. Pour cela nous allons devoir construire chaque fenêtre popup au format HTML préalablement à l’affichage des cartes en utilisant des outils issus sdes packaghes htmltoolset htmlwidgets. On supprime les labels des deux couches, l’utilisateur ayant désormais juste à cliquer sur un Iris pour obtenir tous les renseignements dans une seule fenêtre On ajoute au passage un paramètre highlighOptions() pour que les iris au dessus desquels passe la souris soient mis en valeur par un trait de contour spécifique. On verra ainsi mieux à quelle zone s’applique le popup de renseignement. # Choix de la variable myvar &lt;-mapiris$pct_1 # Choix des classes mycut&lt;-c(0, 5, 10, 20,40,100) # Choix de la palette (c&#39;est une fonction !) mypal &lt;- colorBin(&#39;RdYlBu&#39;, myvar, bins=mycut) # Calcul du diamètre des cercles myradius &lt;-8*sqrt(mapiris$count_1/max(mapiris$count_1)) # Préparation des popups mypopups &lt;- lapply(seq(nrow(mapiris)), function(i) { paste0( paste(&quot;Commune : &quot;,mapiris$NOM_COM[i]), &#39;&lt;br&gt;&#39;, paste(&quot;Iris : &quot; ,mapiris$NOM_IRIS[i]), &#39;&lt;br&gt;&#39;, paste(&quot;Population totale : &quot; ,mapiris$count_1[i]+mapiris$count_2[i]), &#39;&lt;br&gt;&#39;, paste(&quot;Population en HLM : &quot; ,mapiris$count_1[i]), &#39;&lt;br&gt;&#39;, paste(&quot;% pop. en HLM :&quot;, mapiris$pct_1[i]) ) }) mypopups&lt;-lapply(mypopups, htmltools::HTML) # Réalisation de la carte map &lt;- leaflet() %&gt;% addProviderTiles(&#39;Esri.WorldTopoMap&#39;) %&gt;% setView(lat = 48.77, lng=2.53, zoom = 13) %&gt;% addPolygons(data = mapiris, fillColor = ~mypal(pct_1), fillOpacity = 0.5, color = &quot;white&quot;, popup = mypopups, weight = 1, highlightOptions = highlightOptions(weight = 3, color = &#39;green&#39;)) %&gt;% addLegend(data = mapiris, pal = mypal, title = &quot;% population en HLM&quot;, values =~pct_1, position = &#39;topright&#39;) %&gt;% addCircleMarkers(data=mapiris, lat = ~lat, lng = ~lng, radius = myradius, stroke = FALSE, fillColor = &quot;gray50&quot;, fillOpacity = 0.5)%&gt;% addPolygons(data = mapcom, fill = FALSE, color = &quot;black&quot;, weight = 2) map "],["31-datamodel.html", "Chapitre 5 Modèle de données (CG) Objectif 5.1 tableau de contingence tab 5.2 Attributs sociologiques soc 5.3 Attributs géographiques geo 5.4 Assemblage et sauvegarde 5.5 Prolongements", " Chapitre 5 Modèle de données (CG) Ce cours propose de construire une structure de donnée permettant l’analyse à la fois sociologique et géographique des données individuelles qui ont fait l’objet des chapitres précédent. Ce modèle de donnée servira par la suite au développement d’applications shiny. Claude Grasland (Professeur à l’Université de Paris) Objectif L’objectif de ce chapitre est de construire une structure de données croisant une dimension spatiale \\(i\\) et une dimension sociale \\(j\\) à partir d’un comptage du nombre d’individus ou du nombre de ménages \\(X_{ij}\\) localisés dans l’unité spatiale \\(i\\) et ayant l’attribut sociologique \\(j\\). La structure de donnée devra permettre la représentation cartographique des résultats (ajout de la geométrie des unités spatiales \\(i\\)). Elle devra également permettre d’agréger les unités spatiale et sociales élémentaires vers des niveaux d’agrégation supérieur qu’on notera \\(i2,i3, ...\\) pour les niveaux géographiques et \\(j2,j3,...\\) pour les niveaux sociologiques. L’ensemble des données utiles devra être stockée dans un objet unique, si possible de petite taille, sous la forme d’une liste. Nous allons prendre comme exemple l’analyse de la distribution des CSP (variable CS1) par IRIS dans le Val-de-Marne lors du RP de 2017 pour les personnes âgées de 18 ans et plus 5.1 tableau de contingence tab Notre tableau de contingence ne contiendra que trois variables i : code géographique de l’IRIS j : code socioloqiue de la CSP Pij : effectif de personnes appartenant à la CSP i et résidant dans l’unité spatiale j La création sera effectuée par le programme suivant où l’on retire les personnes résidant dans des communes non découpées en IRIS. # Sélection des individus de 18 ans et + ind18 &lt;- readRDS(&quot;data/indiv2017.Rdata&quot;) %&gt;% filter(as.numeric(AGEREV)&gt;=18) %&gt;% filter(IRIS != &quot;ZZZZZZZZZ&quot;) # Création du tableau de contingence tab &lt;- ind18 %&gt;% select(i =IRIS, j = CS1, Xij = IPONDI) %&gt;% group_by(i,j) %&gt;% summarise(Xij = round(sum(Xij),0)) # Visualisation du résultat kable(head(tab)) i j Xij 940020101 2 97 940020101 3 421 940020101 4 480 940020101 5 428 940020101 6 263 940020101 7 292 5.2 Attributs sociologiques soc Nous avons besoin d’ajouter des renseignements sur les modalités sociologiques \\(j\\) que l’on va chercher dans le fichier des métadonnées. j : code de la modalité var_j : nom de la variable lab_j : label de la modalité j # Chargement du fichier des méta données meta &lt;- readRDS(&quot;data/indiv_2017_meta.Rdata&quot;) # Identification des modalités à extraire listmod &lt;- unique(tab$j) # extraction des informations soc&lt;-meta %&gt;% filter(COD_VAR == &quot;CS1&quot; ) %&gt;% filter(COD_MOD %in% listmod) %&gt;% select(j = COD_MOD, var_j = LIB_VAR, lab_j = LIB_MOD) kable(soc) j var_j lab_j 1 Catégorie socioprofessionnelle en 8 postes Agriculteurs exploitants 2 Catégorie socioprofessionnelle en 8 postes Artisans, commerçants et chefs d’entreprise 3 Catégorie socioprofessionnelle en 8 postes Cadres et professions intellectuelles supérieures 4 Catégorie socioprofessionnelle en 8 postes Professions Intermédiaires 5 Catégorie socioprofessionnelle en 8 postes Employés 6 Catégorie socioprofessionnelle en 8 postes Ouvriers 7 Catégorie socioprofessionnelle en 8 postes Retraités 8 Catégorie socioprofessionnelle en 8 postes Autres personnes sans activité professionnelle On peut ajouter à ce tableau un niveau d’agrégation supérieur en ajoutant une liste de variables : j2 : code d’agrégation var_j2 : nom de la variable agrégée lab_j2 : label des modalités de la variable agrégée soc$j2 &lt;-as.factor(soc$j) levels(soc$j2) &lt;-c(&quot;B&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;C&quot;,NA,NA) soc$var_j2 &lt;- &quot;CSP des actifs en 3 classes&quot; soc$lab_j2 &lt;-soc$j2 levels(soc$lab_j2) &lt;-list(&quot;Haut&quot; = &quot;A&quot;,&quot;Moyen&quot; = &quot;B&quot;,&quot;Bas&quot; = &quot;C&quot;) kable(soc) j var_j lab_j j2 var_j2 lab_j2 1 Catégorie socioprofessionnelle en 8 postes Agriculteurs exploitants B CSP des actifs en 3 classes Moyen 2 Catégorie socioprofessionnelle en 8 postes Artisans, commerçants et chefs d’entreprise A CSP des actifs en 3 classes Haut 3 Catégorie socioprofessionnelle en 8 postes Cadres et professions intellectuelles supérieures A CSP des actifs en 3 classes Haut 4 Catégorie socioprofessionnelle en 8 postes Professions Intermédiaires B CSP des actifs en 3 classes Moyen 5 Catégorie socioprofessionnelle en 8 postes Employés C CSP des actifs en 3 classes Bas 6 Catégorie socioprofessionnelle en 8 postes Ouvriers C CSP des actifs en 3 classes Bas 7 Catégorie socioprofessionnelle en 8 postes Retraités NA CSP des actifs en 3 classes NA 8 Catégorie socioprofessionnelle en 8 postes Autres personnes sans activité professionnelle NA CSP des actifs en 3 classes NA 5.3 Attributs géographiques geo Les attributs géographiques comportent le nom des unités spatiales observées, le nom et le code des unités spatiales de nbiveau supérieur (s’il y en a) et enfin la géométrie des unités spatiales. Soit la structure : i : code de l’unité géographique lab_i : nom de l’unité géographique i2 : code de l’unité géographique englobante (facultatif) lab_i2 : nom de l’unité géographique englobante (facultatif) lat : latitude du centroïde de l’unité géographique lng : longitude du centroïde de l’unité géographique geometry : contours de l’unité géographique s’il s’agit d’une surface en latitude longitude (WGS94 soit crs = 4326) # Chargement du fonds de carte et projection en WGS94 map &lt;- readRDS(&quot;data/map_iris.Rdata&quot;) %&gt;% st_as_sf() %&gt;% st_transform (crs=4326) # Définition de la liste des unités spatiales utiles listgeo &lt;- unique(tab$i) # Extraction et recodage des informations utiles geo &lt;-map %&gt;% select(i = CODE_IRIS, lab_i = NOM_IRIS, i2 = INSEE_COM, lab_i2 = NOM_COM, geometry) %&gt;% mutate(var_i = &quot;quartier IRIS&quot;, var_i2 = &quot;Communes&quot;) # Ajout des centroïdes coo &lt;- st_coordinates(st_centroid(geo)) geo$lng &lt;-coo[,1] geo$lat &lt;-coo[,2] kable(head(geo)) i lab_i i2 lab_i2 geometry var_i var_i2 lng lat 940210107 Sorbiers 94021 Chevilly-Larue MULTIPOLYGON (((2.357357 48… quartier IRIS Communes 2.357553 48.77377 940680204 Le Vieux Saint-Maur 4 94068 Saint-Maur-des-Fossés MULTIPOLYGON (((2.483923 48… quartier IRIS Communes 2.481153 48.80862 940810308 Robespierre 94081 Vitry-sur-Seine MULTIPOLYGON (((2.388071 48… quartier IRIS Communes 2.388817 48.79110 940760109 Centre Ville Est 94076 Villejuif MULTIPOLYGON (((2.368424 48… quartier IRIS Communes 2.367894 48.79224 940460105 Centre_Vert de Maison 5 94046 Maisons-Alfort MULTIPOLYGON (((2.433334 48… quartier IRIS Communes 2.433856 48.79129 940650105 Le Sud 94065 Rungis MULTIPOLYGON (((2.337343 48… quartier IRIS Communes 2.342378 48.74465 5.4 Assemblage et sauvegarde Il peut être intéressant d’ajouter à la liste des objets quelques variables supplémentaires comme la source, l’auteur et un bref résumé du contenu du tableau : count = &quot;Population 18 ans et +&quot; source = c(&quot;Source : INSEE - RP 2017 - Fichier individu &amp; IGN - Geofla - IRIS&quot;) author = &quot;Claude Grasland - contact : claude.grasland@parisgeo.cnrs.fr&quot; info = &quot;Fichier élaboré dans le cadre du projet Data Mining 2021 portant sur les CSP des individus de 18 ans et plus résidant dans le Val de Marne à l&#39;échelon des IRIS lors du RP 2017&quot; Pour éviter la prolifération des fichiers, on va assembler toutes nos composantes dans un unique objet servant de base de données à l’aide de la fonction list() : base = list(&quot;tab&quot; = tab, &quot;soc&quot; = soc, &quot;geo&quot; = geo, &quot;count&quot; = count, &quot;source&quot; = source, &quot;author&quot; = author, &quot;info&quot; = info) saveRDS(base,&quot;myproject/data/VDM_RP2017_CS1_IRIS_POP.rds&quot;) 5.5 Prolongements Notre base de donnée tient désormais dans un seul fichier qui ne pèse que 382 Ko et pourra être facilement mobilisé dans toute une série d’applications de visualisation statistique ou cartographique interactives. On peut évidemment créer autant de bases que l’on veut selon le même format, ce qui permettra de standardiser les procédures d’exploitation ultérieures. On va créer à titre d’exemple un second fichier donnant le mode de transport le plus souvent utilisé pour se rendre au travail pour les personnes mobiles # Sélection des personnes mobiles mob &lt;- readRDS(&quot;data/indiv2017.Rdata&quot;) %&gt;% filter(TRANS!=&quot;Z&quot;) %&gt;% # Elimine les personnes non concernées filter(TRANS!=&quot;1&quot;) %&gt;% # Elimine les actifs non mobiles filter(IRIS != &quot;ZZZZZZZZZ&quot;) # ---------------------------------------- # Création du tableau de contingence tab &lt;- mob %&gt;% select(i =IRIS, j = TRANS, Xij = IPONDI) %&gt;% group_by(i,j) %&gt;% summarise(Xij = round(sum(Xij),0)) # Visualisation du résultat kable(head(tab)) i j Xij 940020101 2 102 940020101 3 56 940020101 4 53 940020101 5 424 940020101 6 769 940020102 2 103 #---------------------------------------------- # Chargement du fichier des méta données meta &lt;- readRDS(&quot;data/indiv_2017_meta.Rdata&quot;) # Identification des modalités à extraire listmod &lt;- unique(tab$j) # extraction des informations soc&lt;-meta %&gt;% filter(COD_VAR == &quot;TRANS&quot; ) %&gt;% filter(COD_MOD %in% listmod) %&gt;% select(j = COD_MOD, var_j = LIB_VAR, lab_j = LIB_MOD) # Agrégation en modes &quot;doux&quot; et &quot;dur&quot; soc$j2 &lt;-as.factor(soc$j) levels(soc$j2) [1] &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; levels(soc$j2) &lt;-c(&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;C&quot;) soc$var_j2 &lt;- &quot;Modes de déplacement en 3 classes&quot; soc$lab_j2 &lt;-soc$j2 levels(soc$lab_j2) &lt;-list(&quot;Marche ou en vélo&quot; = &quot;A&quot;,&quot;Véhicule à moteur&quot; = &quot;B&quot;,&quot;Transports en commun&quot; = &quot;C&quot;) kable(soc) j var_j lab_j j2 var_j2 lab_j2 2 Mode de transport principal le plus souvent utilisé pour aller travailler Marche à pied (ou rollers, patinette) A Modes de déplacement en 3 classes Marche ou en vélo 3 Mode de transport principal le plus souvent utilisé pour aller travailler Vélo (y compris à assistance électrique) A Modes de déplacement en 3 classes Marche ou en vélo 4 Mode de transport principal le plus souvent utilisé pour aller travailler Deux-roues motorisé B Modes de déplacement en 3 classes Véhicule à moteur 5 Mode de transport principal le plus souvent utilisé pour aller travailler Voiture, camion, fourgonnette B Modes de déplacement en 3 classes Véhicule à moteur 6 Mode de transport principal le plus souvent utilisé pour aller travailler Transports en commun C Modes de déplacement en 3 classes Transports en commun #-------------------------------------------- # Chargement du fonds de carte et projection en WGS94 map &lt;- readRDS(&quot;data/map_iris.Rdata&quot;) %&gt;% st_as_sf() %&gt;% st_transform (crs=4326) # Définition de la liste des unités spatiales utiles listgeo &lt;- unique(tab$i) # Extraction et recodage des informations utiles geo &lt;-map %&gt;% select(i = CODE_IRIS, lab_i = NOM_IRIS, i2 = INSEE_COM, lab_i2 = NOM_COM, geometry) %&gt;% mutate(var_i = &quot;quartier IRIS&quot;, var_i2 = &quot;Communes&quot;) # Ajout des centroïdes coo &lt;- st_coordinates(st_centroid(geo)) geo$lng &lt;-coo[,1] geo$lat &lt;-coo[,2] kable(head(geo)) i lab_i i2 lab_i2 geometry var_i var_i2 lng lat 940210107 Sorbiers 94021 Chevilly-Larue MULTIPOLYGON (((2.357357 48… quartier IRIS Communes 2.357553 48.77377 940680204 Le Vieux Saint-Maur 4 94068 Saint-Maur-des-Fossés MULTIPOLYGON (((2.483923 48… quartier IRIS Communes 2.481153 48.80862 940810308 Robespierre 94081 Vitry-sur-Seine MULTIPOLYGON (((2.388071 48… quartier IRIS Communes 2.388817 48.79110 940760109 Centre Ville Est 94076 Villejuif MULTIPOLYGON (((2.368424 48… quartier IRIS Communes 2.367894 48.79224 940460105 Centre_Vert de Maison 5 94046 Maisons-Alfort MULTIPOLYGON (((2.433334 48… quartier IRIS Communes 2.433856 48.79129 940650105 Le Sud 94065 Rungis MULTIPOLYGON (((2.337343 48… quartier IRIS Communes 2.342378 48.74465 #---------------------------------------------- count = &quot;Actifs mobiles&quot; source = c(&quot;Source : INSEE - RP 2017 - Fichier individu &amp; IGN - Geofla - IRIS&quot;) author = &quot;Claude Grasland - contact : claude.grasland@parisgeo.cnrs.fr&quot; info = &quot;Fichier élaboré dans le cadre du projet Data Mining 2021 portant sur déplacements des actifs mobiles résidant dans le Val de Marne à l&#39;échelon des IRIS lors du RP 2017&quot; base = list(&quot;tab&quot; = tab, &quot;soc&quot; = soc, &quot;geo&quot; = geo, &quot;count&quot; = count, &quot;source&quot; = source, &quot;author&quot; = author, &quot;info&quot; = info) saveRDS(base,&quot;myproject/data/VDM_RP2017_TRANS_IRIS_ACT.rds&quot;) Puis un fichier de l’ancienneté d’installation des ménages dans leur logement actuel, ce qui donnera une idée transversale de leur mobilité. # Sélection des ménages ordinaires mob &lt;- readRDS(&quot;data/indiv2017.Rdata&quot;) %&gt;% filter(LPRM==&quot;1&quot;) %&gt;% # sélectionne les ménages ordinaires filter(ANEMR!=&quot;ZZ&quot;) %&gt;% # élimine les personnes non concernées filter(IRIS != &quot;ZZZZZZZZZ&quot;) # ---------------------------------------- # Création du tableau de contingence tab &lt;- mob %&gt;% select(i =IRIS, j = ANEMR, Xij = IPONDI) %&gt;% group_by(i,j) %&gt;% summarise(Xij = round(sum(Xij),0)) # Visualisation du résultat kable(head(tab)) i j Xij 940020101 00 269 940020101 01 411 940020101 02 503 940020101 03 169 940020101 04 72 940020101 05 40 #---------------------------------------------- # Chargement du fichier des méta données meta &lt;- readRDS(&quot;data/indiv_2017_meta.Rdata&quot;) # Identification des modalités à extraire listmod &lt;- unique(tab$j) # extraction des informations soc&lt;-meta %&gt;% filter(COD_VAR == &quot;ANEMR&quot; ) %&gt;% filter(COD_MOD %in% listmod) %&gt;% select(j = COD_MOD, var_j = LIB_VAR, lab_j = LIB_MOD) # Agrégation en modes &quot;doux&quot; et &quot;dur&quot; soc$j2 &lt;-as.factor(soc$j) levels(soc$j2) [1] &quot;00&quot; &quot;01&quot; &quot;02&quot; &quot;03&quot; &quot;04&quot; &quot;05&quot; &quot;06&quot; &quot;07&quot; &quot;08&quot; &quot;09&quot; levels(soc$j2) &lt;-c(&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;C&quot;,&quot;C&quot;,&quot;C&quot;,&quot;C&quot;,&quot;C&quot;,&quot;C&quot;) soc$var_j2 &lt;- &quot;Ancienneté d&#39;emménagement en 3 classes&quot; soc$lab_j2 &lt;-soc$j2 levels(soc$lab_j2) &lt;-list(&quot;Moins de 4 ans&quot; = &quot;A&quot;,&quot;5 à 19 ans&quot; = &quot;B&quot;,&quot;20 ans et plus&quot; = &quot;C&quot;) kable(soc) j var_j lab_j j2 var_j2 lab_j2 00 Ancienneté d’emménagement dans le logement (regroupée) Moins de 2 ans A Ancienneté d’emménagement en 3 classes Moins de 4 ans 01 Ancienneté d’emménagement dans le logement (regroupée) De 2 à 4 ans A Ancienneté d’emménagement en 3 classes Moins de 4 ans 02 Ancienneté d’emménagement dans le logement (regroupée) De 5 à 9 ans B Ancienneté d’emménagement en 3 classes 5 à 19 ans 03 Ancienneté d’emménagement dans le logement (regroupée) De 10 à 19 ans B Ancienneté d’emménagement en 3 classes 5 à 19 ans 04 Ancienneté d’emménagement dans le logement (regroupée) De 20 à 29 ans C Ancienneté d’emménagement en 3 classes 20 ans et plus 05 Ancienneté d’emménagement dans le logement (regroupée) De 30 à 39 ans C Ancienneté d’emménagement en 3 classes 20 ans et plus 06 Ancienneté d’emménagement dans le logement (regroupée) De 40 à 49 ans C Ancienneté d’emménagement en 3 classes 20 ans et plus 07 Ancienneté d’emménagement dans le logement (regroupée) De 50 à 59 ans C Ancienneté d’emménagement en 3 classes 20 ans et plus 08 Ancienneté d’emménagement dans le logement (regroupée) De 60 à 69 ans C Ancienneté d’emménagement en 3 classes 20 ans et plus 09 Ancienneté d’emménagement dans le logement (regroupée) 70 ans ou plus C Ancienneté d’emménagement en 3 classes 20 ans et plus #-------------------------------------------- # Chargement du fonds de carte et projection en WGS94 map &lt;- readRDS(&quot;data/map_iris.Rdata&quot;) %&gt;% st_as_sf() %&gt;% st_transform (crs=4326) # Définition de la liste des unités spatiales utiles listgeo &lt;- unique(tab$i) # Extraction et recodage des informations utiles geo &lt;-map %&gt;% select(i = CODE_IRIS, lab_i = NOM_IRIS, i2 = INSEE_COM, lab_i2 = NOM_COM, geometry) %&gt;% mutate(var_i = &quot;quartier IRIS&quot;, var_i2 = &quot;Communes&quot;) # Ajout des centroïdes coo &lt;- st_coordinates(st_centroid(geo)) geo$lng &lt;-coo[,1] geo$lat &lt;-coo[,2] kable(head(geo)) i lab_i i2 lab_i2 geometry var_i var_i2 lng lat 940210107 Sorbiers 94021 Chevilly-Larue MULTIPOLYGON (((2.357357 48… quartier IRIS Communes 2.357553 48.77377 940680204 Le Vieux Saint-Maur 4 94068 Saint-Maur-des-Fossés MULTIPOLYGON (((2.483923 48… quartier IRIS Communes 2.481153 48.80862 940810308 Robespierre 94081 Vitry-sur-Seine MULTIPOLYGON (((2.388071 48… quartier IRIS Communes 2.388817 48.79110 940760109 Centre Ville Est 94076 Villejuif MULTIPOLYGON (((2.368424 48… quartier IRIS Communes 2.367894 48.79224 940460105 Centre_Vert de Maison 5 94046 Maisons-Alfort MULTIPOLYGON (((2.433334 48… quartier IRIS Communes 2.433856 48.79129 940650105 Le Sud 94065 Rungis MULTIPOLYGON (((2.337343 48… quartier IRIS Communes 2.342378 48.74465 #---------------------------------------------- count= &quot;Ménages&quot; source = c(&quot;Source : INSEE - RP 2017 - Fichier individu &amp; IGN - Geofla - IRIS&quot;) author = &quot;Claude Grasland - contact : claude.grasland@parisgeo.cnrs.fr&quot; info = &quot;Fichier élaboré dans le cadre du projet Data Mining 2021 portant sur l&#39;ancienneté d&#39;instalklation des ménages résidant dans le Val de Marne à l&#39;échelon des IRIS lors du RP 2017&quot; base = list(&quot;tab&quot; = tab, &quot;soc&quot; = soc, &quot;geo&quot; = geo, &quot;count&quot; = count, &quot;source&quot; = source, &quot;author&quot; = author, &quot;info&quot; = info) saveRDS(base,&quot;myproject/data/VDM_RP2017_ANEMR_IRIS_MEN.rds&quot;) "],["32-functions.html", "Chapitre 6 Fonctions Objectif 6.1 Fonctions de sélection 6.2 Fonctions d’agrégation 6.3 Fonctions de normalisation", " Chapitre 6 Fonctions Un modèle de donnée n’a d’intérêt que s’il est conçu en fonction d’objectifs qui seront réalisés à l’aide de fonctions exploitant les possibilités du modèle de donnée. Nous allons montrer ici à l’aide de quelques exemples simples l’intérêt du modèle de donnée défini au chapitre précédent. Objectif L’objectif de ce chapitre est de construire une série de fonctions exploitant le modèle de donnée défini précédemment que nous appellerons base. Pour bien mettre en évidence le fait que les fonctions dépendent de ce modèle de données, on leur donnera des noms qui commenceront toujours par ce radical suivi de suffixes. Plus précisément on définira une arborescence de fonctions à l’aide de suffixes de précision croissante. On se place ainsi dans une logique de création d’un package pouvant encapsuler à terme ces différentes fonctions (mais cela dépasse le cadre de ce cours). Les fonctions doivent pouvoir s’applique à n’importe quelle base de données suivant le modèle prescrit. On les testera donc sur au moins trois bases différentes portant respectivement sur les individus âgés de de 18 ans et plus, les actifs mobiles et les ménages ordinaires csp94 : base de données des individus âgés de 18 ans et plus par CSP et par IRIS au RP 2017, contenue dans le fichier VDM_RP2017_CS1_IRIS_POP.Rdata. tra94 : base de données des actifs mobiles et par IRIS selon le mode de transport au 2017, contenue dans le fichier VDM_RP2017_TRANS_IRIS_ACT.Rdata anc94 : base de données des ménages et par IRIS en fonction de l’ancienneté d’installation dans le logement au RP2017, contenue dans le fichier VDM_RP2017_ANEMR_IRIS_MEN.Rdata csp94 &lt;- readRDS(&quot;myproject/data/VDM_RP2017_CS1_IRIS_POP.rds&quot;) tra94 &lt;- readRDS(&quot;myproject/data/VDM_RP2017_TRANS_IRIS_ACT.rds&quot;) anc94 &lt;- readRDS(&quot;myproject/data/VDM_RP2017_ANEMR_IRIS_MEN.rds&quot;) 6.1 Fonctions de sélection Les fonctions utilitaires permettent de transformer une base en une autre base en filtrant ou agrégeant des données selon les dimensions sociales ou spatiales. Le résultat est obligatoirement une base de même type que la base d’origine. 6.1.1 Sélection géographique base_select_geo() On peut tout d’abord effectuer une sélection géographique en ne conservant que certains IRIS. La sélection peut s’effectuer par défaut sur les unités géographique de base i mais elle peut aussi utiliser n’importe quelle variable du fichier geo, notamment les niveaux d’agrégation supérieurs ce qui est en général plus pratique. Pour cela on va commencer par modifier le fichier geo puis le fichier tab et enfin le fichier soc afin d’y éliminer les catégories éventuellement absentes de la zone d’étude. base_select_geo &lt;- function(base = base, var = i2, sel = c(&quot;Geo1&quot;,&quot;Geo2&quot;,&quot;Geo3&quot;)) { b&lt;-base b$geo&lt;- b$geo %&gt;% filter({{var}} %in% sel) b$tab&lt;- b$tab %&gt;% filter(i %in% b$geo$i) b$soc &lt;- b$soc %&gt;% filter(j %in% unique(b$tab$j)) return(b) } Essayons d’appliquer notre fonction à l’extraction des CSP de la commune de Sucy-en-Brie : csp_sucy &lt;- base_select_geo(base = csp94, var = i2, sel = &quot;94071&quot;) On peut vérifier que les trois fichiers ont été modifiés dans la nouvelle base. kable(head(csp_sucy$tab,3)) i j Xij 940710101 2 99 940710101 3 367 940710101 4 269 kable(head(csp_sucy$geo,3)) i lab_i i2 lab_i2 geometry var_i var_i2 lng lat 940710107 Notre Dame … Bruyeres 94071 Sucy-en-Brie MULTIPOLYGON (((2.557576 48… quartier IRIS Communes 2.562682 48.75904 940710103 La Cite Verte 94071 Sucy-en-Brie MULTIPOLYGON (((2.525385 48… quartier IRIS Communes 2.521975 48.77332 940710102 La Fosse Rouge 94071 Sucy-en-Brie MULTIPOLYGON (((2.534443 48… quartier IRIS Communes 2.527384 48.77628 kable(head(csp_sucy$soc,3)) j var_j lab_j j2 var_j2 lab_j2 2 Catégorie socioprofessionnelle en 8 postes Artisans, commerçants et chefs d’entreprise A CSP des actifs en 3 classes Haut 3 Catégorie socioprofessionnelle en 8 postes Cadres et professions intellectuelles supérieures A CSP des actifs en 3 classes Haut 4 Catégorie socioprofessionnelle en 8 postes Professions Intermédiaires B CSP des actifs en 3 classes Moyen 6.1.2 Sélection sociologique base_select_soc() On peut tout effectuer l’opération symétrique sur les données sociologiques Pour cela on va commencer par modifier le fichier soc puis le fichier tab et enfin le fichier geopour éliminer les unités spatiales où l’ensemble des catégories ciblées sont absentes. base_select_soc &lt;- function(base = base, var = j2, sel = c(&quot;Cat1&quot;,&quot;Cat2&quot;,&quot;Cat3&quot;)) { b&lt;-base b$soc&lt;- b$soc %&gt;% filter({{var}} %in% sel) b$tab&lt;- b$tab %&gt;% filter(j %in% b$soc$j) b$geo &lt;- b$geo %&gt;% filter(i %in% unique(b$tab$i)) return(b) } A titre d’exemple on ne va conserver que les deux modes de transport doux (marche et vélo) dans le fichier des déplacements des actifs : tra_doux &lt;- base_select_soc(base = tra94, var = j2, sel = &quot;A&quot;) On peut vérifier que les trois fichiers ont été modifiés dans la nouvelle base. kable(head(tra_doux$tab,4)) i j Xij 940020101 2 102 940020101 3 56 940020102 2 103 940020102 3 37 kable(head(tra_doux$geo,3)) i lab_i i2 lab_i2 geometry var_i var_i2 lng lat 940210107 Sorbiers 94021 Chevilly-Larue MULTIPOLYGON (((2.357357 48… quartier IRIS Communes 2.357553 48.77377 940680204 Le Vieux Saint-Maur 4 94068 Saint-Maur-des-Fossés MULTIPOLYGON (((2.483923 48… quartier IRIS Communes 2.481153 48.80862 940810308 Robespierre 94081 Vitry-sur-Seine MULTIPOLYGON (((2.388071 48… quartier IRIS Communes 2.388817 48.79110 kable(head(tra_doux$soc,3)) j var_j lab_j j2 var_j2 lab_j2 2 Mode de transport principal le plus souvent utilisé pour aller travailler Marche à pied (ou rollers, patinette) A Modes de déplacement en 3 classes Marche ou en vélo 3 Mode de transport principal le plus souvent utilisé pour aller travailler Vélo (y compris à assistance électrique) A Modes de déplacement en 3 classes Marche ou en vélo 6.2 Fonctions d’agrégation 6.2.1 Agrégation géographique base_agreg_geo()) Supposons maintenant que l’on veuille transformer notre base de donnée pour la faire passer du niveau des IRIS (i) à celui des communes (i2). Cela va entraîner une modification des fichiers tab et geo mais pas du fichier soc qui demeurera identique. Noter que l’on doir reprojeter les données avant de calculer les centres de polygones et de les agréger base_agreg_geo &lt;- function(base = base, var = i2, lab = lab_i2) { b&lt;-base key &lt;- b$geo %&gt;% select(i, {{var}}) b$tab &lt;-b$tab %&gt;% left_join(key) %&gt;% group_by({{var}},j) %&gt;% mutate(i = as.factor({{var}}),j = j,Xij = sum(Xij)) %&gt;% ungroup()%&gt;% select(i,j,Xij) b$geo &lt;- b$geo %&gt;% st_transform(crs = 2154) %&gt;% mutate(i = {{var}}, lab_i = {{lab}}) %&gt;% group_by(i) %&gt;% summarize(lab_i = unique(lab_i), lat = mean(lat), lng=mean(lng)) %&gt;% ungroup() %&gt;% st_transform(crs = 4326)%&gt;% st_as_sf() return(b) } Appliquons ceci au fichier CSP des IRIS. On obtient une nouvelle base par CSP mais au niveau des communes. Il y a un message d’avertissement concernant l’agrégation des unités spatiales qu’il vaut normalement mieux effectuer après une projection planaire. com &lt;-base_agreg_geo(base = csp94, var = i2, lab = lab_i2) kable(head(com$tab)) i j Xij 94002 2 1030 94002 3 5746 94002 4 6251 94002 5 6783 94002 6 3439 94002 7 5959 kable(head(com$geo)) i lab_i lat lng geometry 94001 Ablon-sur-Seine 48.72462 2.421236 MULTIPOLYGON (((2.43501 48…. 94002 Alfortville 48.79967 2.421002 POLYGON ((2.433383 48.78383… 94003 Arcueil 48.80620 2.333503 POLYGON ((2.343535 48.79781… 94004 Boissy-Saint-Léger 48.75209 2.509456 POLYGON ((2.516929 48.73853… 94011 Bonneuil-sur-Marne 48.77062 2.482723 POLYGON ((2.476012 48.76572… 94015 Bry-sur-Marne 48.83884 2.523050 POLYGON ((2.518283 48.829, … 6.2.2 Agrégation sociologique base_agreg_soc() On reproduit un code équivalent pour procéder à une agrégation des catégories sociales base_agreg_soc &lt;- function(base = base, var = j2, lab = lab_j2) { b&lt;-base key &lt;- b$soc %&gt;% select(j, {{var}}) b$tab &lt;-b$tab %&gt;% left_join(key) %&gt;% group_by(i,{{var}}) %&gt;% mutate(i =i, j= as.factor({{var}}),Xij = sum(Xij)) %&gt;% ungroup()%&gt;% select(i,j,Xij) b$soc &lt;- b$soc %&gt;% mutate(j = {{var}}, lab_j = {{lab}}) %&gt;% select(j,lab_j) return(b) } Appliquons ceci au fichier CSP des IRIS pour le regrouper en 3 catégories. csp3 &lt;-base_agreg_soc(base = csp94, var = j2, lab= lab_j2) kable(head(csp3$tab)) i j Xij 940020101 A 518 940020101 A 518 940020101 B 480 940020101 C 691 940020101 C 691 940020101 NA 695 kable(head(csp3$soc)) j lab_j B Moyen A Haut A Haut B Moyen C Bas C Bas 6.3 Fonctions de normalisation Les fonctions de normalisation sont destinées à transformer les données absolues de comptage en donnée relatives de proportion d’un total pouvant être celui de la ligne (unités spatiales) ou de la colonne (unités sociales). Elles peuvent s’appliquer selon le cas à une variable ou un tableau. 6.3.1 Normalisation géographique base_norm_geo() Cette fonction permet d’exprimer les modalités de la variable en % du total des unités géographiques. Elle va essentiellement modifier le fichier tabauquel on va adjoindre deux colonnes : Xi = effectif total de l’unité spatiale Pj_i = Xij/Xi = proportion de i dans j base_norm_geo &lt;- function(base = base) { b &lt;- base tab_i &lt;- b$tab %&gt;% group_by(i) %&gt;% summarize(Xi = sum(Xij)) b$tab &lt;-b$tab %&gt;% left_join(tab_i) %&gt;% mutate(Pj_i = Xij/Xi) return(b) } Par exemple : csp94_geo &lt;- base_norm_geo(csp94) head(csp94_geo$tab) # A tibble: 6 x 5 i j Xij Xi Pj_i &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 940020101 2 97 2384 0.0407 2 940020101 3 421 2384 0.177 3 940020101 4 480 2384 0.201 4 940020101 5 428 2384 0.180 5 940020101 6 263 2384 0.110 6 940020101 7 292 2384 0.122 6.3.2 Normalisation sociologique base_norm_soc() Cette fonction permet d’exprimer les modalités de la variable en % du total des catagories sociales. Elle va donc également modifier le fichier tab et lui adjoindre deux autres colonnes : Xj = effectif total de la catégorie Pi_j = Xij/Xi = proportion de j dans i base_norm_soc &lt;- function(base = base) { b &lt;- base tab_j &lt;- b$tab %&gt;% group_by(j) %&gt;% summarize(Xj = sum(Xij)) b$tab &lt;-b$tab %&gt;% left_join(tab_j) %&gt;% mutate(Pi_j = Xij/Xj) return(b) } par exemple : csp94_soc &lt;- base_norm_soc(csp94) kable(head(csp94_soc$tab)) i j Xij Xj Pi_j 940020101 2 97 34283 0.0028294 940020101 3 421 173525 0.0024262 940020101 4 480 178808 0.0026844 940020101 5 428 195921 0.0021846 940020101 6 263 96247 0.0027326 940020101 7 292 214956 0.0013584 6.3.3 Normalisation statistique base_norm_stat() Si on veut effectuer une analyse des anomalies statistiques à l’intérieur du tableau, on effectue la double normalisation géographique et sociologique puis on calcule la valeur théorique E_ijsous hypothèse d’indépendance des variables sociologiques et géographiques. On en déduit le résidu R_ij qui mesure les sur et sous-représentation des individus ainsi que le chi-2 correspondant K2_ij. base_norm_stat &lt;- function(base=base) { b&lt;-base b&lt;-base_norm_geo(b) b&lt;-base_norm_soc(b) b$tab&lt;-b$tab %&gt;% mutate(Eij = Xi * Xj/sum(Xj), Rij = Xij-Eij, K2ij = (Rij**2)/Eij) return(b) } par exemple : csp94_stat &lt;- base_norm_stat(csp94) kable(head(csp94_stat$tab)) i j Xij Xi Pj_i Xj Pi_j Eij Rij K2ij 940020101 2 97 2384 0.0406879 34283 0.0028294 76.68352 20.31648 5.3826367 940020101 3 421 2384 0.1765940 173525 0.0024262 388.13719 32.86281 2.7824299 940020101 4 480 2384 0.2013423 178808 0.0026844 399.95409 80.04591 16.0202065 940020101 5 428 2384 0.1795302 195921 0.0021846 438.23210 -10.23210 0.2389052 940020101 6 263 2384 0.1103188 96247 0.0027326 215.28333 47.71667 10.5762049 940020101 7 292 2384 0.1224832 214956 0.0013584 480.80920 -188.80920 74.1435795 "]]

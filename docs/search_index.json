[["21-cartography.html", "Chapitre 3 Analyse cartographique I (C.G.) 3.1 Introduction 3.2 Le package cartography 3.3 Création de fonctions", " Chapitre 3 Analyse cartographique I (C.G.) 3.1 Introduction L’objectif de cette section est d’apprendre à réaliser des cartographies statiques d’indicateurs relatifs aux unités spatiales à différentes échelles à l’aide du package cartography. de créer des fonctions permetant d’automatiser la tâche de cartographie à l’échelle des communes 3.1.1 Packages utilisés Nous allons nous limiter à un nombre limité de packages dplyr et tidyr: pour la manipulation des tableaux et leur agrégation (inutile de charger l’ensemble du package tidyverse) knitr : pour afficher proprement les tableaux de résultats ggplot2 : pour visualiser les résultats sous formes de graphiques sf : pour manipuler les données cartographiques et les agréger cartography : pour la réalisation de cartes statiques de qualité imprimables aux formats .pdf ou .doc library(knitr) library(tidyr) library(dplyr) library(ggplot2) library(sf) library(cartography) 3.1.2 Chargement des données Nous avons besoin uniquement de trois fichiers Le fichier des individus le fichier des métadonnées relatives aux individus le fonds de carte des IRIS indiv &lt;- readRDS(&quot;data/indiv2017.Rdata&quot;) meta &lt;- readRDS(&quot;data/indiv2017_meta.Rdata&quot;) map &lt;-readRDS(&quot;data/map_iris.Rdata&quot;) 3.2 Le package cartography Le package cartography permet de réaliser des cartes statiques de très haute qualité. Il a en effet été mis au point par des cartographes et des géomaticiens professionnels. Il propose une gamme de possibilités sans équivalent. On ne verra ici qu’une toute petite partie de ses possibilités. Nous allons prendre comme exemple l’analyse d’un tableau du nombre d’automobiles par ménage en nous limitant aux ménages ordinaires c’est-à-dire en excluant les personnes habitant dans des logements collectifs (pensionnats, prisons, congrégations religieuses, …) Nous ne conservons que les individus chefs de ménages (LPRM=1) ce qui va logiquement éliminer les individus présents dans les ménages non ordinaires (LPRM=Z) ainsi que tous les membres d’un logement qui ne sont pas chefs de ménages. menag&lt;-indiv %&gt;% filter(LPRM==1) 3.2.1 Création du tableau de contingence Nous souhaitons ventiler les ménages en fonction de leur localisation géographique (IRIS) et de leur nombre d’automobile (VOIT) en tenant compte de leur poids (IPONDI) puisque les données sont issues d’uin échantillonage qu’il faut redresser. Cette opération se réalise très facilement à l’aide du package dplyr à l’aide des fonctions group_by, mutate et summarize : tab &lt;- menag %&gt;% group_by(IRIS, VOIT) %&gt;% summarise(nbmen = sum(IPONDI)) %&gt;% ungroup() `summarise()` regrouping output by &#39;IRIS&#39; (override with `.groups` argument) str(tab) tibble [2,070 × 3] (S3: tbl_df/tbl/data.frame) $ IRIS : Factor w/ 4243 levels &quot;751010101&quot;,&quot;751010102&quot;,..: 3300 3300 3300 3300 3301 3301 3301 3301 3302 3302 ... $ VOIT : Factor w/ 5 levels &quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,..: 1 2 3 4 1 2 3 4 1 2 ... $ nbmen: num [1:2070] 674.1 679.5 142.2 29.5 801.4 ... head(tab,5) # A tibble: 5 x 3 IRIS VOIT nbmen &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; 1 940020101 0 674. 2 940020101 1 679. 3 940020101 2 142. 4 940020101 3 29.5 5 940020102 0 801. Le résultat est un tibble au format “long” qui comporte 4 lignes différentes pour chaque IRIS, correspondant aux nombres de ménages ayant respectivement 0, 1, 2 et 3 voitures ou plus. Nous allons transformer ce tableau en format “large” pour placer côte à côte les différentes modalités du nombre de voitures. Pour cela il faut utiliser la fonction pivot_widerdu package tidyr. library(tidyr) tabcont &lt;- tab %&gt;% pivot_wider(names_from = VOIT, values_from = nbmen, names_prefix = &quot;MEN_VOIT&quot;, values_fill = 0) head(tabcont) # A tibble: 6 x 5 IRIS MEN_VOIT0 MEN_VOIT1 MEN_VOIT2 MEN_VOIT3 &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 940020101 674. 679. 142. 29.5 2 940020102 801. 903. 170. 24.8 3 940020103 661. 703. 76.0 10.6 4 940020104 694. 701. 126. 23.0 5 940020105 434. 960. 237. 29.3 6 940020106 625. 735. 166. 29.2 Grâce à cette transformation, nous disposons maintenant pour chaque IRIS de la distribution des ménages en fonction de leur nombre de voitures, ce qui constitue le tableau de contingence recherché. 3.2.2 Ajout d’un tableau de pourcentage Nous allons maintenant calculer le nombre total de ménage puis en déduire la proportion de ménages en fonction de leur nombre d’automobile pour chacun des IRIS. tabdon &lt;- tabcont %&gt;% mutate (MEN_TOTAL = MEN_VOIT0+MEN_VOIT1+MEN_VOIT2+MEN_VOIT3, PCT_VOIT0 = 100* MEN_VOIT0 / MEN_TOTAL, PCT_VOIT1 = 100* MEN_VOIT1 / MEN_TOTAL, PCT_VOIT2 = 100* MEN_VOIT2 / MEN_TOTAL, PCT_VOIT3 = 100* MEN_VOIT3 / MEN_TOTAL) head(tabdon[,c(1,6:10)]) # A tibble: 6 x 6 IRIS MEN_TOTAL PCT_VOIT0 PCT_VOIT1 PCT_VOIT2 PCT_VOIT3 &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 940020101 1525. 44.2 44.5 9.32 1.93 2 940020102 1899. 42.2 47.6 8.93 1.31 3 940020103 1450. 45.6 48.5 5.24 0.729 4 940020104 1544. 45.0 45.4 8.14 1.49 5 940020105 1660. 26.1 57.8 14.3 1.76 6 940020106 1555. 40.2 47.3 10.7 1.87 3.2.3 Estimation du nombre moyen d’automobile par menages Il n’est pas possible d’estimer le nombre exact d’automobile par ménage car l’INSEE ne détaille pas la catégorie VOIT = 3 qui correspond à “Trois automobiles ou +”. On peut néanmoins procéder à une estimation minimale du nombre d’automobile en supposant que les ménages de ce type ont exactement rois automobiles. On en déduit alors le nombre total d’automobile par IRIS (VOIT_TOTAL) et le nombre moyen d’automobile par ménage (VOIT_MEN). tabdon &lt;-tabdon %&gt;% mutate(VOIT_TOTAL = MEN_VOIT1 + 2*MEN_VOIT2 + 3*MEN_VOIT3, VOIT_MEN = VOIT_TOTAL / MEN_TOTAL) head(tabdon[,c(1,6,11,12)]) # A tibble: 6 x 4 IRIS MEN_TOTAL VOIT_TOTAL VOIT_MEN &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 940020101 1525. 1052. 0.690 2 940020102 1899. 1317. 0.694 3 940020103 1450. 886. 0.611 4 940020104 1544. 1021. 0.662 5 940020105 1660. 1522. 0.917 6 940020106 1555. 1154. 0.742 3.2.4 Analyse statistique Avant de passer à la cartographie, on peut analyser quelques variables intéressantes. 3.2.4.1 Part des ménages sans automobiles Les ménages sans automobiles sont une catégorie intéressante, même si elle peut recouper des situations très diverses (étudiants, personnes âgées, pauvres, …). summary(tabdon$PCT_VOIT0) Min. 1st Qu. Median Mean 3rd Qu. Max. 0.00 21.94 30.95 31.13 40.84 65.31 ggplot(tabdon, aes(x=PCT_VOIT0)) + geom_histogram(bins=20, fill=&quot;gray30&quot;) + scale_y_continuous(&quot;Nombre d&#39;IRIS&quot;)+ scale_x_continuous(&quot;% de ménages&quot;)+ ggtitle(&quot;Par des ménages sans automobiles en 2017&quot;) La distribution apparaît très variable puisque les ménages sans automobiles sont absents de certains IRIS alors qu’ils représentent plus de la moitié des ménages dans d’autres IRIS. 3.2.4.2 Nombre moyen d’automobiles par ménage Même s’il est légèrement sous-estimé, le nombre d’automobile par ménage est un bon indicateur de la dépendance de certains logements mals desservis par les transports en commun. summary(tabdon$VOIT_MEN) Min. 1st Qu. Median Mean 3rd Qu. Max. 0.3944 0.7190 0.8675 0.9003 1.0458 2.0000 ggplot(tabdon, aes(x=VOIT_MEN)) + geom_histogram(bins=20, fill=&quot;gray30&quot;) + scale_y_continuous(&quot;Nombre d&#39;IRIS&quot;)+ scale_x_continuous(&quot;voitures / ménage&quot;)+ ggtitle(&quot;Nombre moyen d&#39;automobile par ménage en 2017&quot;) Alors qu’on trouve en général entre 0.6 et 1.2 automobiles par ménage, certains IRIS affichent des valeurs moyennes de 1.5 à 2 automobiles par ménage. 3.2.5 Sauvegarde du tableau et jointure avec le fonds de carte On commence par effectuer une sauvegarde simple de notre tableau : saveRDS(tabdon,&quot;data/VOIT_IRIS.Rdata&quot;) Puis on effectue une jointure avec le fonds de carte map_iris et on réalise une sauvegarde sous un autre nom. tabfin&lt;-tabdon %&gt;% rename(CODE_IRIS = IRIS) map_VOIT_IRIS&lt;-left_join(map, tabfin) %&gt;% st_as_sf() Joining, by = &quot;CODE_IRIS&quot; saveRDS(map_VOIT_IRIS, &quot;data/map_VOIT_IRIS.Rdata&quot;) 3.2.6 Carte de stock Une carte de stock représente la localisation de quantités que l’on peut aditionner et dont le total a un sens. Par exemple un nombre d’habitants, un nombre de ménages, un nombre d’automobiles. Ce quantités doivent être représentées par des figures (cercles, carrés, …) dont la surface est proportionelle au stock afin que l’oeil du lecteur puisse les aditionner visuellement. Dans le package cartography, on réalise ce type de carte à l’aide de la fonction PropSymbolLayer et on complète l’habillage de la carte (titre, sources, auteur, …) à l’aide de la fonction layoutLayer 3.2.6.1 Distribution des ménages map_com&lt;-readRDS(&quot;data/map_com.Rdata&quot;) map_iris&lt;-readRDS(&quot;data/map_VOIT_IRIS.Rdata&quot;) par(mar=c(0,0,2,0)) plot(map_iris$geometry, col=&quot;lightyellow&quot;, border=&quot;gray80&quot;,lwd=0.4) plot(map_com$geometry, col=NA, border=&quot;gray40&quot;,lwd=0.8, add=T) propSymbolsLayer(x = map_iris, var = &quot;MEN_TOTAL&quot;, col=&quot;blue&quot;, inches = 0.06, legend.title.txt = &quot;Nb ménages&quot;, legend.pos = &quot;left&quot;) layoutLayer(title = &quot;Distribution des ménages du Val de Marne en 2017&quot;, author = &quot;Master MECI / Option data mining&quot;, sources = &quot;INSEE, RP 2017, fichiers détail&quot;) 3.2.6.2 Distribution des automobiles map_com&lt;-readRDS(&quot;data/map_com.Rdata&quot;) map_iris&lt;-readRDS(&quot;data/map_VOIT_IRIS.Rdata&quot;) par(mar=c(0,0,2,0)) plot(map_iris$geometry, col=&quot;lightyellow&quot;, border=&quot;gray80&quot;,lwd=0.4) plot(map_com$geometry, col=NA, border=&quot;gray40&quot;,lwd=0.8, add=T) propSymbolsLayer(x = map_iris, var = &quot;VOIT_TOTAL&quot;, col=&quot;red&quot;, inches = 0.06, legend.title.txt = &quot;nb. véhicules&quot;, legend.pos = &quot;left&quot;) layoutLayer(title = &quot;Distribution des automobiles des ménages du Val de Marne en 2017&quot;, author = &quot;Master MECI / Option data mining&quot;, sources = &quot;INSEE, RP 2017, fichiers détail&quot;) 3.2.7 Carte d’intensité (choroplèthe) Une carte d’intensité représente un phénomène relatif dont la somme n’a pas de sens. Par exemple, il serait absurde d’aditionner les nombres d’automobiles par habitant des IRIS du Val de Marne. Ces variables d’intensité caractèrisent donc l’état général d’une zone (choros) at elles vont être représentées par une couleur appliquée à toute la surface de la zone, d’où leur nom de cartes choroplèthes. La fonction u package cartography adaptée aux variables d’intensité est la fonction Chorolayer. Comme précédemment on la combine avec la fonction LayoutLayerpour réaliser l’habillage de la carte. 3.2.7.1 Part des ménages sans automobile On va réaliser une carte allant du vert clair au vert foncé au fur et à mesure que le nombre de ménages sans automobiles augmente. map_com&lt;-readRDS(&quot;data/map_com.Rdata&quot;) map_iris&lt;-readRDS(&quot;data/map_VOIT_IRIS.Rdata&quot;) par(mar=c(0,0,2,0)) mybreaks = c(0, 10, 20, 30, 40, 50, 60, 70) mycols &lt;-carto.pal(pal1 = &quot;green.pal&quot;, n1 = 7) choroLayer(x = map_iris, var = &quot;PCT_VOIT0&quot;, breaks = mybreaks, col= mycols, lwd=0.2, colNA = &quot;gray80&quot;, legend.title.txt = &quot;% ménages&quot;, legend.pos = &quot;left&quot;, legend.values.rnd = 2, legend.nodata = &quot;Pas de données&quot;) plot(map_com$geometry, col=NA, border=&quot;gray10&quot;,lwd=0.8, add=T) layoutLayer(title = &quot;Part des ménages sans automobiles du Val de Marne en 2017&quot;, author = &quot;Master MECI / Option data mining&quot;, sources = &quot;INSEE, RP 2017, fichiers détail&quot;) 3.2.7.2 Nombre moyen d’automobiles par ménage On va prendre comme référence la valeur de 1 automobile par ménage et on va construire une double palette qui se dirrige vers le brun lorsque le nombre d’automobile par ménage augmente et vers l’orange lorsque le nombre d’automobile par ménage diminue map_com&lt;-readRDS(&quot;data/map_com.Rdata&quot;) map_iris&lt;-readRDS(&quot;data/map_VOIT_IRIS.Rdata&quot;) par(mar=c(0,0,2,0)) mybreaks = c(0.3,0.5, 0.6,0.7,0.8,0.9, 1,1.1, 1.2,1.3,1.4,1.5,2.1) mycols &lt;-carto.pal(pal1 = &quot;green.pal&quot;, n1 = 6, pal2 = &quot;orange.pal&quot;, n2 = 6) choroLayer(x = map_iris, var = &quot;VOIT_MEN&quot;, breaks = mybreaks, col= mycols, lwd=0.2, colNA = &quot;gray80&quot;, legend.title.txt = &quot;auto. / menage&quot;, legend.pos = &quot;left&quot;, legend.values.rnd = 2, legend.nodata = &quot;Pas de données&quot;) plot(map_com$geometry, col=NA, border=&quot;gray10&quot;,lwd=0.8, add=T) layoutLayer(title = &quot;Dépendance automobile des ménages du Val de Marne en 2017&quot;, author = &quot;Master MECI / Option data mining&quot;, sources = &quot;INSEE, RP 2017, fichiers détail&quot;) 3.2.8 Carte de stock + intensité On peut combiner les deux modes cartographiques. Prenons à titre d’exemple le cas des ménages ayant trois automobiles ou plus. Onn peut décrire ce phénomène soit en terme de stock, soit en termes d’intensité. summary(map_iris$MEN_VOIT3) Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s 0.00 12.50 21.42 26.20 33.77 145.76 9 summary(map_iris$PCT_VOIT3) Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s 0.000 1.170 1.943 2.510 3.160 16.114 9 On réalise les deux cartes successivement en commençant par la carte de taux puis en lui ajoutant la carte de stock par dessus. map_com&lt;-readRDS(&quot;data/map_com.Rdata&quot;) map_iris&lt;-readRDS(&quot;data/map_VOIT_IRIS.Rdata&quot;) par(mar=c(0,0,2,0)) mybreaks = c(0, 1,2,4,8,17) mycols &lt;-carto.pal(pal1 = &quot;taupe.pal&quot;, n1 = 5) choroLayer(x = map_iris, var = &quot;PCT_VOIT3&quot;, breaks = mybreaks, col= mycols, lwd=0.2, colNA = &quot;gray80&quot;, legend.title.txt = &quot;% ménages&quot;, legend.pos = &quot;topleft&quot;, legend.values.rnd = 2, legend.nodata = &quot;Pas de données&quot;) plot(map_com$geometry, col=NA, border=&quot;gray10&quot;,lwd=0.8, add=T) propSymbolsLayer(x = map_iris, var = &quot;MEN_VOIT3&quot;, col=&quot;red&quot;, inches = 0.06, legend.title.txt = &quot;nb. ménages&quot;, legend.pos = &quot;left&quot;) layoutLayer(title = &quot;Nombre et proportion des ménages ayant 3 automobiles ou plus en 2017&quot;, author = &quot;Master MECI / Option data mining&quot;, sources = &quot;INSEE, RP 2017, fichiers détail&quot;) 3.3 Création de fonctions L’objectif de cette section est de préparer des fonctions de cartographie qui pourront être intégrés dans une application shiny. On va pour cela reprendre les fonctions mises au point dans la partie statistiques et les coupler avec des procédures de cartographie. On se limitera dans l’immédiat à l’emploi des packages sfet cartography,mais on pourra par la suite créer d’autres fonctions fondées sur des packages tels que leaflet, plotlyou tmap… 3.3.1 fonction tab_cont_iris() On va prendre comme point de départ la création d’un tableau de contingence spatial c’est-à-dire un tableau dont les lignes correspondent aux IRIS d’une commune et les colonnes aux modalités d’une variable de type factor. On récupère les fonctions statistiques mises au point précédemment source(&quot;fonctions/mes_fonctions.R&quot;) On charge le fichier de données en lui ajoutant la variable LPRM_1 dont nous aurons besoin pour distinguer les données par ménage et pour l’ensemble de la population. 3.3.1.1 création du tableau avec la fonction tab_var tab&lt;-tab_var(data = RP, codecom = &quot;94071&quot;, list_mod = c(&quot;1&quot;), var = VOIT, IRIS) 3.3.1.2 pivotage du tableau On opére deux opérations de pivotage du tableau pour récupérer les valeurs brutes (raw) et les valeurs en % (pct). tab_raw &lt;- pivot_wider(data = tab %&gt;% select(-pct), names_from = VOIT, values_from = n, values_fill = 0) names(tab_raw)[-1] &lt;- paste(&quot;count_&quot;,names(tab_raw)[-1], sep=&quot;&quot;) tab_pct &lt;- pivot_wider(data = tab %&gt;% select(-n), names_from = VOIT, values_from = pct, values_fill = 0) names(tab_pct)[-1] &lt;- paste(&quot;pct_&quot;,names(tab_pct)[-1], sep=&quot;&quot;) 3.3.1.3 Ajout de la géométrie On fusionne les deux tableaux précédents et bon effectue la jointure avec le fonds de carte, ce qui suppose de renommer la variable IRIS en CODE_IRIS. tab_geo &lt;- left_join(tab_raw, tab_pct) %&gt;% rename(CODE_IRIS=IRIS) %&gt;% left_join(map_iris) %&gt;% st_as_sf() Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; 3.3.1.4 Création d’une fonction unique On reprend les étapes précédentes pour en faire une fonction unique appelée tab_cont_irisqui prend en entrée une variable quelconque de type factor et produit en sortie le tableau de contingence spatial soit par individu, soit par ménages. tab_cont_iris &lt;- function(data, map, codecom, list_mod, var) { # Create tab tab &lt;-tab_var(data, codecom, list_mod, {{var}}, IRIS) # Pivot count tab_raw &lt;- pivot_wider(data = tab %&gt;% select(-pct), names_from = {{var}}, values_from = n, values_fill = 0) names(tab_raw)[-1] &lt;- paste(&quot;count_&quot;,names(tab_raw)[-1], sep=&quot;&quot;) # Pivot pct tab_pct &lt;- pivot_wider(data = tab %&gt;% select(-n), names_from = {{var}}, values_from = pct, values_fill = 0) names(tab_pct)[-1] &lt;- paste(&quot;pct_&quot;,names(tab_pct)[-1], sep=&quot;&quot;) # join with geom tab_geo &lt;- left_join(tab_raw, tab_pct) %&gt;% rename(CODE_IRIS=IRIS) %&gt;% left_join(map) %&gt;% st_as_sf() return(tab_geo) } 3.3.1.5 Test de la fonction On peut tester la fonction sur la variable SEXE en effectuant un comptage : soit pour la population totale en prenant list_mod = “0” SEXE_IRIS_pop &lt;- tab_cont_iris(RP,map_iris,&quot;94071&quot;,&quot;0&quot;,SEXE) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; head(SEXE_IRIS_pop,3) # A tibble: 3 x 12 CODE_IRIS count_1 count_2 pct_1 pct_2 INSEE_COM NOM_COM IRIS NOM_IRIS &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 940710101 620 718 46.3 53.7 94071 Sucy-e… 0101 Le Gran… 2 940710102 645 737 46.7 53.3 94071 Sucy-e… 0102 La Foss… 3 940710103 776 1018 43.3 56.7 94071 Sucy-e… 0103 La Cite… # … with 3 more variables: TYP_IRIS &lt;chr&gt;, geometry &lt;MULTIPOLYGON [m]&gt;, # DEPT &lt;chr&gt; soit pour les chefs de ménage en prenant list_mod = “1” SEXE_IRIS_men &lt;- tab_cont_iris(RP,map_iris,&quot;94071&quot;,&quot;1&quot;,SEXE) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; head(SEXE_IRIS_men,3) # A tibble: 3 x 12 CODE_IRIS count_1 count_2 pct_1 pct_2 INSEE_COM NOM_COM IRIS NOM_IRIS &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 940710101 474 338 58.4 41.6 94071 Sucy-e… 0101 Le Gran… 2 940710102 411 411 50 50 94071 Sucy-e… 0102 La Foss… 3 940710103 553 496 52.7 47.3 94071 Sucy-e… 0103 La Cite… # … with 3 more variables: TYP_IRIS &lt;chr&gt;, geometry &lt;MULTIPOLYGON [m]&gt;, # DEPT &lt;chr&gt; 3.3.2 fonction map_count_iris Nous allons créer différentes fonctions de cartographie selon que la variable à représenter est un stock (count_x) ou une intensité (pct_xx). Dans l’immédiat nous allons nous limiter aux fonctions de base du package cartographymais ou pourra par la suite proposer d’autres solutions. 3.3.2.1 Objectifs On prend comme entrée un tableau de contingence spatial et on décide de représenter l’une des modalités de type count. Soit par exemple la modalité 3 de la variable VOIT mesurée en nombre de ménages map&lt;-tab_cont_iris(RP, map_iris,&quot;94071&quot;,&quot;0&quot;,VOIT) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; par(mar=c(0,0,2,0)) plot(map$geometry, col=&quot;lightyellow&quot;, border=&quot;gray80&quot;,lwd=0.4) propSymbolsLayer(x = map, var = &quot;count_3&quot;, col=&quot;blue&quot;, inches = 0.06, legend.title.txt = &quot;Nb ménages&quot;, legend.pos = &quot;topright&quot;) layoutLayer(title = &quot;Ménages avec trois voitures ou plus&quot;, author = &quot;Master MECI / Option data mining&quot;, sources = &quot;INSEE, RP 2017, fichiers détail&quot;) 3.3.2.2 Fonction minimale On va maintenant créer une fonction ayant autant de paramètres que nécessaire pour pouvoir s’appliquer à n’importe quelle modalité de n’importe quelle variable. La fonction minimale devra comporter 6 paramètres map_count_iris &lt;- function (data, map, codecom, list_mod, var, mod, titre) { mymap&lt;-tab_cont_iris(data,map_iris,codecom,list_mod,{{var}}) myvar &lt;- paste(&quot;count_&quot;,mod, sep=&quot;&quot;) if (list_mod==0) {myleg = &quot;nb. d&#39;habitants&quot;} else {myleg = &quot;nb de ménages&quot;} par(mar=c(0,0,2,0)) plot(mymap$geometry, col=&quot;lightyellow&quot;, border=&quot;gray80&quot;,lwd=0.4) propSymbolsLayer(x = mymap, var = myvar, col=&quot;blue&quot;, inches = 0.06, legend.title.txt = myleg, legend.pos = &quot;topright&quot;) layoutLayer(title = titre, author = &quot;Master MECI / Option data mining&quot;, sources = &quot;INSEE, RP 2017, fichiers détail&quot;) } On teste la fonction sur les ménages ayant plus de trois voitures à Sucy-en-Brie map_count_iris(data = RP, map = map_iris, codecom = &quot;94071&quot;, list_mod = &quot;1&quot;, var = VOIT, mod = 3, &quot;Ménages avec trois voitures ou plus&quot;) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; On vérifie qu’elle marche également sur une autre commune comme Saint-Maur-des-Fossés (94068). map_count_iris(data = RP, map = map_iris, codecom = &quot;94068&quot;, list_mod = &quot;1&quot;, var = VOIT, mod = 3, &quot;Ménages avec trois voitures ou plus&quot;) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; … ou bien sur une autre modalité d’une autre variable. Par exemple la distribution des ménages dont la personne de référence est ouvrier à Sucy-en-Brie map_count_iris(data = RP, map = map_iris, codecom = &quot;94071&quot;, list_mod = &quot;1&quot;, var = CS1, mod = 6, &quot;Ménages ouvriers en 2017&quot;) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; 3.3.2.3 Fonction améliorée Vous pouvez maintenant améliorer la fonction en lui ajoutant d’autres paramètres variables tels que : la source l’auteur la couleur de remplissage des cercles la couleur d’arrière-plan des iris le zoom d’aggrandissement des cercles etc. 3.3.3 fonction map_pct_iris Nous allons maintenant préparer un pogramme pour cartographier une variable d’intensité (pct_xx) dont la somme n’a pas de sens et qui doit donc utiliser le mode cartographique zonal (carte choroplèthe). 3.3.3.1 Objectifs On prend comme entrée le tableau de contingence spatial qui a été transformé en profil en ligne avec des modalités de type pct. Comme nous allons devoir établir automatiquement des classes sans connaître la forme de la distribution, nous devons utiliser une solution robuste. La méthode des quantiles apparaît alors comme la plus adaptée puisqu’elle consiste à découper la distribution en classes d’effectifs égaux. Concernant le nombre de classes, il doit dépendre du nombre d’éléments (ici d’IRIS) et nous allons utiliser pour cela la formule de Huntsberger qui indique le nombre maximum de classes souhaitable (K) en fonction du nombre d’élément (n). \\(K = 1 + \\frac{10}{3}.log_{10}(x)\\) On définit à partir de là une carte-type en prenant l’exemple du % de ménages n’ayant pas de voiture à Sucy-en-Brie huntsberger &lt;- function(x) {round(1+(10/3)*log10(x))} map&lt;-tab_cont_iris(RP,map_iris, &quot;94071&quot;,&quot;0&quot;,VOIT) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; par(mar=c(0,0,2,0)) nbc&lt;-huntsberger(nrow(map)) choroLayer( x = map, nclass = nbc, method = &quot;quantile&quot;, var = &quot;pct_0&quot;, legend.title.txt = &quot;% ménages&quot;, legend.pos = &quot;topright&quot;, legend.values.rnd = 1) layoutLayer(title = &quot;Ménages n&#39;ayant pas de voiture&quot;, author = &quot;Master MECI / Option data mining&quot;, sources = &quot;INSEE, RP 2017, fichiers détail&quot;) 3.3.3.2 Fonction minimale On va maintenant créer une fonction ayant autant de paramètres que nécessaire pour pouvoir s’appliquer à n’importe quelle modalité de n’importe quelle variable. La fonction minimale devra comporter 7 paramètres map_pct_iris &lt;- function ( data, map, codecom, list_mod, var, mod, titre) { mymap&lt;-tab_cont_iris(data,map, codecom,list_mod,{{var}}) myvar &lt;- paste(&quot;pct_&quot;,mod, sep=&quot;&quot;) if (list_mod==0) {myleg = &quot;% des habitants&quot;} else {myleg = &quot;% des ménages&quot;} huntsberger &lt;- function(x) {round(1+(10/3)*log10(x))} nbc&lt;-huntsberger(nrow(map)) par(mar=c(0,0,2,0)) choroLayer( x = mymap, var = myvar, nclass = nbc, method = &quot;quantile&quot;, legend.title.txt = myleg, legend.pos = &quot;topright&quot;, legend.values.rnd = 1) layoutLayer(title = titre, author = &quot;Master MECI / Option data mining&quot;, sources = &quot;INSEE, RP 2017, fichiers détail&quot;) } On teste la fonction sur les ménages ayant plus de trois voitures à Sucy-en-Brie map_pct_iris(data = RP, map= map_iris, codecom = &quot;94071&quot;, list_mod = &quot;1&quot;, var = VOIT, mod = 3, &quot;Ménages avec trois voitures ou plus&quot;) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; On vérifie qu’elle marche également sur une autre commune comme Saint-Maur-des-Fossés (94068). map_pct_iris(data = RP, map = map_iris, codecom = &quot;94068&quot;, list_mod = &quot;1&quot;, var = VOIT, mod = 3, &quot;Ménages avec trois voitures ou plus&quot;) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; … ou bien sur une autre modalité d’une autre variable. Par exemple la distribution des ménages dont la personne de référence est ouvrier à Sucy-en-Brie map_pct_iris(data = RP, map = map_iris, codecom = &quot;94071&quot;, list_mod = &quot;1&quot;, var = CS1, mod = 6, &quot;Ménages ouvriers en 2017&quot;) Joining, by = &quot;IRIS&quot; Joining, by = &quot;CODE_IRIS&quot; 3.3.3.3 Fonction améliorée Vous pouvez maintenant améliorer la fonction en lui ajoutant d’autres paramètres variables tels que : la source l’auteur la palette de couleur le nombre de classes le mode de découpage des classes etc. 3.3.4 Sauvegarde des fonctions On sauvegarde les nouvelles fonctions dans un nouveau fichier mes_fonctions_V2.R qui comporte les fonctions statistiques précédents et les nouvelles fonctions cartographiques mises au point dans ce chapitre. "]]

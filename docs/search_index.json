[["index.html", "Projet DATA MINING 2021 Master Meci - Parcours Data - Options PISE et CCESE", " Projet DATA MINING 2021 Master Meci - Parcours Data - Options PISE et CCESE Claude Grasland et Camille Signoretto 2021-03-20 "],["00-presentation.html", "Présentation À propos de ce document Prérequis Remerciements Licence", " Présentation À propos de ce document Ce document est la première version du cours de Data Mining dispensé aux étudiants de deuxième année de l’ option Data du master MECI Il est basé sur R version 4.0.2 (2020-06-22). Ce document est régulièrement corrigé et mis à jour. La version de référence est disponible en ligne à l’adresse : https://ClaudeGrasland.github.io/DataMiningProject2021. Pour toute suggestion ou correction, il est possible de me contacter par mail Prérequis Le seul prérequis pour suivre ce document est d’avoir installé R et RStudio sur votre ordinateur. Il s’agit de deux logiciels libres, gratuits, téléchargeables en ligne et fonctionnant sous PC, Mac et Linux. Pour installer R, il suffit de se rendre sur une des pages suivantes 1 : Installer R sous Windows Installer R sous Mac Pour installer RStudio, rendez-vous sur la page suivante et téléchargez la version adaptée à votre système : https://www.rstudio.com/products/rstudio/download/#download Remerciements Ce document a bénéficié de la relecture et des suggestions … des étudiants qui en ont été les cobayes des premières versions. Ce document est généré par l’excellente extension bookdown de Yihui Xie et il s’est servi du template proposé par Julien Barnier pour introduire des exercices interactifs dans son cours de tidyverse. Licence Ce document est mis à disposition selon les termes de la Licence Creative Commons Attribution - Pas d’Utilisation Commerciale - Partage dans les Mêmes Conditions 4.0 International. Licence Creative Commons Sous Linux, utilisez votre gestionnaire de packages habituel.↩︎ "],["11-data.html", "Chapitre 1 Collecte de données statistiques et spatiales 1.1 Introduction 1.2 Données statistiques sur les individus 1.3 Données statistiques sur les logements ordinaires 1.4 Données géométriques 1.5 Bilan et nettoyage", " Chapitre 1 Collecte de données statistiques et spatiales library(knitr) library(dplyr) library(data.table) library(readr) library(sf) library(ggplot2) 1.1 Introduction L’objectif du projet Data Mining 2021 consistera à étudier les inégalités sociales et spatiales dans le département du Val de Marne à partir des données du dernier recensement de population de 2017. Ces inégalités seront envisagées à différentes échelles ce qui impliquera des procédures d’agrégation des fichiers détails. 1.2 Données statistiques sur les individus Nous partirons des fichiers détail de l’INSEE car, à la différence des tableaux prédéfinis, ils permettent virtuellement toutes les formes de croisement d’indicateurs. Ils sont évidemment beaucoup plus volumineux, mais ce sera justement l’occasion pour les étudiants en data mining d’être confrontés à des problèmes d’optimisation et de big data. On trouve leur description détaillée sur le site de l’INSEE dans la page consacrée au recensement : https://www.insee.fr/fr/statistiques/4508161 Nous avons opté pour le fichier des individus localisés au canton-ou-ville qui présente une grande polyvalence d’usage puisqu’il permet de reconstituer des tableau agrégés ou l’unité de compte peut-être soit le ménage, soit l’individu selon le critère de pondération adopté. 1.2.1 Etape 1 : téléchargement des données et stockage temporaire Nous allons télécharger ici le fichier des données pour la région Ile-de-France au format .csv et l’enregistrer dans un dossier spécial tmp qui pourra ulétérieurement être détruit ou déplacé afin de libérer de la place N.B. Ce programme qui prend quelques minutes sera exécuté une seule fois. On ajoutera ensuite dans l’en-tête du chunk eval=FALSE ce qui veut dire que ce bloc de code ne sera plus executé automatiquement lorsqu’on réalise un knit du document Rmd. Il sera néanmoins toujours possible de l’executer manuellement en cliquant sur sa petite flèche verte. ### Téléchargement du fichier INSEE download.file(url=&quot;https://www.insee.fr/fr/statistiques/fichier/4802064/RP2017_INDCVIZA_csv.zip&quot;, destfile = &quot;tmp/indiv2017.zip&quot;) ## Decompression du fichier INSEE unzip(zipfile = &quot;tmp/indiv2017.zip&quot;, exdir = &quot;tmp&quot;) ## Examen du contenu list.files(&quot;tmp&quot;) Nous constatons que le document zippé contenait en fait deux fichiers différents Le fichier de données individuelles FD_INDCVIZA_2017.csv : qui pèse au bas mot 1014.3 Mo (1 Giga) et dont nous verrons par la suite qu’il comporte 4.3 millions de lignes et 88 colonnes. Le fichier de métadonnées varmod_INDCVI_2017.csv : qui ne pèse que 1.8 Mo et comprend la description précise du label de chacune des modalités de variables. 1.2.2 Etape 2 : Transformation des données au format R L’importation d’un tableau aussi gros (4.3 millions de lignes et 88 colonnes) donne l’occasion de faire quelques tests de vitesses sur les différents packages capables de lire des fichiers .csv. Nous allons pour cela utiliser la fonction Sys.time()qui permet de repérer l’heure au début et à la fin d’une action. Les résultats dépendront évidemment de la vitesse de l’ordinateur. Il s’agit ici d’un MacBook Pro 2.9 Ghz, disposant de 4 coeurs et 16 Go de mémoire. 1.2.2.1 Chargement avec la fonction read.csv Avec la fonctionread.csv ui fait partie du R-base , le temps de chargement est de 150 secondes. Le tableau résultant est de classe data.frame puisque nous avons utilisé une fonction native de R-base t1&lt;-Sys.time() tab&lt;-read.csv(&quot;tmp/FD_INDCVIZA_2017.csv&quot;, sep = &quot;;&quot;, header =T) t2&lt;-Sys.time() paste (&quot;chargement effectué en&quot;,t2-t1,) dim(tab) class(tab) 1.2.2.2 Chargement avec la fonction read_csv2 avec la fonction read_csv2 du package readr, le chargement est effectué en 59 secondes sur le même ordinateur. Le tableau résultant garde la classe data.frame mais est aussi un tibble puisque le package readr fait partie de l’écosystème tibble/tidyverse. Le temps de chrgement est donc divisé par deux. library(readr) t1&lt;-Sys.time() tab&lt;-read_csv2(&quot;tmp/FD_INDCVIZA_2017.csv&quot;) t2&lt;-Sys.time() paste (&quot;chargement effectué en&quot;,t2-t1, &quot;secondes&quot;) dim(tab) class(tab) 1.2.2.3 Chargement avec la fonction fread avec la fonction fread du package data.table, le chargement est effectué en 31 secondes sur le même ordinateur.Le tableau résultant conserve la classe data.frame mais possède aussi la classe data.table puisque la fonction fread est issue de ce package. Le temps est divisé encore une fois par deux. library(data.table) t1&lt;-Sys.time() tab&lt;-fread(&quot;tmp/FD_INDCVIZA_2017.csv&quot;) t2&lt;-Sys.time() paste (&quot;chargement effectué en&quot;,t2-t1, &quot;secondes&quot;) dim(tab) class(tab) On voit donc que le temps de chargement peut différer fortement selon le choix des packages. Il en va ensuite de même pour les traitements d’agrégation des données qui seront plus ou moins rapides selon que l’on utilise les fonctions de R-base applicables à un data.frame, celles du package tidyverse applicables à un tibble ou enfin celles du package data.table applicables à un data.table. 1.2.3 Etape 3 : Sélection des données utiles et sauvegarde au format .Rdata Nos différentes tableaux peuvent être enregistés au format interne de .R ce qui réduira considérablement leur taille par rapport au fichier texte au format csv qui pèse 1.06 Go. Nous allons également limiter la taille du document en ne conservant que les données qui nous intéressent, en l’occurence celles du département du Val de Marne. Comme ces données bvont nous servir durant tout le projet, elles seront stockées dans le dossier data situé à l’intérieur du projet et non pas dans le dossier tmp qui sera détruit si l’on n’en a plus besoin pour libérer de la place. N.B. On ramène l’objet à la classe d’objet unique data.frame pour éviter des conflits possibles entre package. On pourra toujours le retransformer ensuite en data.table ou en tibble. ## Chargement avec fread (+ rapide) tab&lt;-fread(&quot;tmp/FD_INDCVIZA_2017.csv&quot;) ## Suppression de la classe data.table tab&lt;-as.data.frame(tab) ## Selection des données relatives au Val de Marne sel &lt;- tab %&gt;% filter(DEPT == 94) ## Vérification des dimensions du tableau dim(sel) ## Sauvegarde au format RDS saveRDS(object = sel, file = &quot;data/indiv2017.Rdata&quot;) On peut effectuer de façon facultative une sauvegarde au format .csv ce qui évitera des problème d’ouverture du fichier .Rdata pour les personnes ayant des versions anciennes de R. Mais du coup cela engendrera un fichier très volumineux (200 Mo). ## Sauvegarde au format CSV (facultatif) write.table(x=sel, file = &quot;data/indiv2017.csv&quot;, sep=&quot;;&quot;, dec = &quot;.&quot;, fileEncoding = &quot;UTF-8&quot;) 1.2.3.1 Etape 4 : Chargement et sauvegarde des méta-données Il ne faut surtout pas oublier le fichier des métadonnées qui va permettre de recoder facilement tous les facteurs et de décoder les chiffres correspondant aux classes. On va donc le transformer au format R puis l’enregistrer également dans le dossier data. # Lecture du fichier de métadonnées meta&lt;-fread(&quot;tmp/varmod_INDCVI_2017.csv&quot;) # Enregistrement dans le dossier data saveRDS(object = meta, file = &quot;data/indiv2017_meta.Rdata&quot;) 1.3 Données statistiques sur les logements ordinaires Nous allons reproduire sans les commenter de façon aussi détaillée les mêmes étapes que précédemment pour construire un fichier des logements ordinaires dont la description se trouve à l’adresse suivante : https://www.insee.fr/fr/statistiques/4802056?sommaire=4508161 1.3.1 Etape 1 : récupération des fichiers ### Téléchargement du fichier INSEE download.file(url=&quot;https://www.insee.fr/fr/statistiques/fichier/4802056/RP2017_LOGEMTZA_csv.zip&quot;, destfile = &quot;tmp/logmt2017.zip&quot;) ## Decompression du fichier INSEE unzip(zipfile = &quot;tmp/logmt2017.zip&quot;, exdir = &quot;tmp&quot;) ## Examen du contenu list.files(&quot;tmp&quot;) Comme dans le cas du fichier des individus, on trouve un fichier des données et un fichier des métadonnées qu’il faut tous les deux récupérer. 1.3.2 Etape 2 : Transformation des données au format R On utilise la fonction fread du package data.table qui est la plus rapide ## Chargement avec fread (+ rapide) tab&lt;-fread(&quot;tmp/FD_LOGEMTZA_2017.csv&quot;) 1.3.3 Etape 3 : Sélection des données utiles et sauvegarde au format .Rdata On remet le tableau au format standard data.frame , on sélectionne la zone d’étude et on sauvegarde au format .Rdata. N.B Comme la variable DEPT n’existe pas on utilise les deux premiers chiffres du code de la variable COMMUNE pour la créer ## Suppression de la classe data.table tab&lt;-as.data.frame(tab) ## Selection des données relatives au Val de Marne sel &lt;- tab %&gt;% mutate(DEPT = substr(COMMUNE,1,2)) %&gt;% filter(DEPT == &quot;94&quot;) ## Vérification des dimensions du tableau dim(sel) ## Sauvegarde au format RDS saveRDS(object = sel, file = &quot;data/logmt2017.Rdata&quot;) 1.3.3.1 Etape 4 : Chargement et sauvegarde des méta-données Comme dans le cas des logements, on sauvegarde précieusement le fichier des métadonnées. # Lecture du fichier de métadonnées meta&lt;-fread(&quot;tmp/varmod_LOGEMT_2017.csv&quot;) # Enregistrement dans le dossier data saveRDS(object = meta, file = &quot;data/logmt2017_meta.Rdata&quot;) 1.4 Données géométriques Les contours des unités spatiales correspondant aux codes de l’INSEE sont produits par l’IGN et disponibles sur le site géoservice en accès libre : https://geoservices.ign.fr/documentation/diffusion/telechargement-donnees-libres.html 1.4.1 Etape 1 : récupération du fonds IRIS au format shapefile La principale difficulté est de s’orienter dans l’ensemble des produits disponibles. Dans l’exemple présent, nous cherchhons le contour des IRIS, c’est-à-dire des entités infra-communales correspondant au découpage utilisé lors du recensement de 2017. Comme précédemment, nous allons stocker le résultat du téléchargement dans notre fichier tmp qui sera détruit ou déplacé lorsque nous aurons récupéré toutes les données utiles. download.file(url=&quot;https://wxs.ign.fr/1yhlj2ehpqf3q6dt6a2y7b64/telechargement/inspire/CONTOURS-IRIS-2017-06-30%24CONTOURS-IRIS_2-1__SHP__FRA_2017-06-30/file/CONTOURS-IRIS_2-1__SHP__FRA_2017-06-30.7z&quot;, destfile = &quot;tmp/geom.7z&quot;) Il n’est apparemment pas possible de décompresser le fichier avec la fonction unzip de R, donc on effectue cette opération manuellement. Il en résulte une arborescence très complexe de dossiers et de sous-dossiers correspondant aux IRIS de la Francé métropolitaine mais aussi de chacun des DOM. Il faut alors aller repérer dans cet arborescence le dossier où se trouve le fonds IRIS de la France métropolitaine qui est au format shapefile et comporte plusieurs fichiers avec des extensions différentes. list.files(&quot;tmp/CONTOURS-IRIS_2-1__SHP__FRA_2017-06-30/CONTOURS-IRIS/1_DONNEES_LIVRAISON_2016/CONTOURS-IRIS_2-1_SHP_LAMB93_FE-2016&quot;) [1] &quot;CONTOURS-IRIS.cpg&quot; &quot;CONTOURS-IRIS.dbf&quot; &quot;CONTOURS-IRIS.prj&quot; [4] &quot;CONTOURS-IRIS.shp&quot; &quot;CONTOURS-IRIS.shx&quot; &quot;LISTE.csv&quot; 1.4.2 Etape 2 : Importation et transformation au format sf La cartographie et plus généralement les opérations géométriques sur des données spatiales dans R peuvent facilement être effectuées avec le package sf (spatial features) qui crée des objets ubniques rassemblant à la fois un tableau de données (l’équivalent du fichier .dbf) une géométrie (l’équivalent du fichier .shp) une projection (l’équivalent du fichier .prj) Lorsqu’on récupère des fonds de carte au format shapefile (.shp) ou dans d’autres formats standards comme GeoJson, la première tâche consiste donc à les convertir au formt sf afin de pouvoir les utiliser facilement dans R. L’importation se fait à l’aide de l’instruction st_read en indiquant juste le nom du fichier .shp à charger. Les autres fichiers (.dbf ou .proj) seront lus également et intégrés dans l’objet qui hérite de la double classe data.frame et sf library(sf) map &lt;- st_read(&quot;tmp/CONTOURS-IRIS_2-1__SHP__FRA_2017-06-30/CONTOURS-IRIS/1_DONNEES_LIVRAISON_2016/CONTOURS-IRIS_2-1_SHP_LAMB93_FE-2016/CONTOURS-IRIS.shp&quot;) Reading layer `CONTOURS-IRIS&#39; from data source `/Users/claudegrasland1/Documents/cg/cours/2020_M2_MECI_Datamining/DataMiningProject2021/tmp/CONTOURS-IRIS_2-1__SHP__FRA_2017-06-30/CONTOURS-IRIS/1_DONNEES_LIVRAISON_2016/CONTOURS-IRIS_2-1_SHP_LAMB93_FE-2016/CONTOURS-IRIS.shp&#39; using driver `ESRI Shapefile&#39; Simple feature collection with 49404 features and 6 fields geometry type: MULTIPOLYGON dimension: XY bbox: xmin: 99040 ymin: 6049662 xmax: 1242445 ymax: 7110479 projected CRS: RGF93_Lambert_93 dim(map) [1] 49404 7 class(map) [1] &quot;sf&quot; &quot;data.frame&quot; head(map,2) # A tibble: 2 x 7 INSEE_COM NOM_COM IRIS CODE_IRIS NOM_IRIS TYP_IRIS geometry &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;MULTIPOLYGON [m]&gt; 1 72191 Mayet 0000 721910000 Mayet Z (((498083.5 6747517, 4981… 2 77248 Lesches 0000 772480000 Lesches Z (((685753.1 6868613, 6857… 1.4.3 Etape 3 : Extraction des IRIS de la zone d’étude Le fichier comporte près de 50 000 unités spatiales qui correspondent soit à des communes suffisamment grandes pour être découpées en IRIS, soit à des communes non découpées. On reconnaît ces dernières au fait que leur code IRIS se termine par ‘00000’. Supposons qu’on veuille extraire le fonds de carte du Val de Marne. On va commencer par créer une variable DEPT en extrayant les dxeux premiers caractères du code communal, puis on va sélectionner le départements correspondant : map_iris&lt;-map %&gt;% mutate(DEPT = substr(INSEE_COM,1,2)) %&gt;% filter(DEPT %in% c(&quot;94&quot;)) dim(map_iris) [1] 527 8 class(map_iris) [1] &quot;sf&quot; &quot;data.frame&quot; head(map_iris,2) # A tibble: 2 x 8 INSEE_COM NOM_COM IRIS CODE_IRIS NOM_IRIS TYP_IRIS geometry &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;MULTIPOLYGON [m]&gt; 1 94021 Chevil… 0107 940210107 Sorbiers H (((652774.3 6853051, 652… 2 94068 Saint-… 0204 940680204 Le Vieu… H (((662096.5 6856264, 662… # … with 1 more variable: DEPT &lt;chr&gt; Le nouveau tableau ne comporte plus que 2749 unités spatiales et 8 colonnes au lieu de 7 puisqu’ l’on a ajouté une colonne DEPT. On peut visualiser le résultat à l’aide de la fonction geom_sfdu package ggplot2 : ggplot(map_iris)+geom_sf(fill=&quot;lightyellow&quot;,col=&quot;red&quot;) + theme_void() On sauvegarde le résultat dans notre dossier data au format interne de R : saveRDS(object = map_iris, file = &quot;data/map_iris.Rdata&quot;) On peut également effectuer (de façon facultative) une sauvegarde au format shapefile afin de pouvoir réutiliser le fonds de carte à l’aide d’autres applications externes à R. st_write(obj = map_iris, dsn= &quot;data/map_iris.shp&quot;, # indique le format de sortie par l&#39;extension .shp delete_dsn = TRUE, # écrase le fichier s&#39;il existe déjà quiet = TRUE) # évite que R fasse des commentaires 1.4.4 Etape 4 : création d’un fonds de carte des communes Comme nous serons amenés à travailler à plusieurs échelles, nous produisons tout de suite un fonds de carte des communes en utilisant les fonctions d’agrégation du packages sf combinées avec celles de dplyr. map_com &lt;- map_iris %&gt;% group_by(INSEE_COM) %&gt;% summarise(NOM_COM = min(NOM_COM)) %&gt;% st_as_sf() `summarise()` ungrouping output (override with `.groups` argument) on vérifie que l’agrégation s’est bien passée : ggplot(map_com)+geom_sf(fill=&quot;lightyellow&quot;,col=&quot;red&quot;) + theme_void() Et on sauvegarde le fonds de carte saveRDS(object = map_com, file = &quot;data/map_com.Rdata&quot;) 1.4.5 Etape 5 : création d’un fonds de carte par département Enfin, on construit un fonds de carte des départements selon la même procédure : map_dep &lt;- map_iris %&gt;% mutate(DEPT = substr(INSEE_COM,1,2))%&gt;% group_by(DEPT) %&gt;% summarise() %&gt;% st_as_sf() `summarise()` ungrouping output (override with `.groups` argument) ggplot(map_dep)+geom_sf(fill=&quot;lightyellow&quot;,col=&quot;red&quot;) + theme_void() saveRDS(object = map_dep, file = &quot;data/map_dep.Rdata&quot;) 1.4.6 Etape 6: Superposition des trois fonds de carte On va utiliser la fonction plot du package sf qui permet de visualiser la variable geometry et facilite les superpositions avec l’instruction add=TRUE. par(mar=c(0,0,0,0)) plot(map_iris$geometry, col= &quot;lightyellow&quot;, border = &quot;gray80&quot;, lwd=0.5) plot(map_com$geometry, col= NA, border = &quot;gray50&quot;, lwd=1, add=TRUE) plot(map_dep$geometry, col= NA, border = &quot;gray30&quot;, lwd=2, add=TRUE) 1.5 Bilan et nettoyage Nous avons désormais un dossier data qui comporte : Le fichier des individus et ses métadonnées Le fichier des logements ordinaires et ses métadonnées Les fonds de carte par iris, commune et département. list.files(&quot;data&quot;) [1] &quot;indiv2017_meta.Rdata&quot; &quot;indiv2017.Rdata&quot; &quot;logmt2017_meta.Rdata&quot; [4] &quot;logmt2017.Rdata&quot; &quot;map_com.Rdata&quot; &quot;map_dep.Rdata&quot; [7] &quot;map_iris.Rdata&quot; &quot;map_VOIT_IRIS.Rdata&quot; &quot;mapdon_94068.Rdata&quot; [10] &quot;mapdon_94071.Rdata&quot; &quot;VOIT_IRIS.Rdata&quot; On peut alors décider de détruire le dossier tmp qui contient des dossiers très volumineux et pas forcément indispensables. "],["21-socio-spatial.html", "Chapitre 2 Agrégation socio-spatiale 2.1 Objectifs 2.2 Fichier de référence", " Chapitre 2 Agrégation socio-spatiale 2.1 Objectifs L’objectif de cette section est de procéder à des agrégations sociales et spatiales des données individuelles afin de pouvoir ensuite réaliser des cartes. 2.1.1 Ménages ou habitants ? La principale difficulté consistera à choisir les bonnes pondérations selon que l’on souhaite : Travailler sur les ménages : par exemple pour connaître le nombre de ménages ayant 0, 1, 2 ou plus de 3 automobiles. Travailler sur les habitants : par exemple pour connaître le nombre de personnes ayant plus de 6 ans. 2.1.2 Département, commune ou IRIS ? On devra aussi s’intéresser aux variables géographiques disponibles pour réaliser des agrégations spatiales différentes selon que l’on souhaite travailler : à l’échelle de l’ensemble du département : par exemple, quel est le taux de chômage des actifs du Val de Marne à l’échelle des communes : par exemple, quel est le taux de chômage des actifs de Sucy-en-Brie à l’échelle des IRIS infra-communaux : par exemple, quel est le taux de chômage des actifs du quartier de la Fossse Rouge à Sucy-en Brie. 2.1.3 Tableaux de contingence et tableaux de profil Enfin, on fera attention de ne pas mélanger les stocks et les taux qui correspondent à des tableaux et des variables de nature différente tant pour l’analyse statistique que pour la cartogaphie. Un tableau de contingence est un tableau de comptage d’individus (habitants ou ménages) dans lequel on peut effectuer les sommes en ligne ou en colonnes. Par exemple, on peut dénombrer les actifs en fonction de leur catégorie socio-professionnelle et de leur commune de résidence. Chacune des cases du tableau correspondra à un nombre d’actifs. Un tableau de profil (ou de pourcentage) est une transformation du tableau de contingence permettant de calculer des pourcentages en ligne ou en colonne. Dans l’exemple précédent, si les lignes correspondent aux communes et les colonnes aux CSP, on peut produire soit un tableau des profils en lignes (pourcentage des habitants d’une commune travaillant dans une CSP), soit un tableau des profils en colonnes (pourcentage des membres d’une CSP résidant dans une commune). 2.1.4 Packages utilisés Nous allons nous limiter à un nombre minimum de package au cours de cette première séance dans la mesure où très peu de réalisations cartographiques seront effectuées. dplyr : pour la manipulation des tableaux et leur agrégation (inutile de charger l’ensemble du package tidyverse) knitr : pour afficher proprement les tableaux de résultats ggplot2 : pour visualiser les résultats sous formes de graphiques sf : pour manipuler les données cartographiques et les agréger library(knitr) library(dplyr) library(ggplot2) library(sf) 2.1.5 Choix d’une commune En prévision du projet, chaque étudiant devra choisir une commune qui fera l’objet d’analyse ciblées. Cette commune devra respecter les conditions suivantes : Présence d’au moins 10 IRIS Population supérieure à 20 000 habitants Diversité sociale importante avec mélange de quartiers à profils différents Une fois identifiée la commune cible chaque étudiant devra trouver son code officiel géographique en tapant son nom sur la page web suivante : https://www.insee.fr/fr/statistiques/zones/2011101 Voici une première liste de communes proposées aux étudiants : Champigny-sur-Marne (94017) Créteil (94028) Fontenay-sous-Bois (94033) Ivry-sur-Seine (94041) Saint-Maur-des-Fossés (94068) Vitry-sur-Seine (94081) Vincennes (94080) Villejuif (94076) Le cours prendra quant à lui l’exemple de la commune de Sucy-en-Brie (94071) 2.1.6 Chargement des données Nous avons besoin de trois fichiers Le fichier des individus le fichier des métadonnées relatives aux individus le fonds de carte des IRIS indiv &lt;- readRDS(&quot;data/indiv2017.Rdata&quot;) meta &lt;- readRDS(&quot;data/indiv2017_meta.Rdata&quot;) map &lt;-readRDS(&quot;data/map_iris.Rdata&quot;) 2.2 Fichier de référence Nous allons apprendre dans un premier temps à calculer pour une commune un fichier de référence comportant le nombre d’habitants et le nombre de ménage de chacun des quartiers IRIS. Puis nous y ajouerons le contour géomérique des quartiers IRIS afin de pouvoir réaliser des cartes par la suite. 2.2.1 Nombre total d’habitants et de ménages de la commune Comme le recensement n’est pas exhaustif, nous devrons pondérer tous nos calculs par la variable IPONDI qui est définie de la façon suivante dans les métadonnées : metavar&lt;-meta %&gt;% filter(COD_VAR == &quot;IPONDI&quot;) kable(metavar) COD_VAR LIB_VAR COD_MOD LIB_MOD TYPE_VAR LONG_VAR IPONDI Poids de l’individu CHAR 17.15 2.2.1.1 nombre d’habitants de la commune On commence par créer la variable COM qui n’existe pas mais qui est contenue dans le code IRIS, puis on regroupe par commune et enfin on effectue la somme. indiv %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(COM == &quot;94071&quot;) %&gt;% summarise(nbhab = sum(IPONDI)) # A tibble: 1 x 1 nbhab &lt;dbl&gt; 1 26479. On constate que la commune de Sucy-en-Brie (94071)* a une population estimée de 26479.068 habitants. 2.2.1.2 nombre de ménage de la commune Pour calculer le nombre de ménages, il faut construire un tablean menag ne comportant que les personnes de références. Nous allons devoir utiliser pour cela la variable LPRM dont on affiche les métadonnées : metavar&lt;-meta %&gt;% filter(COD_VAR == &quot;LPRM&quot;) kable(metavar) COD_VAR LIB_VAR COD_MOD LIB_MOD TYPE_VAR LONG_VAR LPRM Lien à la personne de référence du ménage 1 Personne de référence du ménage CHAR 1 LPRM Lien à la personne de référence du ménage 2 Conjoint de la personne de référence du ménage CHAR 1 LPRM Lien à la personne de référence du ménage 3 Enfant de la personne de référence du ménage ou de son conjoint CHAR 1 LPRM Lien à la personne de référence du ménage 4 Petit-enfant CHAR 1 LPRM Lien à la personne de référence du ménage 5 Ascendant CHAR 1 LPRM Lien à la personne de référence du ménage 6 Autre parent CHAR 1 LPRM Lien à la personne de référence du ménage 7 Ami CHAR 1 LPRM Lien à la personne de référence du ménage 8 Pensionnaire ou sous-locataire CHAR 1 LPRM Lien à la personne de référence du ménage 9 Domestique ou salarié logé CHAR 1 LPRM Lien à la personne de référence du ménage Z Hors logement ordinaire CHAR 1 Ce tableau montre que la modalité “1” correspond précisément aux personnes de références. Il faut donc filtrer le tableau des individus sur la condition LPRF==1pour ne garder que les ménages.On peut alors dénombrer les ménages en appliquant exactement la même procédure de pondération que pour la population : indiv %&gt;% filter(LPRM == 1) %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(COM == &quot;94071&quot;) %&gt;% summarise(nbmen = sum(IPONDI)) # A tibble: 1 x 1 nbmen &lt;dbl&gt; 1 10716. D’après le tableau obtenu, il y a 7466.732 ménages (ordinaires) dans la commune de Sucy-en-Brie en 2017 2.2.1.3 Vérification On se rend sur le site de l’INSEE pour vérifier que les deux chiffres correspondent bien approximativement aux résultats du recensement de 2017 2.2.2 Nombre d’habitants et de ménages par IRIS On se propose maintenant d’établir un tableau du nombre d’habitant et du nombre de ménages d’une commune par quartier IRIS. 2.2.2.1 Nombre d’habitants d’une commune par IRIS On calcule le nombre d’habitants par IRIS à l’aide de l’instruction group_by du package dplyr: tabpop &lt;- indiv %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(COM == &quot;94071&quot;) %&gt;% group_by (IRIS) %&gt;% summarise(nbhab = sum(IPONDI)) `summarise()` ungrouping output (override with `.groups` argument) kable(tabpop) IRIS nbhab 940710101 2150.932 940710102 2203.946 940710103 2843.362 940710104 2630.590 940710105 3006.213 940710106 2368.138 940710107 2545.304 940710108 2853.129 940710109 2527.575 940710110 1524.599 940710111 1825.280 2.2.2.2 Nombre de ménages d’une commune par IRIS On calcule le nombre de ménages par IRIS tabmen &lt;- indiv %&gt;% filter(LPRM == 1) %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(COM == &quot;94071&quot;) %&gt;% group_by (IRIS) %&gt;% summarise(nbmen = sum(IPONDI)) `summarise()` ungrouping output (override with `.groups` argument) Puis on effectue la jointure des deux tableaux et on crée une nouvelle variable décrivant le nombre moyen de personnes par ménage tabdon &lt;- left_join(tabpop, tabmen) %&gt;% mutate(tailmen = nbhab/nbmen) Joining, by = &quot;IRIS&quot; kable(tabdon, digits = c(NA,0,0,2)) IRIS nbhab nbmen tailmen 940710101 2151 812 2.65 940710102 2204 822 2.68 940710103 2843 1049 2.71 940710104 2631 1116 2.36 940710105 3006 1287 2.34 940710106 2368 867 2.73 940710107 2545 966 2.63 940710108 2853 1034 2.76 940710109 2528 1289 1.96 940710110 1525 677 2.25 940710111 1825 795 2.30 2.2.3 Ajout de la géométrie Notre tableau des IRIS ne comporte pas actuellement de données géométriques permettant la cartographie et on n’y trouve pas non plus le nom ds IRIS. Nous allons donc extraire ces informations du fichier cartographique. Puis nous allons fusionner les deux fichiers pour faire un objet de type sf(spatial features) qui pourra être facilement utilisé par la suite pour réaliser des cartes. 2.2.3.1 Extraction des IRIS de la commune On charge le fichier des IRIS du départmeent et on extrait de celui-ci les contours IRIS de la commune qui nous intéresse. mymap &lt;- map %&gt;% filter(INSEE_COM == &quot;94071&quot;) %&gt;% select(CODE_IRIS, NOM_IRIS, TYP_IRIS,NOM_COM, geometry) head(mymap) # A tibble: 6 x 5 CODE_IRIS NOM_IRIS TYP_IRIS NOM_COM geometry &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;MULTIPOLYGON [m]&gt; 1 940710107 Notre Dame … H Sucy-en… (((667480.7 6851728, 667498 6851748,… 2 940710103 La Cite Ver… H Sucy-en… (((665121.5 6852886, 665122.9 685287… 3 940710102 La Fosse Ro… H Sucy-en… (((665788.4 6853098, 665788.8 685309… 4 940710111 Gare Varenn… H Sucy-en… (((664052.9 6852830, 664055.5 685282… 5 940710109 Le Centre H Sucy-en… (((664318.9 6852899, 664337.1 685290… 6 940710101 Le Grand Val H Sucy-en… (((664052.9 6852830, 664050.3 685283… 2.2.3.2 Ajout des coordonnées des centres d’IRIS On détermine les centres des quartiers IRIS à l’aide d’un combinaison de fonctions SF et on les ajoute au fichier coo&lt;-as.data.frame(st_coordinates(st_centroid(mymap))) Warning in st_centroid.sf(mymap): st_centroid assumes attributes are constant over geometries of x mymap &lt;-cbind(mymap,coo) kable(mymap) CODE_IRIS NOM_IRIS TYP_IRIS NOM_COM X Y geometry 940710107 Notre Dame … Bruyeres H Sucy-en-Brie 667852.4 6851082 MULTIPOLYGON (((667480.7 68… 940710103 La Cite Verte H Sucy-en-Brie 664869.7 6852686 MULTIPOLYGON (((665121.5 68… 940710102 La Fosse Rouge H Sucy-en-Brie 665269.2 6853014 MULTIPOLYGON (((665788.4 68… 940710111 Gare Varennes Zi H Sucy-en-Brie 663547.5 6852295 MULTIPOLYGON (((664052.9 68… 940710109 Le Centre H Sucy-en-Brie 664634.0 6852430 MULTIPOLYGON (((664318.9 68… 940710101 Le Grand Val H Sucy-en-Brie 664435.3 6853178 MULTIPOLYGON (((664052.9 68… 940710108 Le Petiti Val … Clos de Ville H Sucy-en-Brie 664604.3 6851645 MULTIPOLYGON (((663926.1 68… 940710105 La Procession … Fort H Sucy-en-Brie 665509.4 6852035 MULTIPOLYGON (((665765.1 68… 940710110 Berges Noyers Pv H Sucy-en-Brie 664124.5 6853470 MULTIPOLYGON (((664052.9 68… 940710106 Le Plateau-Parc H Sucy-en-Brie 666195.3 6851330 MULTIPOLYGON (((667480.7 68… 940710104 Les Monrois … Fdv H Sucy-en-Brie 665758.2 6852471 MULTIPOLYGON (((666202.7 68… 2.2.3.3 Visualisation de la carte On visualise la carte des iris à l’aide des fonctions geom_sf et geom_textdu package ggplot2 ggplot(mymap) + geom_sf(fill = &quot;lightyellow&quot;) + geom_text(aes(x=X, y=Y, label = substr(CODE_IRIS,6,9)), colour = &quot;red&quot;) + ggtitle(&quot;Découpage de la commune de Sucy-en-Brie en IRIS&quot;) 2.2.3.4 Jointure des deux fichiers On va maintenant effectuer la joindure avec le tableau de données, mais en faisant attention à recoder la variable IRIS du fichier de données en CODE_IRIS pour assurer la jointure. mapdon &lt;- tabdon %&gt;% rename(CODE_IRIS = IRIS) %&gt;% left_join(mymap) Joining, by = &quot;CODE_IRIS&quot; kable(mapdon) CODE_IRIS nbhab nbmen tailmen NOM_IRIS TYP_IRIS NOM_COM X Y geometry 940710101 2150.932 812.2436 2.648137 Le Grand Val H Sucy-en-Brie 664435.3 6853178 MULTIPOLYGON (((664052.9 68… 940710102 2203.946 822.4033 2.679885 La Fosse Rouge H Sucy-en-Brie 665269.2 6853014 MULTIPOLYGON (((665788.4 68… 940710103 2843.362 1048.7700 2.711140 La Cite Verte H Sucy-en-Brie 664869.7 6852686 MULTIPOLYGON (((665121.5 68… 940710104 2630.590 1115.8427 2.357492 Les Monrois … Fdv H Sucy-en-Brie 665758.2 6852471 MULTIPOLYGON (((666202.7 68… 940710105 3006.213 1287.2656 2.335348 La Procession … Fort H Sucy-en-Brie 665509.4 6852035 MULTIPOLYGON (((665765.1 68… 940710106 2368.138 867.4955 2.729856 Le Plateau-Parc H Sucy-en-Brie 666195.3 6851330 MULTIPOLYGON (((667480.7 68… 940710107 2545.304 966.4696 2.633610 Notre Dame … Bruyeres H Sucy-en-Brie 667852.4 6851082 MULTIPOLYGON (((667480.7 68… 940710108 2853.129 1034.3876 2.758278 Le Petiti Val … Clos de Ville H Sucy-en-Brie 664604.3 6851645 MULTIPOLYGON (((663926.1 68… 940710109 2527.575 1288.7402 1.961276 Le Centre H Sucy-en-Brie 664634.0 6852430 MULTIPOLYGON (((664318.9 68… 940710110 1524.599 677.4526 2.250488 Berges Noyers Pv H Sucy-en-Brie 664124.5 6853470 MULTIPOLYGON (((664052.9 68… 940710111 1825.280 795.1780 2.295436 Gare Varennes Zi H Sucy-en-Brie 663547.5 6852295 MULTIPOLYGON (((664052.9 68… 2.2.3.5 Sauvegarde du résultat On sauvegarde précieusement le fichier final qui servira de référence pour la suite des travaux. saveRDS(mapdon, &quot;data/mapdon_94071.Rdata&quot;) 2.2.4 Automatisation du travail Nous avons maintenant bien décomposé toutes les étapes permettant de créer le fichier de référence pour une commune précise. Il nous reste à automatiser le processus pour une commune quelconque. Nous allons pour cela créer une fonction qui permet de créer pour une commune quelconque son fichier de référence. 2.2.4.1 Ecriture de la fonction Il suffit de reprendre tous les programmes précédents en remplaçant le code 94370 par un argument codecom de la fonction qu’on va appeler mapdon() : mapdon &lt;- function(indiv = indiv, map = map, codecom = &quot;94370&quot;) { # (1) Création du tableau de population par IRIS tabpop &lt;- indiv %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(COM == codecom) %&gt;% group_by (IRIS) %&gt;% summarise(nbhab = sum(IPONDI)) # (2) Création du tableau de ménage par IRIS tabmen &lt;- indiv %&gt;% filter(LPRM == 1) %&gt;% mutate(COM = substr(IRIS,1,5)) %&gt;% filter(COM == codecom) %&gt;% group_by (IRIS) %&gt;% summarise(nbmen = sum(IPONDI)) # (3) Fusion des tableaux de données tabdon &lt;- left_join(tabpop, tabmen) %&gt;% mutate(tailmen = nbhab/nbmen) # (4) Extraction du fonds de carte des IRIS mymap &lt;- map %&gt;% filter(INSEE_COM == codecom) %&gt;% select(CODE_IRIS, NOM_IRIS, TYP_IRIS,NOM_COM, geometry) # (5) Ajout des coordonnées des centres d&#39;IRIS coo&lt;-as.data.frame(st_coordinates(st_centroid(mymap))) mymap &lt;-cbind(mymap,coo) # (6) Fusion des données et de la géométrie mapdon &lt;- tabdon %&gt;% rename(CODE_IRIS = IRIS) %&gt;% left_join(mymap) # (7) Conversion au format sf mapdon&lt;-st_as_sf(mapdon) # (7) Sortie du résultat return(mapdon) } 2.2.4.2 Test de la fonction Essayons maintenant d’appliquer notre fonction à une autre commune comme Saint-Maur-des-Fossés (94068). Il suffit pour cela de lui fournir les trois paramètres correspondant au tableau de données individuelles, au fonds de carte et au code de la commune # indiv &lt;- readRDS(&quot;data/indiv2017.Rdata&quot;) # map &lt;-readRDS(&quot;data/map_iris.Rdata&quot;) stmaur &lt;- mapdon(indiv=indiv, map = map, codecom = &quot;94068&quot;) `summarise()` ungrouping output (override with `.groups` argument) `summarise()` ungrouping output (override with `.groups` argument) Joining, by = &quot;IRIS&quot; Warning in st_centroid.sf(mymap): st_centroid assumes attributes are constant over geometries of x Joining, by = &quot;CODE_IRIS&quot; class(stmaur) [1] &quot;sf&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; kable(head(stmaur)) CODE_IRIS nbhab nbmen tailmen NOM_IRIS TYP_IRIS NOM_COM X Y geometry 940680101 2354.834 1180.1101 1.995436 Adamville 1 H Saint-Maur-des-Fossés 662121.0 6856007 MULTIPOLYGON (((662332.4 68… 940680102 2615.027 1204.4229 2.171187 Adamville 2 H Saint-Maur-des-Fossés 661513.7 6855845 MULTIPOLYGON (((661318.1 68… 940680103 2630.544 1307.0014 2.012656 Adamville 3 H Saint-Maur-des-Fossés 662092.7 6855636 MULTIPOLYGON (((661797 6855… 940680104 2395.176 1156.3000 2.071414 Adamville 4 H Saint-Maur-des-Fossés 662802.3 6855656 MULTIPOLYGON (((662332.4 68… 940680105 2213.094 967.9966 2.286263 Adamville 5 H Saint-Maur-des-Fossés 661794.9 6855206 MULTIPOLYGON (((661810.5 68… 940680106 2561.655 1264.6149 2.025640 Adamville 6 H Saint-Maur-des-Fossés 662302.9 6855263 MULTIPOLYGON (((662285.5 68… On peut visualiser la carte et ses codes : ggplot(stmaur) + geom_sf(fill = &quot;lightyellow&quot;) + geom_text(aes(x=X, y=Y, label = substr(CODE_IRIS,6,9)), colour = &quot;red&quot;) + ggtitle(&quot;Découpage de la commune en IRIS&quot;) Et sauvegarder le résultat s’il est correct : saveRDS(stmaur, &quot;data/mapdon_94068.Rdata&quot;) "],["22-cartographie.html", "Chapitre 3 Cartographie 3.1 Objectifs 3.2 Préparation du tableau de données 3.3 Utilisation du package cartography 3.4 Cartographie avec Leaflet", " Chapitre 3 Cartographie 3.1 Objectifs L’objectif de cette section est de réaliser des cartographies d’indicateurs statistiques relatifs aux unités spatiales à différentes échelles. 3.1.1 Packages utilisés Nous allons nous limiter à un nombre limité de packages dplyr et tidyr: pour la manipulation des tableaux et leur agrégation (inutile de charger l’ensemble du package tidyverse) knitr : pour afficher proprement les tableaux de résultats ggplot2 : pour visualiser les résultats sous formes de graphiques sf : pour manipuler les données cartographiques et les agréger cartography : pour la réalisation de cartes statiques de qualité imprimables aux formats .pdf ou .doc leaflet , htmlwidgets, htmltools pour la réalisation de cartes interactives accessibles sur le web. library(knitr) library(tidyr) library(dplyr) library(ggplot2) library(sf) library(cartography) library(leaflet) library(htmltools) library(htmlwidgets) 3.1.2 Chargement des données Nous avons besoin uniquement de trois fichiers Le fichier des individus le fichier des métadonnées relatives aux individus le fonds de carte des IRIS indiv &lt;- readRDS(&quot;data/indiv2017.Rdata&quot;) meta &lt;- readRDS(&quot;data/indiv2017_meta.Rdata&quot;) map &lt;-readRDS(&quot;data/map_iris.Rdata&quot;) 3.2 Préparation du tableau de données Nous allons prendre comme exemple l’analyse d’un tableau du nombre d’automobiles par ménage en nous limitant aux ménages ordinaires c’est-à-dire en excluant les personnes habitant dans des logements collectifs (pensionnats, prisons, congrégations religieuses, …) Nous ne conservons que les individus chefs de ménages (LPRM=1) ce qui va logiquement éliminer les individus présents dans les ménages non ordinaires (LPRM=Z) ainsi que tous les membres d’un logement qui ne sont pas chefs de ménages. menag&lt;-indiv %&gt;% filter(LPRM==1) 3.2.1 Création du tableau de contingence Nous souhaitons ventiler les ménages en fonction de leur localisation géographique (IRIS) et de leur nombre d’automobile (VOIT) en tenant compte de leur poids (IPONDI) puisque les données sont issues d’uin échantillonage qu’il faut redresser. Cette opération se réalise très facilement à l’aide du package dplyr à l’aide des fonctions group_by, mutate et summarize : tab &lt;- menag %&gt;% group_by(IRIS, VOIT) %&gt;% summarise(nbmen = sum(IPONDI)) %&gt;% ungroup() `summarise()` regrouping output by &#39;IRIS&#39; (override with `.groups` argument) str(tab) tibble [2,070 × 3] (S3: tbl_df/tbl/data.frame) $ IRIS : chr [1:2070] &quot;940020101&quot; &quot;940020101&quot; &quot;940020101&quot; &quot;940020101&quot; ... $ VOIT : chr [1:2070] &quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; ... $ nbmen: num [1:2070] 674.1 679.5 142.2 29.5 801.4 ... head(tab,5) # A tibble: 5 x 3 IRIS VOIT nbmen &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 940020101 0 674. 2 940020101 1 679. 3 940020101 2 142. 4 940020101 3 29.5 5 940020102 0 801. Le résultat est un tibble au format “long” qui comporte 4 lignes différentes pour chaque IRIS, correspondant aux nombres de ménages ayant respectivement 0, 1, 2 et 3 voitures ou plus. Nous allons transformer ce tableau en format “large” pour placer côte à côte les différentes modalités du nombre de voitures. Pour cela il faut utiliser la fonction pivot_widerdu package tidyr. library(tidyr) tabcont &lt;- tab %&gt;% pivot_wider(names_from = VOIT, values_from = nbmen, names_prefix = &quot;MEN_VOIT&quot;, values_fill = 0) head(tabcont) # A tibble: 6 x 5 IRIS MEN_VOIT0 MEN_VOIT1 MEN_VOIT2 MEN_VOIT3 &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 940020101 674. 679. 142. 29.5 2 940020102 801. 903. 170. 24.8 3 940020103 661. 703. 76.0 10.6 4 940020104 694. 701. 126. 23.0 5 940020105 434. 960. 237. 29.3 6 940020106 625. 735. 166. 29.2 Grâce à cette transformation, nous disposons maintenant pour chaque IRIS de la distribution des ménages en fonction de leur nombre de voitures, ce qui constitue le tableau de contingence recherché. 3.2.2 Ajout d’un tableau de pourcentage Nous allons maintenant calculer le nombre total de ménage puis en déduire la proportion de ménages en fonction de leur nombre d’automobile pour chacun des IRIS. tabdon &lt;- tabcont %&gt;% mutate (MEN_TOTAL = MEN_VOIT0+MEN_VOIT1+MEN_VOIT2+MEN_VOIT3, PCT_VOIT0 = 100* MEN_VOIT0 / MEN_TOTAL, PCT_VOIT1 = 100* MEN_VOIT1 / MEN_TOTAL, PCT_VOIT2 = 100* MEN_VOIT2 / MEN_TOTAL, PCT_VOIT3 = 100* MEN_VOIT3 / MEN_TOTAL) head(tabdon[,c(1,6:10)]) # A tibble: 6 x 6 IRIS MEN_TOTAL PCT_VOIT0 PCT_VOIT1 PCT_VOIT2 PCT_VOIT3 &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 940020101 1525. 44.2 44.5 9.32 1.93 2 940020102 1899. 42.2 47.6 8.93 1.31 3 940020103 1450. 45.6 48.5 5.24 0.729 4 940020104 1544. 45.0 45.4 8.14 1.49 5 940020105 1660. 26.1 57.8 14.3 1.76 6 940020106 1555. 40.2 47.3 10.7 1.87 3.2.3 Estimation du nombre moyen d’automobile par menages Il n’est pas possible d’estimer le nombre exact d’automobile par ménage car l’INSEE ne détaille pas la catégorie VOIT = 3 qui correspond à “Trois automobiles ou +”. On peut néanmoins procéder à une estimation minimale du nombre d’automobile en supposant que les ménages de ce type ont exactement rois automobiles. On en déduit alors le nombre total d’automobile par IRIS (VOIT_TOTAL) et le nombre moyen d’automobile par ménage (VOIT_MEN). tabdon &lt;-tabdon %&gt;% mutate(VOIT_TOTAL = MEN_VOIT1 + 2*MEN_VOIT2 + 3*MEN_VOIT3, VOIT_MEN = VOIT_TOTAL / MEN_TOTAL) head(tabdon[,c(1,6,11,12)]) # A tibble: 6 x 4 IRIS MEN_TOTAL VOIT_TOTAL VOIT_MEN &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 940020101 1525. 1052. 0.690 2 940020102 1899. 1317. 0.694 3 940020103 1450. 886. 0.611 4 940020104 1544. 1021. 0.662 5 940020105 1660. 1522. 0.917 6 940020106 1555. 1154. 0.742 3.2.4 Analyse du tableau Avant de passer à la cartographie, on peut analyser quelques variables intéressantes. 3.2.4.1 Part des ménages sans automobiles Les ménages sans automobiles sont une catégorie intéressante, même si elle peut recouper des situations très diverses (étudiants, personnes âgées, pauvres, …). summary(tabdon$PCT_VOIT0) Min. 1st Qu. Median Mean 3rd Qu. Max. 0.00 21.94 30.95 31.13 40.84 65.31 ggplot(tabdon, aes(x=PCT_VOIT0)) + geom_histogram(bins=20, fill=&quot;gray30&quot;) + scale_y_continuous(&quot;Nombre d&#39;IRIS&quot;)+ scale_x_continuous(&quot;% de ménages&quot;)+ ggtitle(&quot;Par des ménages sans automobiles en 2017&quot;) La distribution apparaît très variable puisque les ménages sans automobiles sont absents de certains IRIS alors qu’ils représentent plus de la moitié des ménages dans d’autres IRIS. 3.2.4.2 Nombre moyen d’automobiles par ménage Même s’il est légèrement sous-estimé, le nombre d’automobile par ménage est un bon indicateur de la dépendance de certains logements mals desservis par les transports en commun. summary(tabdon$VOIT_MEN) Min. 1st Qu. Median Mean 3rd Qu. Max. 0.3944 0.7190 0.8675 0.9003 1.0458 2.0000 ggplot(tabdon, aes(x=VOIT_MEN)) + geom_histogram(bins=20, fill=&quot;gray30&quot;) + scale_y_continuous(&quot;Nombre d&#39;IRIS&quot;)+ scale_x_continuous(&quot;voitures / ménage&quot;)+ ggtitle(&quot;Nombre moyen d&#39;automobile par ménage en 2017&quot;) Alors qu’on trouve en général entre 0.6 et 1.2 automobiles par ménage, certains IRIS affichent des valeurs moyennes de 1.5 à 2 automobiles par ménage. 3.2.5 Sauvegarde du tableau et jointure avec le fonds de carte On commence par effectuer une sauvegarde simple de notre tableau : saveRDS(tabdon,&quot;data/VOIT_IRIS.Rdata&quot;) Puis on effectue une jointure avec le fonds de carte map_iris et on réalise une sauvegarde sous un autre nom. tabfin&lt;-tabdon %&gt;% rename(CODE_IRIS = IRIS) map_VOIT_IRIS&lt;-left_join(map, tabfin) %&gt;% st_as_sf() Joining, by = &quot;CODE_IRIS&quot; saveRDS(map_VOIT_IRIS, &quot;data/map_VOIT_IRIS.Rdata&quot;) 3.3 Utilisation du package cartography Le package cartography permet de réaliser des cartes statiques de très haute qualité. Il a en effet été mis au point par des cartographes et des géomaticiens professionnels. Il propose une gamme de possibilités sans équivalent. On ne verra ici qu’une toute petite partie de ses possibilités. 3.3.1 Carte de stock Une carte de stock représente la localisation de quantités que l’on peut aditionner et dont le total a un sens. Par exemple un nombre d’habitants, un nombre de ménages, un nombre d’automobiles. Ce quantités doivent être représentées par des figures (cercles, carrés, …) dont la surface est proportionelle au stock afin que l’oeil du lecteur puisse les aditionner visuellement. Dans le package cartography, on réalise ce type de carte à l’aide de la fonction PropSymbolLayer et on complète l’habillage de la carte (titre, sources, auteur, …) à l’aide de la fonction layoutLayer 3.3.1.1 Distribution des ménages map_com&lt;-readRDS(&quot;data/map_com.Rdata&quot;) map_iris&lt;-readRDS(&quot;data/map_VOIT_IRIS.Rdata&quot;) par(mar=c(0,0,2,0)) plot(map_iris$geometry, col=&quot;lightyellow&quot;, border=&quot;gray80&quot;,lwd=0.4) plot(map_com$geometry, col=NA, border=&quot;gray40&quot;,lwd=0.8, add=T) propSymbolsLayer(x = map_iris, var = &quot;MEN_TOTAL&quot;, col=&quot;blue&quot;, inches = 0.06, legend.title.txt = &quot;Nb ménages&quot;, legend.pos = &quot;left&quot;) layoutLayer(title = &quot;Distribution des ménages du Val de Marne en 2017&quot;, author = &quot;Master MECI / Option data mining&quot;, sources = &quot;INSEE, RP 2017, fichiers détail&quot;) 3.3.1.2 Distribution des automobiles map_com&lt;-readRDS(&quot;data/map_com.Rdata&quot;) map_iris&lt;-readRDS(&quot;data/map_VOIT_IRIS.Rdata&quot;) par(mar=c(0,0,2,0)) plot(map_iris$geometry, col=&quot;lightyellow&quot;, border=&quot;gray80&quot;,lwd=0.4) plot(map_com$geometry, col=NA, border=&quot;gray40&quot;,lwd=0.8, add=T) propSymbolsLayer(x = map_iris, var = &quot;VOIT_TOTAL&quot;, col=&quot;red&quot;, inches = 0.06, legend.title.txt = &quot;nb. véhicules&quot;, legend.pos = &quot;left&quot;) layoutLayer(title = &quot;Distribution des automobiles des ménages du Val de Marne en 2017&quot;, author = &quot;Master MECI / Option data mining&quot;, sources = &quot;INSEE, RP 2017, fichiers détail&quot;) 3.3.2 Carte d’intensité (choroplèthe) Une carte d’intensité représente un phénomène relatif dont la somme n’a pas de sens. Par exemple, il serait absurde d’aditionner les nombres d’automobiles par habitant des IRIS du Val de Marne. Ces variables d’intensité caractèrisent donc l’état général d’une zone (choros) at elles vont être représentées par une couleur appliquée à toute la surface de la zone, d’où leur nom de cartes choroplèthes. La fonction u package cartography adaptée aux variables d’intensité est la fonction Chorolayer. Comme précédemment on la combine avec la fonction LayoutLayerpour réaliser l’habillage de la carte. 3.3.2.1 Part des ménages sans automobile On va réaliser une carte allant du vert clair au vert foncé au fur et à mesure que le nombre de ménages sans automobiles augmente. map_com&lt;-readRDS(&quot;data/map_com.Rdata&quot;) map_iris&lt;-readRDS(&quot;data/map_VOIT_IRIS.Rdata&quot;) par(mar=c(0,0,2,0)) mybreaks = c(0, 10, 20, 30, 40, 50, 60, 70) mycols &lt;-carto.pal(pal1 = &quot;green.pal&quot;, n1 = 7) choroLayer(x = map_iris, var = &quot;PCT_VOIT0&quot;, breaks = mybreaks, col= mycols, lwd=0.2, colNA = &quot;gray80&quot;, legend.title.txt = &quot;% ménages&quot;, legend.pos = &quot;left&quot;, legend.values.rnd = 2, legend.nodata = &quot;Pas de données&quot;) plot(map_com$geometry, col=NA, border=&quot;gray10&quot;,lwd=0.8, add=T) layoutLayer(title = &quot;Part des ménages sans automobiles du Val de Marne en 2017&quot;, author = &quot;Master MECI / Option data mining&quot;, sources = &quot;INSEE, RP 2017, fichiers détail&quot;) 3.3.2.2 Nombre moyen d’automobiles par ménage On va prendre comme référence la valeur de 1 automobile par ménage et on va construire une double palette qui se dirrige vers le brun lorsque le nombre d’automobile par ménage augmente et vers l’orange lorsque le nombre d’automobile par ménage diminue map_com&lt;-readRDS(&quot;data/map_com.Rdata&quot;) map_iris&lt;-readRDS(&quot;data/map_VOIT_IRIS.Rdata&quot;) par(mar=c(0,0,2,0)) mybreaks = c(0.3,0.5, 0.6,0.7,0.8,0.9, 1,1.1, 1.2,1.3,1.4,1.5,2.1) mycols &lt;-carto.pal(pal1 = &quot;green.pal&quot;, n1 = 6, pal2 = &quot;orange.pal&quot;, n2 = 6) choroLayer(x = map_iris, var = &quot;VOIT_MEN&quot;, breaks = mybreaks, col= mycols, lwd=0.2, colNA = &quot;gray80&quot;, legend.title.txt = &quot;auto. / menage&quot;, legend.pos = &quot;left&quot;, legend.values.rnd = 2, legend.nodata = &quot;Pas de données&quot;) plot(map_com$geometry, col=NA, border=&quot;gray10&quot;,lwd=0.8, add=T) layoutLayer(title = &quot;Dépendance automobile des ménages du Val de Marne en 2017&quot;, author = &quot;Master MECI / Option data mining&quot;, sources = &quot;INSEE, RP 2017, fichiers détail&quot;) 3.3.3 Carte de stock + intensité On peut combiner les deux modes cartographiques. Prenons à titre d’exemple le cas des ménages ayant trois automobiles ou plus. Onn peut décrire ce phénomène soit en terme de stock, soit en termes d’intensité. summary(map_iris$MEN_VOIT3) Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s 0.00 12.50 21.42 26.20 33.77 145.76 9 summary(map_iris$PCT_VOIT3) Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s 0.000 1.170 1.943 2.510 3.160 16.114 9 On réalise les deux cartes successivement en commençant par la carte de taux puis en lui ajoutant la carte de stock par dessus. map_com&lt;-readRDS(&quot;data/map_com.Rdata&quot;) map_iris&lt;-readRDS(&quot;data/map_VOIT_IRIS.Rdata&quot;) par(mar=c(0,0,2,0)) mybreaks = c(0, 1,2,4,8,17) mycols &lt;-carto.pal(pal1 = &quot;taupe.pal&quot;, n1 = 5) choroLayer(x = map_iris, var = &quot;PCT_VOIT3&quot;, breaks = mybreaks, col= mycols, lwd=0.2, colNA = &quot;gray80&quot;, legend.title.txt = &quot;% ménages&quot;, legend.pos = &quot;topleft&quot;, legend.values.rnd = 2, legend.nodata = &quot;Pas de données&quot;) plot(map_com$geometry, col=NA, border=&quot;gray10&quot;,lwd=0.8, add=T) propSymbolsLayer(x = map_iris, var = &quot;MEN_VOIT3&quot;, col=&quot;red&quot;, inches = 0.06, legend.title.txt = &quot;nb. ménages&quot;, legend.pos = &quot;left&quot;) layoutLayer(title = &quot;Nombre et proportion des ménages ayant 3 automobiles ou plus en 2017&quot;, author = &quot;Master MECI / Option data mining&quot;, sources = &quot;INSEE, RP 2017, fichiers détail&quot;) 3.4 Cartographie avec Leaflet Le package Leaflet est particulièrement adapté aux cartographies locales et aux publication sur le web au format .html. Nous allons ici l’utiliser pour réaliser des zoom à l’échelle d’une commune. 3.4.1 Extraction du fonds de carte d’une ou plusieurs commune Nous reprenons notre fichier de données sur l’automobile en ne conservant par exemple que les communes de Sucy-en-Brie (94071), Bonneuil (94011), Ormesson (94055), Chennevières sur Marne (94019) et Saint-Maur (94068) sel &lt;- c(&quot;94071&quot;, &quot;94011&quot;,&quot;94055&quot;,&quot;94068&quot;, &quot;94019&quot;) map_iris &lt;-readRDS(&quot;data/map_VOIT_IRIS.Rdata&quot;) sel_iris &lt;-map_iris %&gt;% filter(INSEE_COM %in% sel) map_com &lt;-readRDS(&quot;data/map_com.Rdata&quot;) sel_com &lt;-map_com %&gt;% filter(INSEE_COM %in% sel) par(mar=c(0,0,0,0)) plot(sel_iris$geometry, col=&quot;lightyellow&quot;, border=&quot;gray80&quot;, lwd=0.5) plot(sel_com$geometry, col=NA, border=&quot;gray40&quot;, lwd=1, add=TRUE) 3.4.2 Projection et calcul des centres Le package Leaflet ne peut utiliser les fonds de carte que s’ils utilisent une projection spécifique en latitude longitude (projection 4326) permettant d’ajouter des “tuiles” cartographiques en arrière plan (typiquement, des plans de rue). Cette opération est effectuée à l’aide de la commande st_transfrom du package sf. Il est par ailleurs intéressant de calculer pour chaque unité spatiale un centre qui pourra être utilisé pour représenter des données sous la forme de points sel_com &lt;- st_transform(sel_com, 4326) sel_com_ctr &lt;-st_centroid(sel_com) Warning in st_centroid.sf(sel_com): st_centroid assumes attributes are constant over geometries of x Warning in st_centroid.sfc(st_geometry(x), of_largest_polygon = of_largest_polygon): st_centroid does not give correct centroids for longitude/ latitude data sel_iris &lt;- st_transform(sel_iris, 4326) sel_iris_ctr&lt;-st_centroid(sel_iris) Warning in st_centroid.sf(sel_iris): st_centroid assumes attributes are constant over geometries of x Warning in st_centroid.sf(sel_iris): st_centroid does not give correct centroids for longitude/latitude data par(mar=c(0,0,0,0)) plot(sel_iris$geometry, col=&quot;lightyellow&quot;, border=&quot;blue&quot;, lwd=0.5) plot(sel_iris_ctr$geometry, col=&quot;blue&quot;, lwd=0.2, add=TRUE) plot(sel_com$geometry, col=NA, border=&quot;red&quot;, lwd=2, add=TRUE) plot(sel_com_ctr$geometry, col=&quot;red&quot;, lwd=2, add=TRUE) 3.4.3 Etape 1 : centrage et niveau de zoom Le package Leaflet est fondé sur l’usage de tuiles disponibles à différentes échelles et qu’il faut centrer sur la zone d’étude à l’aide des coordonnées de latitude et longitude. Si l’on veut par exemple travaillr sur Sucy-en-Brie, il faut trouver ses coordonnées sur le fonds de carte projeté en latitude longitude : sel_com %&gt;% filter(INSEE_COM ==&quot;94071&quot;) %&gt;% st_centroid() %&gt;% st_coordinates() Warning in st_centroid.sf(.): st_centroid assumes attributes are constant over geometries of x Warning in st_centroid.sfc(st_geometry(x), of_largest_polygon = of_largest_polygon): st_centroid does not give correct centroids for longitude/ latitude data X Y 1 2.533255 48.76564 En ce qui concerne le niveau de zoom, on le trouve plutôt par essai et erreur. Dans notre exemple un zoom de niveau 12 sera adapté p &lt;- leaflet() %&gt;% addTiles() %&gt;% setView(lng =2.533, lat=48.765, zoom = 12) p 3.4.4 Etape 2 : Choix des tuiles Par défaut, Leaflet propose les “tuiles” d’OpenStreetMap, mais on peut en choisir d’autres. Par exemple, un fonds de carte npir et blanc peut être intéressant pour ne pas gêner la superposition de cartes ebn couleur. p &lt;- leaflet() %&gt;% addTiles() %&gt;% addProviderTiles(providers$Stamen.TonerLite) %&gt;% setView(lng =2.533, lat=48.765, zoom = 12) p 3.4.5 Etape 3 : Ajout d’une carte choroplèthe On décide d’ajouter le contour des IRIS des communes avec des couleurs correspondant à la variable dépendance automobile. mycut&lt;-quantile(sel_iris$VOIT_MEN, c(0,1/6, 2/6, 3/6,4/6,5/6,1 )) bin_pal = colorBin(&#39;Spectral&#39;, sel_iris$VOIT_MEN, bins=mycut, reverse=T,) p &lt;- leaflet() %&gt;% addTiles() %&gt;% addProviderTiles(providers$Stamen.TonerLite) %&gt;% setView(lng =2.533, lat=48.765, zoom = 12) %&gt;% addPolygons(data = sel_iris, fillColor = ~bin_pal(VOIT_MEN), color = &#39;grey&#39;, weight = 0.4, fillOpacity = 0.6, highlightOptions = highlightOptions(weight = 2, color = &#39;black&#39;)) %&gt;% addLegend(data = sel_iris, pal = bin_pal, title = &quot;Dépendance automobile&quot;, values = ~VOIT_MEN, position = &#39;topright&#39;,) p 3.4.6 Etape 4 : ajout d’une carte de stock mycut&lt;-quantile(sel_iris$VOIT_MEN, c(0,1/6, 2/6, 3/6,4/6,5/6,1 )) bin_pal = colorBin(&#39;Spectral&#39;, sel_iris$VOIT_MEN, bins=mycut, reverse=T,) p &lt;- leaflet() %&gt;% addTiles() %&gt;% addProviderTiles(providers$Stamen.TonerLite) %&gt;% setView(lng =2.533, lat=48.765, zoom = 12) %&gt;% addPolygons(data = sel_iris, fillColor = ~bin_pal(VOIT_MEN), color = &#39;grey&#39;, weight = 0.4, fillOpacity = 0.6, highlightOptions = highlightOptions(weight = 2, color = &#39;black&#39;)) %&gt;% addLegend(data = sel_iris, pal = bin_pal, title = &quot;Voiture / ménage&quot;, values = ~VOIT_MEN, position = &#39;topright&#39;,) %&gt;% addCircleMarkers(data=st_centroid(sel_iris$geometry, quiet =T), radius = 8*sqrt(sel_iris$VOIT_TOTAL/max(sel_iris$VOIT_TOTAL)), fillColor = &quot;gray50&quot;, stroke = FALSE, fillOpacity = 0.5) Warning in st_centroid.sfc(sel_iris$geometry, quiet = T): st_centroid does not give correct centroids for longitude/latitude data p 3.4.7 Etape 5 : ajout du contour des communes mycut&lt;-quantile(sel_iris$VOIT_MEN, c(0,1/6, 2/6, 3/6,4/6,5/6,1 )) bin_pal = colorBin(&#39;Spectral&#39;, sel_iris$VOIT_MEN, bins=mycut, reverse=T,) p &lt;- leaflet() %&gt;% addTiles() %&gt;% addProviderTiles(providers$Stamen.TonerLite) %&gt;% setView(lng =2.533, lat=48.765, zoom = 12) %&gt;% addPolygons(data = sel_iris, fillColor = ~bin_pal(VOIT_MEN), color = &#39;grey&#39;, weight = 0.4, fillOpacity = 0.6, highlightOptions = highlightOptions(weight = 2, color = &#39;black&#39;)) %&gt;% addLegend(data = sel_iris, pal = bin_pal, title = &quot;Voiture / ménage&quot;, values = ~VOIT_MEN, position = &#39;topright&#39;,) %&gt;% addCircleMarkers(data=st_centroid(sel_iris$geometry, quiet =T), radius = 8*sqrt(sel_iris$VOIT_TOTAL/max(sel_iris$VOIT_TOTAL)), fillColor = &quot;gray50&quot;, stroke = FALSE, fillOpacity = 0.5) %&gt;% addPolygons(data =sel_com, fill= FALSE, color = &#39;black&#39;,weight =2) Warning in st_centroid.sfc(sel_iris$geometry, quiet = T): st_centroid does not give correct centroids for longitude/latitude data p 3.4.8 Etape 6 : Ajout d’un curseur interactif En ajoutant le package htmltools # Round values sel_iris&lt;-sel_iris %&gt;% mutate(MEN_TOTAL = round(MEN_TOTAL,0), VOIT_TOTAL = round(VOIT_TOTAL,0), VOIT_MEN = round(VOIT_MEN,2)) # Define class mycut&lt;-quantile(sel_iris$VOIT_MEN, c(0,1/6, 2/6, 3/6,4/6,5/6,1 )) bin_pal = colorBin(&#39;Spectral&#39;, sel_iris$VOIT_MEN, bins=mycut, reverse=T,) # Define labels labs &lt;- lapply(seq(nrow(sel_iris)), function(i) { paste0( paste(&quot;Commune :&quot;,sel_iris$NOM_COM[i]), &#39;&lt;p&gt;&lt;/p&gt;&#39;, paste(&quot;Code Iris :&quot; ,sel_iris$IRIS[i]), &#39;&lt;p&gt;&lt;/p&gt;&#39;, paste(&quot;Nom Iris :&quot; ,sel_iris$NOM_IRIS[i]), &#39;&lt;p&gt;&lt;/p&gt;&#39;, paste(&quot;Nb de ménages :&quot;,sel_iris$MEN_TOTAL[i]), &#39;&lt;p&gt;&lt;/p&gt;&#39;, paste(&quot;Nb de voitures:&quot;, sel_iris$VOIT_TOTAL[i]),&#39;&lt;p&gt;&lt;/p&gt;&#39;, paste(&quot;Voitures/Ménage:&quot;, sel_iris$VOIT_MEN[i]),&#39;&lt;p&gt;&lt;/p&gt;&#39; ) }) labs&lt;-lapply(labs, htmltools::HTML) p &lt;- leaflet() %&gt;% addTiles() %&gt;% addProviderTiles(providers$Stamen.TonerLite) %&gt;% setView(lng =2.533, lat=48.765, zoom = 12) %&gt;% addPolygons(data = sel_iris, fillColor = ~bin_pal(VOIT_MEN), color = &#39;grey&#39;, weight = 0.4, fillOpacity = 0.6, highlightOptions = highlightOptions(weight = 2, color = &#39;black&#39;), label = labs) %&gt;% addLegend(data = sel_iris, pal = bin_pal, title = &quot;Voiture / ménage&quot;, values = ~VOIT_MEN, position = &#39;topright&#39;,) %&gt;% addCircleMarkers(data=st_centroid(sel_iris$geometry, quiet =T), radius = 8*sqrt(sel_iris$VOIT_TOTAL/max(sel_iris$VOIT_TOTAL)), fillColor = &quot;gray50&quot;, stroke = FALSE, fillOpacity = 0.5) %&gt;% addPolygons(data =sel_com, fill= FALSE, color = &#39;black&#39;,weight =2) Warning in st_centroid.sfc(sel_iris$geometry, quiet = T): st_centroid does not give correct centroids for longitude/latitude data p "]]

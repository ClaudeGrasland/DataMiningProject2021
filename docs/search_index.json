[["11-data.html", "Chapitre 1 Collecte de données statistiques et spatiales 1.1 Introduction 1.2 Données statistiques sur les individus 1.3 Données statistiques sur les logements ordinaires 1.4 Données géométriques 1.5 Bilan et nettoyage", " Chapitre 1 Collecte de données statistiques et spatiales library(knitr) library(dplyr) library(data.table) library(readr) library(sf) library(ggplot2) 1.1 Introduction Lobjectif du projet Data Mining 2021 consistera à étudier les inégalités sociales et spatiales dans le département du Val de Marne à partir des données du dernier recensement de population de 2017. Ces inégalités seront envisagées à différentes échelles ce qui impliquera des procédures dagrégation des fichiers détails. 1.2 Données statistiques sur les individus Nous partirons des fichiers détail de lINSEE car, à la différence des tableaux prédéfinis, ils permettent virtuellement toutes les formes de croisement dindicateurs. Ils sont évidemment beaucoup plus volumineux, mais ce sera justement loccasion pour les étudiants en data mining dêtre confrontés à des problèmes doptimisation et de big data. On trouve leur description détaillée sur le site de lINSEE dans la page consacrée au recensement : https://www.insee.fr/fr/statistiques/4508161 Nous avons opté pour le fichier des individus localisés au canton-ou-ville qui présente une grande polyvalence dusage puisquil permet de reconstituer des tableau agrégés ou lunité de compte peut-être soit le ménage, soit lindividu selon le critère de pondération adopté. 1.2.1 Etape 1 : téléchargement des données et stockage temporaire Nous allons télécharger ici le fichier des données pour la région Ile-de-France au format .csv et lenregistrer dans un dossier spécial tmp qui pourra ulétérieurement être détruit ou déplacé afin de libérer de la place N.B. Ce programme qui prend quelques minutes sera exécuté une seule fois. On ajoutera ensuite dans len-tête du chunk eval=FALSE ce qui veut dire que ce bloc de code ne sera plus executé automatiquement lorsquon réalise un knit du document Rmd. Il sera néanmoins toujours possible de lexecuter manuellement en cliquant sur sa petite flèche verte. ### Téléchargement du fichier INSEE download.file(url=&quot;https://www.insee.fr/fr/statistiques/fichier/4802064/RP2017_INDCVIZA_csv.zip&quot;, destfile = &quot;tmp/indiv2017.zip&quot;) ## Decompression du fichier INSEE unzip(zipfile = &quot;tmp/indiv2017.zip&quot;, exdir = &quot;tmp&quot;) ## Examen du contenu list.files(&quot;tmp&quot;) Nous constatons que le document zippé contenait en fait deux fichiers différents Le fichier de données individuelles FD_INDCVIZA_2017.csv : qui pèse au bas mot 1014.3 Mo (1 Giga) et dont nous verrons par la suite quil comporte 4.3 millions de lignes et 88 colonnes. Le fichier de métadonnées varmod_INDCVI_2017.csv : qui ne pèse que 1.8 Mo et comprend la description précise du label de chacune des modalités de variables. 1.2.2 Etape 2 : Transformation des données au format R Limportation dun tableau aussi gros (4.3 millions de lignes et 88 colonnes) donne loccasion de faire quelques tests de vitesses sur les différents packages capables de lire des fichiers .csv. Nous allons pour cela utiliser la fonction Sys.time()qui permet de repérer lheure au début et à la fin dune action. Les résultats dépendront évidemment de la vitesse de lordinateur. Il sagit ici dun MacBook Pro 2.9 Ghz, disposant de 4 coeurs et 16 Go de mémoire. 1.2.2.1 Chargement avec la fonction read.csv Avec la fonctionread.csv ui fait partie du R-base , le temps de chargement est de 150 secondes. Le tableau résultant est de classe data.frame puisque nous avons utilisé une fonction native de R-base t1&lt;-Sys.time() tab&lt;-read.csv(&quot;tmp/FD_INDCVIZA_2017.csv&quot;, sep = &quot;;&quot;, header =T) t2&lt;-Sys.time() paste (&quot;chargement effectué en&quot;,t2-t1,) dim(tab) class(tab) 1.2.2.2 Chargement avec la fonction read_csv2 avec la fonction read_csv2 du package readr, le chargement est effectué en 59 secondes sur le même ordinateur. Le tableau résultant garde la classe data.frame mais est aussi un tibble puisque le package readr fait partie de lécosystème tibble/tidyverse. Le temps de chrgement est donc divisé par deux. library(readr) t1&lt;-Sys.time() tab&lt;-read_csv2(&quot;tmp/FD_INDCVIZA_2017.csv&quot;) t2&lt;-Sys.time() paste (&quot;chargement effectué en&quot;,t2-t1, &quot;secondes&quot;) dim(tab) class(tab) 1.2.2.3 Chargement avec la fonction fread avec la fonction fread du package data.table, le chargement est effectué en 31 secondes sur le même ordinateur.Le tableau résultant conserve la classe data.frame mais possède aussi la classe data.table puisque la fonction fread est issue de ce package. Le temps est divisé encore une fois par deux. library(data.table) t1&lt;-Sys.time() tab&lt;-fread(&quot;tmp/FD_INDCVIZA_2017.csv&quot;) t2&lt;-Sys.time() paste (&quot;chargement effectué en&quot;,t2-t1, &quot;secondes&quot;) dim(tab) class(tab) On voit donc que le temps de chargement peut différer fortement selon le choix des packages. Il en va ensuite de même pour les traitements dagrégation des données qui seront plus ou moins rapides selon que lon utilise les fonctions de R-base applicables à un data.frame, celles du package tidyverse applicables à un tibble ou enfin celles du package data.table applicables à un data.table. 1.2.3 Etape 3 : Sélection des données utiles et sauvegarde au format .Rdata Nos différentes tableaux peuvent être enregistés au format interne de .R ce qui réduira considérablement leur taille par rapport au fichier texte au format csv qui pèse 1.06 Go. Nous allons également limiter la taille du document en ne conservant que les données qui nous intéressent, en loccurence celles du département du Val de Marne. Comme ces données bvont nous servir durant tout le projet, elles seront stockées dans le dossier data situé à lintérieur du projet et non pas dans le dossier tmp qui sera détruit si lon nen a plus besoin pour libérer de la place. N.B. On ramène lobjet à la classe dobjet unique data.frame pour éviter des conflits possibles entre package. On pourra toujours le retransformer ensuite en data.table ou en tibble. ## Chargement avec fread (+ rapide) tab&lt;-fread(&quot;tmp/FD_INDCVIZA_2017.csv&quot;) ## Suppression de la classe data.table tab&lt;-as.data.frame(tab) ## Selection des données relatives au Val de Marne sel &lt;- tab %&gt;% filter(DEPT == 94) ## Vérification des dimensions du tableau dim(sel) ## Sauvegarde au format RDS saveRDS(object = sel, file = &quot;data/indiv2017.Rdata&quot;) On peut effectuer de façon facultative une sauvegarde au format .csv ce qui évitera des problème douverture du fichier .Rdata pour les personnes ayant des versions anciennes de R. Mais du coup cela engendrera un fichier très volumineux (200 Mo). ## Sauvegarde au format CSV (facultatif) write.table(x=sel, file = &quot;data/indiv2017.csv&quot;, sep=&quot;;&quot;, dec = &quot;.&quot;, fileEncoding = &quot;UTF-8&quot;) 1.2.3.1 Etape 4 : Chargement et sauvegarde des méta-données Il ne faut surtout pas oublier le fichier des métadonnées qui va permettre de recoder facilement tous les facteurs et de décoder les chiffres correspondant aux classes. On va donc le transformer au format R puis lenregistrer également dans le dossier data. # Lecture du fichier de métadonnées meta&lt;-fread(&quot;tmp/varmod_INDCVI_2017.csv&quot;) # Enregistrement dans le dossier data saveRDS(object = meta, file = &quot;data/indiv2017_meta.Rdata&quot;) 1.3 Données statistiques sur les logements ordinaires Nous allons reproduire sans les commenter de façon aussi détaillée les mêmes étapes que précédemment pour construire un fichier des logements ordinaires dont la description se trouve à ladresse suivante : https://www.insee.fr/fr/statistiques/4802056?sommaire=4508161 1.3.1 Etape 1 : récupération des fichiers ### Téléchargement du fichier INSEE download.file(url=&quot;https://www.insee.fr/fr/statistiques/fichier/4802056/RP2017_LOGEMTZA_csv.zip&quot;, destfile = &quot;tmp/logmt2017.zip&quot;) ## Decompression du fichier INSEE unzip(zipfile = &quot;tmp/logmt2017.zip&quot;, exdir = &quot;tmp&quot;) ## Examen du contenu list.files(&quot;tmp&quot;) Comme dans le cas du fichier des individus, on trouve un fichier des données et un fichier des métadonnées quil faut tous les deux récupérer. 1.3.2 Etape 2 : Transformation des données au format R On utilise la fonction fread du package data.table qui est la plus rapide ## Chargement avec fread (+ rapide) tab&lt;-fread(&quot;tmp/FD_LOGEMTZA_2017.csv&quot;) 1.3.3 Etape 3 : Sélection des données utiles et sauvegarde au format .Rdata On remet le tableau au format standard data.frame , on sélectionne la zone détude et on sauvegarde au format .Rdata. N.B Comme la variable DEPT nexiste pas on utilise les deux premiers chiffres du code de la variable COMMUNE pour la créer ## Suppression de la classe data.table tab&lt;-as.data.frame(tab) ## Selection des données relatives au Val de Marne sel &lt;- tab %&gt;% mutate(DEPT = substr(COMMUNE,1,2)) %&gt;% filter(DEPT == &quot;94&quot;) ## Vérification des dimensions du tableau dim(sel) ## Sauvegarde au format RDS saveRDS(object = sel, file = &quot;data/logmt2017.Rdata&quot;) 1.3.3.1 Etape 4 : Chargement et sauvegarde des méta-données Comme dans le cas des logements, on sauvegarde précieusement le fichier des métadonnées. # Lecture du fichier de métadonnées meta&lt;-fread(&quot;tmp/varmod_LOGEMT_2017.csv&quot;) # Enregistrement dans le dossier data saveRDS(object = meta, file = &quot;data/logmt2017_meta.Rdata&quot;) 1.4 Données géométriques Les contours des unités spatiales correspondant aux codes de lINSEE sont produits par lIGN et disponibles sur le site géoservice en accès libre : https://geoservices.ign.fr/documentation/diffusion/telechargement-donnees-libres.html 1.4.1 Etape 1 : récupération du fonds IRIS au format shapefile La principale difficulté est de sorienter dans lensemble des produits disponibles. Dans lexemple présent, nous cherchhons le contour des IRIS, cest-à-dire des entités infra-communales correspondant au découpage utilisé lors du recensement de 2017. Comme précédemment, nous allons stocker le résultat du téléchargement dans notre fichier tmp qui sera détruit ou déplacé lorsque nous aurons récupéré toutes les données utiles. download.file(url=&quot;https://wxs.ign.fr/1yhlj2ehpqf3q6dt6a2y7b64/telechargement/inspire/CONTOURS-IRIS-2017-06-30%24CONTOURS-IRIS_2-1__SHP__FRA_2017-06-30/file/CONTOURS-IRIS_2-1__SHP__FRA_2017-06-30.7z&quot;, destfile = &quot;tmp/geom.7z&quot;) Il nest apparemment pas possible de décompresser le fichier avec la fonction unzip de R, donc on effectue cette opération manuellement. Il en résulte une arborescence très complexe de dossiers et de sous-dossiers correspondant aux IRIS de la Francé métropolitaine mais aussi de chacun des DOM. Il faut alors aller repérer dans cet arborescence le dossier où se trouve le fonds IRIS de la France métropolitaine qui est au format shapefile et comporte plusieurs fichiers avec des extensions différentes. list.files(&quot;tmp/CONTOURS-IRIS_2-1__SHP__FRA_2017-06-30/CONTOURS-IRIS/1_DONNEES_LIVRAISON_2016/CONTOURS-IRIS_2-1_SHP_LAMB93_FE-2016&quot;) [1] &quot;CONTOURS-IRIS.cpg&quot; &quot;CONTOURS-IRIS.dbf&quot; &quot;CONTOURS-IRIS.prj&quot; [4] &quot;CONTOURS-IRIS.shp&quot; &quot;CONTOURS-IRIS.shx&quot; &quot;LISTE.csv&quot; 1.4.2 Etape 2 : Importation et transformation au format sf La cartographie et plus généralement les opérations géométriques sur des données spatiales dans R peuvent facilement être effectuées avec le package sf (spatial features) qui crée des objets ubniques rassemblant à la fois un tableau de données (léquivalent du fichier .dbf) une géométrie (léquivalent du fichier .shp) une projection (léquivalent du fichier .prj) Lorsquon récupère des fonds de carte au format shapefile (.shp) ou dans dautres formats standards comme GeoJson, la première tâche consiste donc à les convertir au formt sf afin de pouvoir les utiliser facilement dans R. Limportation se fait à laide de linstruction st_read en indiquant juste le nom du fichier .shp à charger. Les autres fichiers (.dbf ou .proj) seront lus également et intégrés dans lobjet qui hérite de la double classe data.frame et sf library(sf) map &lt;- st_read(&quot;tmp/CONTOURS-IRIS_2-1__SHP__FRA_2017-06-30/CONTOURS-IRIS/1_DONNEES_LIVRAISON_2016/CONTOURS-IRIS_2-1_SHP_LAMB93_FE-2016/CONTOURS-IRIS.shp&quot;) Reading layer `CONTOURS-IRIS&#39; from data source `C:\\Users\\claude\\cg\\cours\\DataMining\\DataMiningProject2021\\tmp\\CONTOURS-IRIS_2-1__SHP__FRA_2017-06-30\\CONTOURS-IRIS\\1_DONNEES_LIVRAISON_2016\\CONTOURS-IRIS_2-1_SHP_LAMB93_FE-2016\\CONTOURS-IRIS.shp&#39; using driver `ESRI Shapefile&#39; Simple feature collection with 49404 features and 6 fields geometry type: MULTIPOLYGON dimension: XY bbox: xmin: 99040 ymin: 6049662 xmax: 1242445 ymax: 7110479 projected CRS: RGF93_Lambert_93 dim(map) [1] 49404 7 class(map) [1] &quot;sf&quot; &quot;data.frame&quot; head(map,2) # A tibble: 2 x 7 INSEE_COM NOM_COM IRIS CODE_IRIS NOM_IRIS TYP_IRIS geometry &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;MULTIPOLYGON [m]&gt; 1 72191 Mayet 0000 721910000 Mayet Z (((498083.5 6747517, 4981~ 2 77248 Lesches 0000 772480000 Lesches Z (((685753.1 6868613, 6857~ 1.4.3 Etape 3 : Extraction des IRIS de la zone détude Le fichier comporte près de 50 000 unités spatiales qui correspondent soit à des communes suffisamment grandes pour être découpées en IRIS, soit à des communes non découpées. On reconnaît ces dernières au fait que leur code IRIS se termine par 00000. Supposons quon veuille extraire le fonds de carte du Val de Marne. On va commencer par créer une variable DEPT en extrayant les dxeux premiers caractères du code communal, puis on va sélectionner le départements correspondant : map_iris&lt;-map %&gt;% mutate(DEPT = substr(INSEE_COM,1,2)) %&gt;% filter(DEPT %in% c(&quot;94&quot;)) dim(map_iris) [1] 527 8 class(map_iris) [1] &quot;sf&quot; &quot;data.frame&quot; head(map_iris,2) # A tibble: 2 x 8 INSEE_COM NOM_COM IRIS CODE_IRIS NOM_IRIS TYP_IRIS geometry &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;MULTIPOLYGON [m]&gt; 1 94021 Chevil~ 0107 940210107 Sorbiers H (((652774.3 6853051, 652~ 2 94068 Saint-~ 0204 940680204 Le Vieu~ H (((662096.5 6856264, 662~ # ... with 1 more variable: DEPT &lt;chr&gt; Le nouveau tableau ne comporte plus que 2749 unités spatiales et 8 colonnes au lieu de 7 puisqu lon a ajouté une colonne DEPT. On peut visualiser le résultat à laide de la fonction geom_sfdu package ggplot2 : ggplot(map_iris)+geom_sf(fill=&quot;lightyellow&quot;,col=&quot;red&quot;) + theme_void() On sauvegarde le résultat dans notre dossier data au format interne de R : saveRDS(object = map_iris, file = &quot;data/map_iris.Rdata&quot;) On peut également effectuer (de façon facultative) une sauvegarde au format shapefile afin de pouvoir réutiliser le fonds de carte à laide dautres applications externes à R. st_write(obj = map_iris, dsn= &quot;data/map_iris.shp&quot;, # indique le format de sortie par l&#39;extension .shp delete_dsn = TRUE, # écrase le fichier s&#39;il existe déjà quiet = TRUE) # évite que R fasse des commentaires 1.4.4 Etape 4 : création dun fonds de carte des communes Comme nous serons amenés à travailler à plusieurs échelles, nous produisons tout de suite un fonds de carte des communes en utilisant les fonctions dagrégation du packages sf combinées avec celles de dplyr. map_com &lt;- map_iris %&gt;% group_by(INSEE_COM) %&gt;% summarise(NOM_COM = min(NOM_COM)) %&gt;% st_as_sf() `summarise()` ungrouping output (override with `.groups` argument) on vérifie que lagrégation sest bien passée : ggplot(map_com)+geom_sf(fill=&quot;lightyellow&quot;,col=&quot;red&quot;) + theme_void() Et on sauvegarde le fonds de carte saveRDS(object = map_com, file = &quot;data/map_com.Rdata&quot;) 1.4.5 Etape 5 : création dun fonds de carte par département Enfin, on construit un fonds de carte des départements selon la même procédure : map_dep &lt;- map_iris %&gt;% mutate(DEPT = substr(INSEE_COM,1,2))%&gt;% group_by(DEPT) %&gt;% summarise() %&gt;% st_as_sf() `summarise()` ungrouping output (override with `.groups` argument) ggplot(map_dep)+geom_sf(fill=&quot;lightyellow&quot;,col=&quot;red&quot;) + theme_void() saveRDS(object = map_dep, file = &quot;data/map_dep.Rdata&quot;) 1.4.6 Etape 6: Superposition des trois fonds de carte On va utiliser la fonction plot du package sf qui permet de visualiser la variable geometry et facilite les superpositions avec linstruction add=TRUE. par(mar=c(0,0,0,0)) plot(map_iris$geometry, col= &quot;lightyellow&quot;, border = &quot;gray80&quot;, lwd=0.5) plot(map_com$geometry, col= NA, border = &quot;gray50&quot;, lwd=1, add=TRUE) plot(map_dep$geometry, col= NA, border = &quot;gray30&quot;, lwd=2, add=TRUE) 1.5 Bilan et nettoyage Nous avons désormais un dossier data qui comporte : Le fichier des individus et ses métadonnées Le fichier des logements ordinaires et ses métadonnées Les fonds de carte par iris, commune et département. list.files(&quot;data&quot;) [1] &quot;indiv2017.Rdata&quot; &quot;indiv2017_meta.Rdata&quot; &quot;logmt2017.Rdata&quot; [4] &quot;logmt2017_meta.Rdata&quot; &quot;map_com.Rdata&quot; &quot;map_dep.Rdata&quot; [7] &quot;map_iris.Rdata&quot; On peut alors décider de détruire le dossier tmp qui contient des dossiers très volumineux et pas forcément indispensables. "]]
